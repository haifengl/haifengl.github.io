<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>smile.mds documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Smile</span> <span class="project-version">2.3.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>smile</span></div></div></li><li class="depth-2 branch"><a href="smile.ai.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ai</span></div></a></li><li class="depth-2 branch"><a href="smile.classification.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>classification</span></div></a></li><li class="depth-2 branch"><a href="smile.clustering.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clustering</span></div></a></li><li class="depth-2 branch"><a href="smile.io.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-2 branch"><a href="smile.manifold.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>manifold</span></div></a></li><li class="depth-2 branch current"><a href="smile.mds.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mds</span></div></a></li><li class="depth-2"><a href="smile.regression.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>regression</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="smile.mds.html#var-isomds"><div class="inner"><span>isomds</span></div></a></li><li class="depth-1"><a href="smile.mds.html#var-mds"><div class="inner"><span>mds</span></div></a></li><li class="depth-1"><a href="smile.mds.html#var-sammon"><div class="inner"><span>sammon</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">smile.mds</h1><div class="doc"><pre class="plaintext">Multidimensional Scaling
</pre></div><div class="public anchor" id="var-isomds"><h3>isomds</h3><div class="usage"><code>(isomds proximity k)</code><code>(isomds proximity k tol max-iter)</code></div><div class="doc"><pre class="plaintext">Kruskal's nonmetric MDS.

In non-metric MDS, only the rank order of entries in the proximity matrix
(not the actual dissimilarities) is assumed to contain the significant
information. Hence, the distances of the final configuration should as
far as possible be in the same rank order as the original data. Note that
a perfect ordinal re-scaling of the data into distances is usually not
possible. The relationship is typically found using isotonic regression.

`proximity` is the nonnegative proximity matrix of dissimilarities.
The diagonal should be zero and all other elements should be positive
and symmetric.
`k` is the dimension of the projection.
`tol` is the tolerance for stopping iterations.
`max-iter` is the maximum number of iterations.</pre></div></div><div class="public anchor" id="var-mds"><h3>mds</h3><div class="usage"><code>(mds proximity k)</code><code>(mds proximity k positive)</code></div><div class="doc"><pre class="plaintext">Classical multidimensional scaling, also known as principal coordinates analysis.

Given a matrix of dissimilarities (e.g. pairwise distances), MDS
finds a set of points in low dimensional space that well-approximates the
dissimilarities in A. We are not restricted to using a Euclidean
distance metric. However, when Euclidean distances are used MDS is
equivalent to PCA.

`proximity` is the nonnegative proximity matrix of dissimilarities. The
diagonal should be zero and all other elements should be positive and
symmetric. For pairwise distances matrix, it should be just the plain
distance, not squared.

`k` is the dimension of the projection.

If `positive` is true, estimate an appropriate constant to be added
to all the dissimilarities, apart from the self-dissimilarities, that
makes the learning matrix positive semi-definite. The other formulation of
the additive constant problem is as follows. If the proximity is
measured in an interval scale, where there is no natural origin, then there
is not a sympathy of the dissimilarities to the distances in the Euclidean
space used to represent the objects. In this case, we can estimate a
constant `c` such that proximity + c may be taken as ratio data, and also
possibly to minimize the dimensionality of the Euclidean space required for
representing the objects.</pre></div></div><div class="public anchor" id="var-sammon"><h3>sammon</h3><div class="usage"><code>(sammon proximity k)</code><code>(sammon proximity k lambda tol step-tol max-iter)</code></div><div class="doc"><pre class="plaintext">Sammon's mapping.

The Sammon's mapping is an iterative technique for making interpoint
distances in the low-dimensional projection as close as possible to the
interpoint distances in the high-dimensional object. Two points close
together in the high-dimensional space should appear close together in the
projection, while two points far apart in the high dimensional space should
appear far apart in the projection. The Sammon's mapping is a special case
of metric least-square multidimensional scaling.

Ideally when we project from a high dimensional space to a low dimensional
space the image would be geometrically congruent to the original figure.
This is called an isometric projection. Unfortunately it is rarely possible
to isometrically project objects down into lower dimensional spaces. Instead
of trying to achieve equality between corresponding inter-point distances we
can minimize the difference between corresponding inter-point distances.
This is one goal of the Sammon's mapping algorithm. A second goal of the
Sammon's mapping algorithm is to preserve the topology as best as possible
by giving greater emphasize to smaller interpoint distances. The Sammon's
mapping algorithm has the advantage that whenever it is possible to
isometrically project an object into a lower dimensional space it will be
isometrically projected into the lower dimensional space. But whenever an
object cannot be projected down isometrically the Sammon's mapping projects
it down to reduce the distortion in interpoint distances and to limit the
change in the topology of the object.

The projection cannot be solved in a closed form and may be found by an
iterative algorithm such as gradient descent suggested by Sammon. Kohonen
also provides a heuristic that is simple and works reasonably well.

`proximity the nonnegative proximity matrix of dissimilarities.
The diagonal should be zero and all other elements should be positive
and symmetric.
`k` is the dimension of the projection.
`lambda` is the initial value of the step size constant in diagonal Newton
method.
`tol` is the  tolerance for stopping iterations.
`step-tol` is the tolerance on step size.
`max-iter` is the maximum number of iterations.</pre></div></div></div></body></html>