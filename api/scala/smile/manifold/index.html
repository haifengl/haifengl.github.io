<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Smile - Statistical Machine Intelligence and Learning Engine  - smile.manifold</title><meta content="Smile - Statistical Machine Intelligence and Learning Engine - smile.manifold" name="description"/><meta content="Smile Statistical Machine Intelligence and Learning Engine smile.manifold" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.min.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script></head><body><div id="search"><span id="doc-title">Smile - Statistical Machine Intelligence and Learning Engine<span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title="Smile (Statistical Machine Intelligence and Learning Engine) is a fast and comprehensive machine learning, NLP, linear algebra, graph, interpolation, and visualization system in Java and Scala."><span class="name">root</span></a></span><p class="shortcomment cmt">Smile (Statistical Machine Intelligence and Learning Engine) is
a fast and comprehensive machine learning, NLP, linear algebra,
graph, interpolation, and visualization system in Java and Scala.</p><div class="fullcomment"><div class="comment cmt"><p>Smile (Statistical Machine Intelligence and Learning Engine) is
a fast and comprehensive machine learning, NLP, linear algebra,
graph, interpolation, and visualization system in Java and Scala.
With advanced data structures and algorithms,
Smile delivers state-of-art performance.</p><p>Smile covers every aspect of machine learning, including classification,
regression, clustering, association rule mining, feature selection,
manifold learning, multidimensional scaling, genetic algorithms,
missing value imputation, efficient nearest neighbor search, etc.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.smile" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="smile" class="anchorToMember"></a><a id="smile:smile" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">smile</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="smile.association" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="association" class="anchorToMember"></a><a id="association:association" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/association/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../association/index.html" title="Frequent item set mining and association rule mining."><span class="name">association</span></a></span><p class="shortcomment cmt">Frequent item set mining and association rule mining.</p><div class="fullcomment"><div class="comment cmt"><p>Frequent item set mining and association rule mining.
Association rule learning is a popular and well researched method for
discovering interesting relations between variables in large databases.
Let I = {i<sub>1</sub>, i<sub>2</sub>,..., i<sub>n</sub>} be a set of n
binary attributes called items. Let D = {t<sub>1</sub>, t<sub>2</sub>,..., t<sub>m</sub>}
be a set of transactions called the database. Each transaction in D has a
unique transaction ID and contains a subset of the items in I.
An association rule is defined as an implication of the form X &rArr; Y
where X, Y &sube; I and X &cap; Y = &Oslash;. The item sets X and Y are called
antecedent (left-hand-side or LHS) and consequent (right-hand-side or RHS)
of the rule, respectively. The support supp(X) of an item set X is defined as
the proportion of transactions in the database which contain the item set.
Note that the support of an association rule X &rArr; Y is supp(X &cup; Y).
The confidence of a rule is defined conf(X &rArr; Y) = supp(X &cup; Y) / supp(X).
Confidence can be interpreted as an estimate of the probability P(Y | X),
the probability of finding the RHS of the rule in transactions under the
condition that these transactions also contain the LHS.</p><p>For example, the rule {onions, potatoes} &rArr; {burger} found in the sales
data of a supermarket would indicate that if a customer buys onions and
potatoes together, he or she is likely to also buy burger. Such information
can be used as the basis for decisions about marketing activities such as
promotional pricing or product placements.</p><p>Association rules are usually required to satisfy a user-specified minimum
support and a user-specified minimum confidence at the same time. Association
rule generation is usually split up into two separate steps:</p><ul><li>First, minimum support is applied to find all frequent item sets
   in a database (i.e. frequent item set mining).</li><li>Second, these frequent item sets and the minimum confidence constraint
   are used to form rules.</li></ul><p>Finding all frequent item sets in a database is difficult since it involves
searching all possible item sets (item combinations). The set of possible
item sets is the power set over I (the set of items) and has size 2<sup>n</sup> - 1
(excluding the empty set which is not a valid item set). Although the size
of the power set grows exponentially in the number of items n in I, efficient
search is possible using the downward-closure property of support
(also called anti-monotonicity) which guarantees that for a frequent item set
also all its subsets are frequent and thus for an infrequent item set, all
its supersets must be infrequent.</p><p>In practice, we may only consider the frequent item set that has the maximum
number of items bypassing all the sub item sets. An item set is maximal
frequent if none of its immediate supersets is frequent.</p><p>For a maximal frequent item set, even though we know that all the sub item
sets are frequent, we don't know the actual support of those sub item sets,
which are very important to find the association rules within the item sets.
If the final goal is association rule mining, we would like to discover
closed frequent item sets. An item set is closed if none of its immediate
supersets has the same support as the item set.</p><p>Some well known algorithms of frequent item set mining are Apriori,
Eclat and FP-Growth. Apriori is the best-known algorithm to mine association
rules. It uses a breadth-first search strategy to counting the support of
item sets and uses a candidate generation function which exploits the downward
closure property of support. Eclat is a depth-first search algorithm using
set intersection.</p><p>FP-growth (frequent pattern growth) uses an extended prefix-tree (FP-tree)
structure to store the database in a compressed form. FP-growth adopts a
divide-and-conquer approach to decompose both the mining tasks and the
databases. It uses a pattern fragment growth method to avoid the costly
process of candidate generation and testing used by Apriori.</p><h6>References:</h6><ul><li>R. Agrawal, T. Imielinski and A. Swami. Mining Association Rules Between Sets of Items in Large Databases, SIGMOD, 207-216, 1993.</li><li>Rakesh Agrawal and Ramakrishnan Srikant. Fast algorithms for mining association rules in large databases. VLDB, 487-499, 1994.</li><li>Mohammed J. Zaki. Scalable algorithms for association mining. IEEE Transactions on Knowledge and Data Engineering, 12(3):372-390, 2000.</li><li>Jiawei Han, Jian Pei, Yiwen Yin, and Runying Mao. Mining frequent patterns without candidate generation. Data Mining and Knowledge Discovery 8:53-87, 2004.
</li></ul></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.cas" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="cas" class="anchorToMember"></a><a id="cas:cas" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/cas/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../cas/index.html" title="Computer algebra system."><span class="name">cas</span></a></span><p class="shortcomment cmt">Computer algebra system.</p><div class="fullcomment"><div class="comment cmt"><p>Computer algebra system.
A computer algebra system (CAS) has the ability to manipulate mathematical
expressions in a way similar to the traditional manual computations of
mathematicians and scientists.</p><p>The symbolic manipulations supported include:</p><ul><li>simplification to a smaller expression or some standard form,
including automatic simplification with assumptions and
simplification with constraints</li><li>substitution of symbols or numeric values for certain expressions</li><li>change of form of expressions: expanding products and powers, partial
and full factorization, rewriting as partial fractions, constraint
satisfaction, rewriting trigonometric functions as exponentials,
transforming logic expressions, etc.</li><li>partial and total differentiation</li><li>matrix operations including products, inverses, etc.
</li></ul></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.classification" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="classification" class="anchorToMember"></a><a id="classification:classification" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/classification/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../classification/index.html" title="Classification algorithms."><span class="name">classification</span></a></span><p class="shortcomment cmt">Classification algorithms.</p><div class="fullcomment"><div class="comment cmt"><p>Classification algorithms. In machine learning and pattern recognition,
classification refers to an algorithmic procedure for assigning a given
input object into one of a given number of categories. The input
object is formally termed an instance, and the categories are termed classes.</p><p>The instance is usually described by a vector of features, which together
constitute a description of all known characteristics of the instance.
Typically, features are either categorical (also known as nominal, i.e.
consisting of one of a set of unordered items, such as a gender of "male"
or "female", or a blood type of "A", "B", "AB" or "O"), ordinal (consisting
of one of a set of ordered items, e.g. "large", "medium" or "small"),
integer-valued (e.g. a count of the number of occurrences of a particular
word in an email) or real-valued (e.g. a measurement of blood pressure).</p><p>Classification normally refers to a supervised procedure, i.e. a procedure
that produces an inferred function to predict the output value of new
instances based on a training set of pairs consisting of an input object
and a desired output value. The inferred function is called a classifier
if the output is discrete or a regression function if the output is
continuous.</p><p>The inferred function should predict the correct output value for any valid
input object. This requires the learning algorithm to generalize from the
training data to unseen situations in a "reasonable" way.</p><p>A wide range of supervised learning algorithms is available, each with
its strengths and weaknesses. There is no single learning algorithm that
works best on all supervised learning problems. The most widely used
learning algorithms are AdaBoost and gradient boosting, support vector
machines, linear regression, linear discriminant analysis, logistic
regression, naive Bayes, decision trees, k-nearest neighbor algorithm,
and neural networks (multilayer perceptron).</p><p>If the feature vectors include features of many different kinds (discrete,
discrete ordered, counts, continuous values), some algorithms cannot be
easily applied. Many algorithms, including linear regression, logistic
regression, neural networks, and nearest neighbor methods, require that
the input features be numerical and scaled to similar ranges (e.g., to
the [-1,1] interval). Methods that employ a distance function, such as
nearest neighbor methods and support vector machines with Gaussian kernels,
are particularly sensitive to this. An advantage of decision trees (and
boosting algorithms based on decision trees) is that they easily handle
heterogeneous data.</p><p>If the input features contain redundant information (e.g., highly correlated
features), some learning algorithms (e.g., linear regression, logistic
regression, and distance based methods) will perform poorly because of
numerical instabilities. These problems can often be solved by imposing
some form of regularization.</p><p>If each of the features makes an independent contribution to the output,
then algorithms based on linear functions (e.g., linear regression,
logistic regression, linear support vector machines, naive Bayes) generally
perform well. However, if there are complex interactions among features,
then algorithms such as nonlinear support vector machines, decision trees
and neural networks work better. Linear methods can also be applied, but
the engineer must manually specify the interactions when using them.</p><p>There are several major issues to consider in supervised learning:</p><ul><li><b>Features:</b>
The accuracy of the inferred function depends strongly on how the input
object is represented. Typically, the input object is transformed into
a feature vector, which contains a number of features that are descriptive
of the object. The number of features should not be too large, because of
the curse of dimensionality; but should contain enough information to
accurately predict the output.
There are many algorithms for feature selection that seek to identify
the relevant features and discard the irrelevant ones. More generally,
dimensionality reduction may seek to map the input data into a lower
dimensional space prior to running the supervised learning algorithm.</li><li><b>Overfitting:</b>
Overfitting occurs when a statistical model describes random error
or noise instead of the underlying relationship. Overfitting generally
occurs when a model is excessively complex, such as having too many
parameters relative to the number of observations. A model which has
been overfit will generally have poor predictive performance, as it can
exaggerate minor fluctuations in the data.
The potential for overfitting depends not only on the number of parameters
and data but also the conformability of the model structure with the data
shape, and the magnitude of model error compared to the expected level
of noise or error in the data.
In order to avoid overfitting, it is necessary to use additional techniques
(e.g. cross-validation, regularization, early stopping, pruning, Bayesian
priors on parameters or model comparison), that can indicate when further
training is not resulting in better generalization. The basis of some
techniques is either (1) to explicitly penalize overly complex models,
or (2) to test the model's ability to generalize by evaluating its
performance on a set of data not used for training, which is assumed to
approximate the typical unseen data that a model will encounter.</li><li><b>Regularization:</b>
Regularization involves introducing additional information in order
to solve an ill-posed problem or to prevent over-fitting. This information
is usually of the form of a penalty for complexity, such as restrictions
for smoothness or bounds on the vector space norm.
A theoretical justification for regularization is that it attempts to impose
Occam's razor on the solution. From a Bayesian point of view, many
regularization techniques correspond to imposing certain prior distributions
on model parameters.</li><li><b>Bias-variance tradeoff:</b>
Mean squared error (MSE) can be broken down into two components:
variance and squared bias, known as the bias-variance decomposition.
Thus in order to minimize the MSE, we need to minimize both the bias and
the variance. However, this is not trivial. Therefore, there is a tradeoff
between bias and variance.
</li></ul></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.clustering" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clustering" class="anchorToMember"></a><a id="clustering:clustering" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/clustering/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../clustering/index.html" title="Clustering analysis."><span class="name">clustering</span></a></span><p class="shortcomment cmt">Clustering analysis.</p><div class="fullcomment"><div class="comment cmt"><p>Clustering analysis. Clustering is the assignment of a set of observations
into subsets (called clusters) so that observations in the same cluster are
similar in some sense. Clustering is a method of unsupervised learning,
and a common technique for statistical data analysis used in many fields.</p><p>Hierarchical algorithms find successive clusters using previously
established clusters. These algorithms usually are either agglomerative
("bottom-up") or divisive ("top-down"). Agglomerative algorithms begin
with each element as a separate cluster and merge them into successively
larger clusters. Divisive algorithms begin with the whole set and proceed
to divide it into successively smaller clusters.</p><p>Partitional algorithms typically determine all clusters at once, but can
also be used as divisive algorithms in the hierarchical clustering.
Many partitional clustering algorithms require the specification of
the number of clusters to produce in the input data set, prior to
execution of the algorithm. Barring knowledge of the proper value
beforehand, the appropriate value must be determined, a problem on
its own for which a number of techniques have been developed.</p><p>Density-based clustering algorithms are devised to discover
arbitrary-shaped clusters. In this approach, a cluster is regarded as
a region in which the density of data objects exceeds a threshold.</p><p>Subspace clustering methods look for clusters that can only be seen in
a particular projection (subspace, manifold) of the data. These methods
thus can ignore irrelevant attributes. The general problem is also known
as Correlation clustering while the special case of axis-parallel subspaces
is also known as two-way clustering, co-clustering or biclustering in
bioinformatics: in these methods not only the objects are clustered but
also the features of the objects, i.e., if the data is represented in
a data matrix, the rows and columns are clustered simultaneously. They
usually do not however work with arbitrary feature combinations as in general
subspace methods.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.data" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="data" class="anchorToMember"></a><a id="data:data" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/data/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../data/index.html" title="Data manipulation functions."><span class="name">data</span></a></span><p class="shortcomment cmt">Data manipulation functions.</p><div class="fullcomment"><div class="comment cmt"><p>Data manipulation functions.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.feature" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="feature" class="anchorToMember"></a><a id="feature:feature" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/feature/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../feature/index.html" title=""><span class="name">feature</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 current" name="smile.manifold" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="manifold" class="anchorToMember"></a><a id="manifold:manifold" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/manifold/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">manifold</span></span><p class="shortcomment cmt">Manifold learning finds a low-dimensional basis for describing
high-dimensional data.</p><div class="fullcomment"><div class="comment cmt"><p>Manifold learning finds a low-dimensional basis for describing
high-dimensional data. Manifold learning is a popular approach to nonlinear
dimensionality reduction. Algorithms for this task are based on the idea
that the dimensionality of many data sets is only artificially high; though
each data point consists of perhaps thousands of features, it may be
described as a function of only a few underlying parameters. That is, the
data points are actually samples from a low-dimensional manifold that is
embedded in a high-dimensional space. Manifold learning algorithms attempt
to uncover these parameters in order to find a low-dimensional representation
of the data.</p><p>Some prominent approaches are locally linear embedding
(LLE), Hessian LLE, Laplacian eigenmaps, and LTSA. These techniques
construct a low-dimensional data representation using a cost function
that retains local properties of the data, and can be viewed as defining
a graph-based kernel for Kernel PCA. More recently, techniques have been
proposed that, instead of defining a fixed kernel, try to learn the kernel
using semidefinite programming. The most prominent example of such a
technique is maximum variance unfolding (MVU). The central idea of MVU
is to exactly preserve all pairwise distances between nearest neighbors
(in the inner product space), while maximizing the distances between points
that are not nearest neighbors.</p><p>An alternative approach to neighborhood preservation is through the
minimization of a cost function that measures differences between
distances in the input and output spaces. Important examples of such
techniques include classical multidimensional scaling (which is identical
to PCA), Isomap (which uses geodesic distances in the data space), diffusion
maps (which uses diffusion distances in the data space), t-SNE (which
minimizes the divergence between distributions over pairs of points),
and curvilinear component analysis.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="current-entities indented2"><span class="separator"></span> <a href="package$$$dummy$.html" title="Hacking scaladoc issue-8124." class="object"></a><a href="package$$$dummy$.html" title="Hacking scaladoc issue-8124.">$dummy</a></li><li class="indented2 " name="smile.math" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="math" class="anchorToMember"></a><a id="math:math" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/math/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../math/index.html" title="Mathematical and statistical functions."><span class="name">math</span></a></span><p class="shortcomment cmt">Mathematical and statistical functions.</p><div class="fullcomment"><div class="comment cmt"><p>Mathematical and statistical functions.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.nlp" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="nlp" class="anchorToMember"></a><a id="nlp:nlp" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/nlp/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../nlp/index.html" title="Natural language processing."><span class="name">nlp</span></a></span><p class="shortcomment cmt">Natural language processing.</p><div class="fullcomment"><div class="comment cmt"><p>Natural language processing.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.plot" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="plot" class="anchorToMember"></a><a id="plot:plot" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/plot/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../plot/index.html" title="Data visualization."><span class="name">plot</span></a></span><p class="shortcomment cmt">Data visualization.</p><div class="fullcomment"><div class="comment cmt"><p>Data visualization.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.regression" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="regression" class="anchorToMember"></a><a id="regression:regression" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/regression/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../regression/index.html" title="Regression analysis."><span class="name">regression</span></a></span><p class="shortcomment cmt">Regression analysis.</p><div class="fullcomment"><div class="comment cmt"><p>Regression analysis. Regression analysis includes any
techniques for modeling and analyzing several variables, when the focus
is on the relationship between a dependent variable and one or more
independent variables. Most commonly, regression analysis estimates the
conditional expectation of the dependent variable given the independent
variables. Therefore, the estimation target is a function of the independent
variables called the regression function. Regression analysis is widely
used for prediction and forecasting.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.sequence" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sequence" class="anchorToMember"></a><a id="sequence:sequence" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/sequence/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../sequence/index.html" title="Sequence labeling algorithms."><span class="name">sequence</span></a></span><p class="shortcomment cmt">Sequence labeling algorithms.</p><div class="fullcomment"><div class="comment cmt"><p>Sequence labeling algorithms.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.util" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="util" class="anchorToMember"></a><a id="util:util" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/util/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../util/index.html" title="Utility functions."><span class="name">util</span></a></span><p class="shortcomment cmt">Utility functions.</p><div class="fullcomment"><div class="comment cmt"><p>Utility functions.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.validation" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="validation" class="anchorToMember"></a><a id="validation:validation" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/validation/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../validation/index.html" title="Model validation."><span class="name">validation</span></a></span><p class="shortcomment cmt">Model validation.</p><div class="fullcomment"><div class="comment cmt"><p>Model validation.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.wavelet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wavelet" class="anchorToMember"></a><a id="wavelet:wavelet" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/wavelet/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../wavelet/index.html" title="A wavelet is a wave-like oscillation with an amplitude that starts out at zero, increases, and then decreases back to zero."><span class="name">wavelet</span></a></span><p class="shortcomment cmt">A wavelet is a wave-like oscillation with an amplitude that starts out at
zero, increases, and then decreases back to zero.</p><div class="fullcomment"><div class="comment cmt"><p>A wavelet is a wave-like oscillation with an amplitude that starts out at
zero, increases, and then decreases back to zero. Like the fast Fourier
transform (FFT), the discrete wavelet transform (DWT) is a fast, linear
operation that operates on a data vector whose length is an integer power
of 2, transforming it into a numerically different vector of the same length.
The wavelet transform is invertible and in fact orthogonal. Both FFT and DWT
can be viewed as a rotation in function space.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><p id="owner"><a href="../index.html" name="smile" id="smile" class="extype">smile</a></p><h1>manifold<span class="permalink"><a href="../../smile/manifold/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">manifold</span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Manifold learning finds a low-dimensional basis for describing
high-dimensional data. Manifold learning is a popular approach to nonlinear
dimensionality reduction. Algorithms for this task are based on the idea
that the dimensionality of many data sets is only artificially high; though
each data point consists of perhaps thousands of features, it may be
described as a function of only a few underlying parameters. That is, the
data points are actually samples from a low-dimensional manifold that is
embedded in a high-dimensional space. Manifold learning algorithms attempt
to uncover these parameters in order to find a low-dimensional representation
of the data.</p><p>Some prominent approaches are locally linear embedding
(LLE), Hessian LLE, Laplacian eigenmaps, and LTSA. These techniques
construct a low-dimensional data representation using a cost function
that retains local properties of the data, and can be viewed as defining
a graph-based kernel for Kernel PCA. More recently, techniques have been
proposed that, instead of defining a fixed kernel, try to learn the kernel
using semidefinite programming. The most prominent example of such a
technique is maximum variance unfolding (MVU). The central idea of MVU
is to exactly preserve all pairwise distances between nearest neighbors
(in the inner product space), while maximizing the distances between points
that are not nearest neighbors.</p><p>An alternative approach to neighborhood preservation is through the
minimization of a cost function that measures differences between
distances in the input and output spaces. Important examples of such
techniques include classical multidimensional scaling (which is identical
to PCA), Isomap (which uses geodesic distances in the data space), diffusion
maps (which uses diffusion distances in the data space), t-SNE (which
minimizes the divergence between distributions over pairs of points),
and curvilinear component analysis.
</p></div><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="https://www.scala-lang.org/api/2.13.10/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>, <a href="https://www.scala-lang.org/api/2.13.10/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="smile.manifold"><span>manifold</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="smile.manifold#isomap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isomap(data:Array[Array[Double]],k:Int,d:Int,CIsomap:Boolean):smile.manifold.IsoMap" class="anchorToMember"></a><a id="isomap(Array[Array[Double]],Int,Int,Boolean):IsoMap" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/manifold/index.html#isomap(data:Array[Array[Double]],k:Int,d:Int,CIsomap:Boolean):smile.manifold.IsoMap" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isomap</span><span class="params">(<span name="data">data: <a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]]</span>, <span name="k">k: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="d">d: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">2</span></span>, <span name="CIsomap">CIsomap: <a href="https://www.scala-lang.org/api/2.13.10/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">true</span></span>)</span><span class="result">: <span name="smile.manifold.IsoMap" class="extype">IsoMap</span></span></span><p class="shortcomment cmt">Isometric feature mapping.</p><div class="fullcomment"><div class="comment cmt"><p>Isometric feature mapping. Isomap is a widely used low-dimensional embedding methods,
where geodesic distances on a weighted graph are incorporated with the
classical multidimensional scaling. Isomap is used for computing a
quasi-isometric, low-dimensional embedding of a set of high-dimensional
data points. Isomap is highly efficient and generally applicable to a broad
range of data sources and dimensionalities.</p><p>To be specific, the classical MDS performs low-dimensional embedding based
on the pairwise distance between data points, which is generally measured
using straight-line Euclidean distance. Isomap is distinguished by
its use of the geodesic distance induced by a neighborhood graph
embedded in the classical scaling. This is done to incorporate manifold
structure in the resulting embedding. Isomap defines the geodesic distance
to be the sum of edge weights along the shortest path between two nodes.
The top n eigenvectors of the geodesic distance matrix, represent the
coordinates in the new n-dimensional Euclidean space.</p><p>The connectivity of each data point in the neighborhood graph is defined
as its nearest k Euclidean neighbors in the high-dimensional space. This
step is vulnerable to "short-circuit errors" if k is too large with
respect to the manifold structure or if noise in the data moves the
points slightly off the manifold. Even a single short-circuit error
can alter many entries in the geodesic distance matrix, which in turn
can lead to a drastically different (and incorrect) low-dimensional
embedding. Conversely, if k is too small, the neighborhood graph may
become too sparse to approximate geodesic paths accurately.</p><p>This class implements C-Isomap that involves magnifying the regions
of high density and shrink the regions of low density of data points
in the manifold. Edge weights that are maximized in Multi-Dimensional
Scaling(MDS) are modified, with everything else remaining unaffected.</p><h6>References:</h6><ul><li>J. B. Tenenbaum, V. de Silva and J. C. Langford  A Global Geometric Framework for Nonlinear Dimensionality Reduction. Science 290(5500):2319-2323, 2000.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>k-nearest neighbor.</p></dd><dt class="param">d</dt><dd class="cmt"><p>the dimension of the manifold.</p></dd><dt class="param">CIsomap</dt><dd class="cmt"><p>C-Isomap algorithm if true, otherwise standard algorithm.</p></dd></dl></div></li><li class="indented0 " name="smile.manifold#isomds" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isomds(proximity:Array[Array[Double]],k:Int,tol:Double,maxIter:Int):smile.manifold.IsotonicMDS" class="anchorToMember"></a><a id="isomds(Array[Array[Double]],Int,Double,Int):IsotonicMDS" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/manifold/index.html#isomds(proximity:Array[Array[Double]],k:Int,tol:Double,maxIter:Int):smile.manifold.IsotonicMDS" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isomds</span><span class="params">(<span name="proximity">proximity: <a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]]</span>, <span name="k">k: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="tol">tol: <a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">0.0001</span></span>, <span name="maxIter">maxIter: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">200</span></span>)</span><span class="result">: <span name="smile.manifold.IsotonicMDS" class="extype">IsotonicMDS</span></span></span><p class="shortcomment cmt">Kruskal's nonmetric MDS.</p><div class="fullcomment"><div class="comment cmt"><p>Kruskal's nonmetric MDS. In non-metric MDS, only the rank order of entries
in the proximity matrix (not the actual dissimilarities) is assumed to
contain the significant information. Hence, the distances of the final
configuration should as far as possible be in the same rank order as the
original data. Note that a perfect ordinal re-scaling of the data into
distances is usually not possible. The relationship is typically found
using isotonic regression.
</p></div><dl class="paramcmts block"><dt class="param">proximity</dt><dd class="cmt"><p>the non-negative proximity matrix of dissimilarities. The
                 diagonal should be zero and all other elements should be positive and symmetric.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the dimension of the projection.</p></dd><dt class="param">tol</dt><dd class="cmt"><p>tolerance for stopping iterations.</p></dd><dt class="param">maxIter</dt><dd class="cmt"><p>maximum number of iterations.</p></dd></dl></div></li><li class="indented0 " name="smile.manifold#laplacian" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="laplacian(data:Array[Array[Double]],k:Int,d:Int,t:Double):smile.manifold.LaplacianEigenmap" class="anchorToMember"></a><a id="laplacian(Array[Array[Double]],Int,Int,Double):LaplacianEigenmap" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/manifold/index.html#laplacian(data:Array[Array[Double]],k:Int,d:Int,t:Double):smile.manifold.LaplacianEigenmap" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">laplacian</span><span class="params">(<span name="data">data: <a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]]</span>, <span name="k">k: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="d">d: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">2</span></span>, <span name="t">t: <a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">-1</span></span>)</span><span class="result">: <span name="smile.manifold.LaplacianEigenmap" class="extype">LaplacianEigenmap</span></span></span><p class="shortcomment cmt">Laplacian Eigenmap.</p><div class="fullcomment"><div class="comment cmt"><p>Laplacian Eigenmap. Using the notion of the Laplacian of the nearest
neighbor adjacency graph, Laplacian Eigenmap compute a low dimensional
representation of the dataset that optimally preserves local neighborhood
information in a certain sense. The representation map generated by the
algorithm may be viewed as a discrete approximation to a continuous map
that naturally arises from the geometry of the manifold.</p><p>The locality preserving character of the Laplacian Eigenmap algorithm makes
it relatively insensitive to outliers and noise. It is also not prone to
"short circuiting" as only the local distances are used.</p><h6>References:</h6><ul><li>Mikhail Belkin and Partha Niyogi. Laplacian Eigenmaps and Spectral Techniques for Embedding and Clustering. NIPS, 2001.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>k-nearest neighbor.</p></dd><dt class="param">d</dt><dd class="cmt"><p>the dimension of the manifold.</p></dd><dt class="param">t</dt><dd class="cmt"><p>the smooth/width parameter of heat kernel e<sup>-||x-y||<sup>2</sup> / t</sup>.
         Non-positive value means discrete weights.</p></dd></dl></div></li><li class="indented0 " name="smile.manifold#lle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lle(data:Array[Array[Double]],k:Int,d:Int):smile.manifold.LLE" class="anchorToMember"></a><a id="lle(Array[Array[Double]],Int,Int):LLE" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/manifold/index.html#lle(data:Array[Array[Double]],k:Int,d:Int):smile.manifold.LLE" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lle</span><span class="params">(<span name="data">data: <a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]]</span>, <span name="k">k: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="d">d: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">2</span></span>)</span><span class="result">: <span name="smile.manifold.LLE" class="extype">LLE</span></span></span><p class="shortcomment cmt">Locally Linear Embedding.</p><div class="fullcomment"><div class="comment cmt"><p>Locally Linear Embedding. It has several advantages over Isomap, including
faster optimization when implemented to take advantage of sparse matrix
algorithms, and better results with many problems. LLE also begins by
finding a set of the nearest neighbors of each point. It then computes
a set of weights for each point that best describe the point as a linear
combination of its neighbors. Finally, it uses an eigenvector-based
optimization technique to find the low-dimensional embedding of points,
such that each point is still described with the same linear combination
of its neighbors. LLE tends to handle non-uniform sample densities poorly
because there is no fixed unit to prevent the weights from drifting as
various regions differ in sample densities.</p><h6>References:</h6><ul><li>Sam T. Roweis and Lawrence K. Saul. Nonlinear Dimensionality Reduction by Locally Linear Embedding. Science 290(5500):2323-2326, 2000.
</li></ul></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the data set.</p></dd><dt class="param">k</dt><dd class="cmt"><p>k-nearest neighbor.</p></dd><dt class="param">d</dt><dd class="cmt"><p>the dimension of the manifold.</p></dd></dl></div></li><li class="indented0 " name="smile.manifold#mds" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mds(proximity:Array[Array[Double]],k:Int,positive:Boolean):smile.manifold.MDS" class="anchorToMember"></a><a id="mds(Array[Array[Double]],Int,Boolean):MDS" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/manifold/index.html#mds(proximity:Array[Array[Double]],k:Int,positive:Boolean):smile.manifold.MDS" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mds</span><span class="params">(<span name="proximity">proximity: <a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]]</span>, <span name="k">k: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="positive">positive: <a href="https://www.scala-lang.org/api/2.13.10/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">false</span></span>)</span><span class="result">: <span name="smile.manifold.MDS" class="extype">MDS</span></span></span><p class="shortcomment cmt">Classical multidimensional scaling, also known as principal coordinates
analysis.</p><div class="fullcomment"><div class="comment cmt"><p>Classical multidimensional scaling, also known as principal coordinates
analysis. Given a matrix of dissimilarities (e.g. pairwise distances), MDS
finds a set of points in low dimensional space that well-approximates the
dissimilarities in A. We are not restricted to using a Euclidean
distance metric. However, when Euclidean distances are used MDS is
equivalent to PCA.
</p></div><dl class="paramcmts block"><dt class="param">proximity</dt><dd class="cmt"><p>the non-negative proximity matrix of dissimilarities. The
                 diagonal should be zero and all other elements should be positive and
                 symmetric. For pairwise distances matrix, it should be just the plain
                 distance, not squared.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the dimension of the projection.</p></dd><dt class="param">positive</dt><dd class="cmt"><p>if true, estimate an appropriate constant to be added
           to all the dissimilarities, apart from the self-dissimilarities, that
           makes the learning matrix positive semi-definite. The other formulation of
           the additive constant problem is as follows. If the proximity is
           measured in an interval scale, where there is no natural origin, then there
           is not a sympathy of the dissimilarities to the distances in the Euclidean
           space used to represent the objects. In this case, we can estimate a constant c
           such that proximity + c may be taken as ratio data, and also possibly
           to minimize the dimensionality of the Euclidean space required for
           representing the objects.</p></dd></dl></div></li><li class="indented0 " name="smile.manifold#sammon" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sammon(proximity:Array[Array[Double]],k:Int,lambda:Double,tol:Double,stepTol:Double,maxIter:Int):smile.manifold.SammonMapping" class="anchorToMember"></a><a id="sammon(Array[Array[Double]],Int,Double,Double,Double,Int):SammonMapping" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/manifold/index.html#sammon(proximity:Array[Array[Double]],k:Int,lambda:Double,tol:Double,stepTol:Double,maxIter:Int):smile.manifold.SammonMapping" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sammon</span><span class="params">(<span name="proximity">proximity: <a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]]</span>, <span name="k">k: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="lambda">lambda: <a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">0.2</span></span>, <span name="tol">tol: <a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">0.0001</span></span>, <span name="stepTol">stepTol: <a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">0.001</span></span>, <span name="maxIter">maxIter: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">100</span></span>)</span><span class="result">: <span name="smile.manifold.SammonMapping" class="extype">SammonMapping</span></span></span><p class="shortcomment cmt">The Sammon's mapping is an iterative technique for making interpoint
distances in the low-dimensional projection as close as possible to the
interpoint distances in the high-dimensional object.</p><div class="fullcomment"><div class="comment cmt"><p>The Sammon's mapping is an iterative technique for making interpoint
distances in the low-dimensional projection as close as possible to the
interpoint distances in the high-dimensional object. Two points close
together in the high-dimensional space should appear close together in the
projection, while two points far apart in the high dimensional space should
appear far apart in the projection. The Sammon's mapping is a special case of
metric least-square multidimensional scaling.</p><p>Ideally when we project from a high dimensional space to a low dimensional
space the image would be geometrically congruent to the original figure.
This is called an isometric projection. Unfortunately it is rarely possible
to isometrically project objects down into lower dimensional spaces. Instead of
trying to achieve equality between corresponding inter-point distances we
can minimize the difference between corresponding inter-point distances.
This is one goal of the Sammon's mapping algorithm. A second goal of the Sammon's
mapping algorithm is to preserve the topology as best as possible by giving
greater emphasize to smaller interpoint distances. The Sammon's mapping
algorithm has the advantage that whenever it is possible to isometrically
project an object into a lower dimensional space it will be isometrically
projected into the lower dimensional space. But whenever an object cannot
be projected down isometrically the Sammon's mapping projects it down to reduce
the distortion in interpoint distances and to limit the change in the
topology of the object.</p><p>The projection cannot be solved in a closed form and may be found by an
iterative algorithm such as gradient descent suggested by Sammon. Kohonen
also provides a heuristic that is simple and works reasonably well.
</p></div><dl class="paramcmts block"><dt class="param">proximity</dt><dd class="cmt"><p>the non-negative proximity matrix of dissimilarities. The
                 diagonal should be zero and all other elements should be positive and symmetric.</p></dd><dt class="param">k</dt><dd class="cmt"><p>the dimension of the projection.</p></dd><dt class="param">lambda</dt><dd class="cmt"><p>initial value of the step size constant in diagonal Newton method.</p></dd><dt class="param">tol</dt><dd class="cmt"><p>tolerance for stopping iterations.</p></dd><dt class="param">stepTol</dt><dd class="cmt"><p>tolerance on step size.</p></dd><dt class="param">maxIter</dt><dd class="cmt"><p>maximum number of iterations.</p></dd></dl></div></li><li class="indented0 " name="smile.manifold#tsne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="tsne(X:Array[Array[Double]],d:Int,perplexity:Double,eta:Double,iterations:Int):smile.manifold.TSNE" class="anchorToMember"></a><a id="tsne(Array[Array[Double]],Int,Double,Double,Int):TSNE" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/manifold/index.html#tsne(X:Array[Array[Double]],d:Int,perplexity:Double,eta:Double,iterations:Int):smile.manifold.TSNE" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">tsne</span><span class="params">(<span name="X">X: <a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]]</span>, <span name="d">d: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">2</span></span>, <span name="perplexity">perplexity: <a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">20.0</span></span>, <span name="eta">eta: <a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">200.0</span></span>, <span name="iterations">iterations: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">1000</span></span>)</span><span class="result">: <span name="smile.manifold.TSNE" class="extype">TSNE</span></span></span><p class="shortcomment cmt">t-distributed stochastic neighbor embedding.</p><div class="fullcomment"><div class="comment cmt"><p>t-distributed stochastic neighbor embedding. t-SNE is a nonlinear
dimensionality reduction technique that is particularly well suited
for embedding high-dimensional data into a space of two or three
dimensions, which can then be visualized in a scatter plot. Specifically,
it models each high-dimensional object by a two- or three-dimensional
point in such a way that similar objects are modeled by nearby points
and dissimilar objects are modeled by distant points.</p><h6>References:</h6><ul><li>L.J.P. van der Maaten. Accelerating t-SNE using Tree-Based Algorithms. Journal of Machine Learning Research 15(Oct):3221-3245, 2014.</li><li>L.J.P. van der Maaten and G.E. Hinton. Visualizing Non-Metric Similarities in Multiple Maps. Machine Learning 87(1):33-55, 2012.</li><li>L.J.P. van der Maaten. Learning a Parametric Embedding by Preserving Local Structure. In Proceedings of the Twelfth International Conference on Artificial Intelligence &amp; Statistics (AI-STATS), JMLR W&amp;CP 5:384-391, 2009.</li><li>L.J.P. van der Maaten and G.E. Hinton. Visualizing High-Dimensional Data Using t-SNE. Journal of Machine Learning Research 9(Nov):2579-2605, 2008.
</li></ul></div><dl class="paramcmts block"><dt class="param">X</dt><dd class="cmt"><p>input data. If X is a square matrix, it is assumed to be the squared distance/dissimilarity matrix.</p></dd><dt class="param">d</dt><dd class="cmt"><p>the dimension of the manifold.</p></dd><dt class="param">perplexity</dt><dd class="cmt"><p>the perplexity of the conditional distribution.</p></dd><dt class="param">eta</dt><dd class="cmt"><p>the learning rate.</p></dd><dt class="param">iterations</dt><dd class="cmt"><p>the number of iterations.</p></dd></dl></div></li><li class="indented0 " name="smile.manifold#umap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="umap(data:Array[Array[Double]],k:Int,d:Int,iterations:Int,learningRate:Double,minDist:Double,spread:Double,negativeSamples:Int,repulsionStrength:Double):smile.manifold.UMAP" class="anchorToMember"></a><a id="umap(Array[Array[Double]],Int,Int,Int,Double,Double,Double,Int,Double):UMAP" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/manifold/index.html#umap(data:Array[Array[Double]],k:Int,d:Int,iterations:Int,learningRate:Double,minDist:Double,spread:Double,negativeSamples:Int,repulsionStrength:Double):smile.manifold.UMAP" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">umap</span><span class="params">(<span name="data">data: <a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]]</span>, <span name="k">k: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">15</span></span>, <span name="d">d: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">2</span></span>, <span name="iterations">iterations: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">0</span></span>, <span name="learningRate">learningRate: <a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">1.0</span></span>, <span name="minDist">minDist: <a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">0.1</span></span>, <span name="spread">spread: <a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">1.0</span></span>, <span name="negativeSamples">negativeSamples: <a href="https://www.scala-lang.org/api/2.13.10/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">5</span></span>, <span name="repulsionStrength">repulsionStrength: <a href="https://www.scala-lang.org/api/2.13.10/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">1.0</span></span>)</span><span class="result">: <span name="smile.manifold.UMAP" class="extype">UMAP</span></span></span><p class="shortcomment cmt">Uniform Manifold Approximation and Projection.</p><div class="fullcomment"><div class="comment cmt"><p>Uniform Manifold Approximation and Projection.</p><p>UMAP is a dimension reduction technique that can be used for visualization
similarly to t-SNE, but also for general non-linear dimension reduction.
The algorithm is founded on three assumptions about the data:</p><ul><li>The data is uniformly distributed on a Riemannian manifold;</li><li>The Riemannian metric is locally constant (or can be approximated as such);</li><li>The manifold is locally connected.</li></ul><p>From these assumptions it is possible to model the manifold with a fuzzy
topological structure. The embedding is found by searching for a low
dimensional projection of the data that has the closest possible equivalent
fuzzy topological structure.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>the input data.</p></dd><dt class="param">k</dt><dd class="cmt"><p>k-nearest neighbors. Larger values result in more global views
                          of the manifold, while smaller values result in more local data
                          being preserved. Generally in the range 2 to 100.</p></dd><dt class="param">d</dt><dd class="cmt"><p>The target embedding dimensions. defaults to 2 to provide easy
                          visualization, but can reasonably be set to any integer value
                          in the range 2 to 100.</p></dd><dt class="param">iterations</dt><dd class="cmt"><p>The number of iterations to optimize the
                          low-dimensional representation. Larger values result in more
                          accurate embedding. Muse be greater than 10. Choose wise value
                          based on the size of the input data, e.g, 200 for large
                          data (1000+ samples), 500 for small.</p></dd><dt class="param">learningRate</dt><dd class="cmt"><p>The initial learning rate for the embedding optimization,
                          default 1.</p></dd><dt class="param">minDist</dt><dd class="cmt"><p>The desired separation between close points in the embedding
                          space. Smaller values will result in a more clustered/clumped
                          embedding where nearby points on the manifold are drawn closer
                          together, while larger values will result on a more even
                          disperse of points. The value should be set no-greater than
                          and relative to the spread value, which determines the scale
                          at which embedded points will be spread out. default 0.1.</p></dd><dt class="param">spread</dt><dd class="cmt"><p>The effective scale of embedded points. In combination with
                          minDist, this determines how clustered/clumped the embedded
                          points are. default 1.0.</p></dd><dt class="param">negativeSamples</dt><dd class="cmt"><p>The number of negative samples to select per positive sample
                          in the optimization process. Increasing this value will result
                          in greater repulsive force being applied, greater optimization
                          cost, but slightly more accuracy, default 5.</p></dd><dt class="param">repulsionStrength</dt><dd class="cmt"><p>Weighting applied to negative samples in low dimensional
                          embedding optimization. Values higher than one will result in
                          greater weight being given to negative samples, default 1.0.</p></dd></dl></div></li><li class="indented0 " name="smile.manifold.$dummy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="$dummy" class="anchorToMember"></a><a id="$dummy:$dummy" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/manifold/package$$$dummy$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="package$$$dummy$.html" title="Hacking scaladoc issue-8124."><span class="name">$dummy</span></a></span><p class="shortcomment cmt">Hacking scaladoc <a href="https://github.com/scala/bug/issues/8124" target="_blank">issue-8124</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Hacking scaladoc <a href="https://github.com/scala/bug/issues/8124" target="_blank">issue-8124</a>.
The user should ignore this object.</p></div></div></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.10/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.10/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
