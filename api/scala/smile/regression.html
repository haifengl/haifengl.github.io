<!DOCTYPE html><html data-pathToRoot="../" data-rawLocation="smile/regression" data-dynamicSideMenu="true"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>smile.regression</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/apistyles.css"></link><script>var pathToRoot = "../";</script></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../" class="logo-container"><span id="project-logo" class="project-logo"><img src="../project-logo/smile.jpg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/smile.jpg"></img></span><span class="project-name h300">Smile - Scala</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">4.2.0</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="../project-logo/smile.jpg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/smile.jpg"></img></span><span class="project-name h300">Smile - Scala</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><div class="text">Copyright © 2010-2025 Haifeng Li. All rights reserved.
<script async src="https://www.googletagmanager.com/gtag/js?id=G-57GD08QCML"></script>
<script type="text/javascript" src="/api/java/script-dir/gtag.js"></script>
Use is subject to license terms.</div></div><div class="text-mobile">Copyright © 2010-2025 Haifeng Li. All rights reserved.
Use is subject to license terms.</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">Smile - Scala</a>/<a href="../smile.html">smile</a>/<a href="regression.html">smile.regression</a></div><div id="content" class="body-medium"><div><div class="cover-header">
 <span class="icon"><span class="micon pa"></span></span>
 <h1 class="h600 single">smile.regression</h1>
</div>
<div class="fqname body-large">
 <span></span>
</div>
<div class="main-signature mono-small-block">
 <div class="signature">
  <span class="modifiers"></span><span class="kind"><span t="k">package </span></span><a href="regression.html" t="n" class="documentableName ">smile.regression</a>
 </div>
</div>
<div class="cover">
 <div class="doc">
  <p>Regression analysis. Regression analysis includes any techniques for modeling and analyzing several variables, when the focus is on the relationship between a dependent variable and one or more independent variables. Most commonly, regression analysis estimates the conditional expectation of the dependent variable given the independent variables. Therefore, the estimation target is a function of the independent variables called the regression function. Regression analysis is widely used for prediction and forecasting.</p>
 </div>
 <section id="attributes">
  <h2 class="h500">Attributes</h2>
  <dl class="attributes"></dl>
 </section>
</div>
<section id="members-list">
 <h2 class="h500">Members list</h2>
 <div class="documentableFilter">
  <div class="filtersContainer"></div><input class="filterableInput" placeholder="Filter by any phrase" data-test-id="filterBarInput" type="search"><button class="clearButton label-only-button" data-test-id="filterBarClearButton">Clear all</button>
 </div>
 <div class="membersList expand">
  <div class="tabs">
   <div class="contents">
    <section id="Type-members">
     <div data-togglable="Type members" class="tab expand">
      <div class="member-group-header">
       <h3 data-togglable="Type members" class="h400">Type members</h3>
      </div>
      <section id="Classlikes">
       <div class="documentableList expand">
        <div class="documentableList-expander">
         <button class="icon-button show-content expand"></button>
         <h4 class="groupHeader h200">Classlikes</h4>
        </div>
        <div class="documentableElement">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">object </span></span><a href="regression/gpr$.html" t="n" class="documentableName ">gpr</a>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Gaussian Process for Regression.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Gaussian Process for Regression.</p>
             </div>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Supertypes
              </dt>
              <dd class="body-medium">
               <div class="mono-small-block supertypes">
                <div>
                 class <span data-unresolved-link="" t="n">Object</span>
                </div>
                <div>
                 trait <span data-unresolved-link="" t="n">Matchable</span>
                </div>
                <div>
                 class <span data-unresolved-link="" t="n">Any</span>
                </div><span></span>
               </div>
              </dd>
              <dt class="body-small">
               Self type
              </dt>
              <dd class="body-medium">
               <div class="mono-small-block supertypes">
                <span></span>
                <div>
                 <a href="regression/gpr$.html" t="n">gpr</a>.<span t="k">type</span>
                </div>
               </div>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
       </div>
      </section>
     </div>
    </section>
    <section id="Value-members">
     <div data-togglable="Value members" class="tab expand">
      <div class="member-group-header">
       <h3 data-togglable="Value members" class="h400">Value members</h3>
      </div>
      <section id="Concrete-methods">
       <div class="documentableList expand">
        <div class="documentableList-expander">
         <button class="icon-button show-content expand"></button>
         <h4 class="groupHeader h200">Concrete methods</h4>
        </div>
        <div class="documentableElement" id="cart-fffff4e4">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="regression.html#cart-fffff4e4" t="n" class="documentableName ">cart</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">formula</span>: <span data-unresolved-link="" t="t">Formula</span>, <span t="k"></span><span data-unresolved-link="" t="n">data</span>: <span data-unresolved-link="" t="t">DataFrame</span>, <span t="k"></span><span data-unresolved-link="" t="n">maxDepth</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxNodes</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">nodeSize</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>): <span data-unresolved-link="" t="t">RegressionTree</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Regression tree. A classification/regression tree can be learned by splitting the training set into subsets based on an attribute value test. This process is repeated on each derived subset in a recursive manner called recursive partitioning. The recursion is completed when the subset at a node all has the same value of the target variable, or when splitting no longer adds value to the predictions.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Regression tree. A classification/regression tree can be learned by splitting the training set into subsets based on an attribute value test. This process is repeated on each derived subset in a recursive manner called recursive partitioning. The recursion is completed when the subset at a node all has the same value of the target variable, or when splitting no longer adds value to the predictions.</p>
              <p>The algorithms that are used for constructing decision trees usually work top-down by choosing a variable at each step that is the next best variable to use in splitting the set of items. "Best" is defined by how well the variable splits the set into homogeneous subsets that have the same value of the target variable. Different algorithms use different formulae for measuring "best". Used by the CART algorithm, Gini impurity is a measure of how often a randomly chosen element from the set would be incorrectly labeled if it were randomly labeled according to the distribution of labels in the subset. Gini impurity can be computed by summing the probability of each item being chosen times the probability of a mistake in categorizing that item. It reaches its minimum (zero) when all cases in the node fall into a single target category. Information gain is another popular measure, used by the ID3, C4.5 and C5.0 algorithms. Information gain is based on the concept of entropy used in information theory. For categorical variables with different number of levels, however, information gain are biased in favor of those attributes with more levels. Instead, one may employ the information gain ratio, which solves the drawback of information gain.</p>
              <p>Classification and Regression Tree techniques have a number of advantages over many of those alternative techniques.</p>
              <ul>
               <li>'''Simple to understand and interpret:''' In most cases, the interpretation of results summarized in a tree is very simple. This simplicity is useful not only for purposes of rapid classification of new observations, but can also often yield a much simpler "model" for explaining why observations are classified or predicted in a particular manner.</li>
               <li>'''Able to handle both numerical and categorical data:''' Other techniques are usually specialized in analyzing datasets that have only one type of variable.</li>
               <li>'''Nonparametric and nonlinear:''' The final results of using tree methods for classification or regression can be summarized in a series of (usually few) logical if-then conditions (tree nodes). Therefore, there is no implicit assumption that the underlying relationships between the predictor variables and the dependent variable are linear, follow some specific non-linear link function, or that they are even monotonic in nature. Thus, tree methods are particularly well suited for data mining tasks, where there is often little a priori knowledge nor any coherent set of theories or predictions regarding which variables are related and how. In those types of data analytics, tree methods can often reveal simple relationships between just a few variables that could have easily gone unnoticed using other analytic techniques.</li>
              </ul>
              <p>One major problem with classification and regression trees is their high variance. Often a small change in the data can result in a very different series of splits, making interpretation somewhat precarious. Besides, decision-tree learners can create over-complex trees that cause over-fitting. Mechanisms such as pruning are necessary to avoid this problem. Another limitation of trees is the lack of smoothness of the prediction surface.</p>
              <p>Some techniques such as bagging, boosting, and random forest use more than one decision tree for their analysis.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               data
              </dt>
              <dd class="body-medium">
               <p>the data frame of the explanatory and response variables.</p>
              </dd>
              <dt class="body-small">
               formula
              </dt>
              <dd class="body-medium">
               <p>a symbolic description of the model to be fitted.</p>
              </dd>
              <dt class="body-small">
               maxDepth
              </dt>
              <dd class="body-medium">
               <p>the maximum depth of the tree.</p>
              </dd>
              <dt class="body-small">
               maxNodes
              </dt>
              <dd class="body-medium">
               <p>the maximum number of leaf nodes in the tree.</p>
              </dd>
              <dt class="body-small">
               nodeSize
              </dt>
              <dd class="body-medium">
               <p>the minimum size of leaf nodes.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>Regression tree model.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="gbm-fff">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="regression.html#gbm-fff" t="n" class="documentableName ">gbm</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">formula</span>: <span data-unresolved-link="" t="t">Formula</span>, <span t="k"></span><span data-unresolved-link="" t="n">data</span>: <span data-unresolved-link="" t="t">DataFrame</span>, <span t="k"></span><span data-unresolved-link="" t="n">loss</span>: <span data-unresolved-link="" t="t">Loss</span>, <span t="k"></span><span data-unresolved-link="" t="n">ntrees</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxDepth</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxNodes</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">nodeSize</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">shrinkage</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">subsample</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>): <span data-unresolved-link="" t="t">GradientTreeBoost</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Gradient boosted regression trees.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Gradient boosted regression trees.</p>
              <p>Generic gradient boosting at the t-th step would fit a regression tree to pseudo-residuals. Let J be the number of its leaves. The tree partitions the input space into J disjoint regions and predicts a constant value in each region. The parameter J controls the maximum allowed level of interaction between variables in the model. With J = 2 (decision stumps), no interaction between variables is allowed. With J = 3 the model may include effects of the interaction between up to two variables, and so on. Hastie et al. comment that typically 4 ≤ J ≤ 8 work well for boosting and results are fairly insensitive to the choice of in this range, J = 2 is insufficient for many applications, and J &gt; 10 is unlikely to be required.</p>
              <p>Fitting the training set too closely can lead to degradation of the model's generalization ability. Several so-called regularization techniques reduce this over-fitting effect by constraining the fitting procedure. One natural regularization parameter is the number of gradient boosting iterations T (i.e. the number of trees in the model when the base learner is a decision tree). Increasing T reduces the error on training set, but setting it too high may lead to over-fitting. An optimal value of T is often selected by monitoring prediction error on a separate validation data set.</p>
              <p>Another regularization approach is the shrinkage which times a parameter η (called the "learning rate") to update term. Empirically it has been found that using small learning rates (such as η &lt; 0.1) yields dramatic improvements in model's generalization ability over gradient boosting without shrinking (η = 1). However, it comes at the price of increasing computational time both during training and prediction: lower learning rate requires more iterations.</p>
              <p>Soon after the introduction of gradient boosting Friedman proposed a minor modification to the algorithm, motivated by Breiman's bagging method. Specifically, he proposed that at each iteration of the algorithm, a base learner should be fit on a subsample of the training set drawn at random without replacement. Friedman observed a substantial improvement in gradient boosting's accuracy with this modification.</p>
              <p>Subsample size is some constant fraction f of the size of the training set. When f = 1, the algorithm is deterministic and identical to the one described above. Smaller values of f introduce randomness into the algorithm and help prevent over-fitting, acting as a kind of regularization. The algorithm also becomes faster, because regression trees have to be fit to smaller datasets at each iteration. Typically, f is set to 0.5, meaning that one half of the training set is used to build each base learner.</p>
              <p>Also, like in bagging, sub-sampling allows one to define an out-of-bag estimate of the prediction performance improvement by evaluating predictions on those observations which were not used in the building of the next base learner. Out-of-bag estimates help avoid the need for an independent validation dataset, but often underestimate actual performance improvement and the optimal number of iterations.</p>
              <p>Gradient tree boosting implementations often also use regularization by limiting the minimum number of observations in trees' terminal nodes. It's used in the tree building process by ignoring any splits that lead to nodes containing fewer than this number of training set instances. Imposing this limit helps to reduce variance in predictions at leaves.</p>
              <p>====References:====</p>
              <ul>
               <li>J. H. Friedman. Greedy Function Approximation: A Gradient Boosting Machine, 1999.</li>
               <li>J. H. Friedman. Stochastic Gradient Boosting, 1999.</li>
              </ul>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               data
              </dt>
              <dd class="body-medium">
               <p>the data frame of the explanatory and response variables.</p>
              </dd>
              <dt class="body-small">
               formula
              </dt>
              <dd class="body-medium">
               <p>a symbolic description of the model to be fitted.</p>
              </dd>
              <dt class="body-small">
               loss
              </dt>
              <dd class="body-medium">
               <p>loss function for regression. By default, least absolute deviation is employed for robust regression.</p>
              </dd>
              <dt class="body-small">
               maxDepth
              </dt>
              <dd class="body-medium">
               <p>the maximum depth of the tree.</p>
              </dd>
              <dt class="body-small">
               maxNodes
              </dt>
              <dd class="body-medium">
               <p>the maximum number of leaf nodes in the tree.</p>
              </dd>
              <dt class="body-small">
               nodeSize
              </dt>
              <dd class="body-medium">
               <p>the minimum size of leaf nodes.</p>
              </dd>
              <dt class="body-small">
               ntrees
              </dt>
              <dd class="body-medium">
               <p>the number of iterations (trees).</p>
              </dd>
              <dt class="body-small">
               shrinkage
              </dt>
              <dd class="body-medium">
               <p>the shrinkage parameter in (0, 1] controls the learning rate of procedure.</p>
              </dd>
              <dt class="body-small">
               subsample
              </dt>
              <dd class="body-medium">
               <p>the sampling fraction for stochastic tree boosting.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>Gradient boosted trees.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="lasso-8ed">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="regression.html#lasso-8ed" t="n" class="documentableName ">lasso</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">formula</span>: <span data-unresolved-link="" t="t">Formula</span>, <span t="k"></span><span data-unresolved-link="" t="n">data</span>: <span data-unresolved-link="" t="t">DataFrame</span>, <span t="k"></span><span data-unresolved-link="" t="n">lambda</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">tol</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxIter</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>): <span data-unresolved-link="" t="t">LinearModel</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Least absolute shrinkage and selection operator. The Lasso is a shrinkage and selection method for linear regression. It minimizes the usual sum of squared errors, with a bound on the sum of the absolute values of the coefficients (i.e. L<sub>1</sub>-regularized). It has connections to soft-thresholding of wavelet coefficients, forward stage-wise regression, and boosting methods.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Least absolute shrinkage and selection operator. The Lasso is a shrinkage and selection method for linear regression. It minimizes the usual sum of squared errors, with a bound on the sum of the absolute values of the coefficients (i.e. L<sub>1</sub>-regularized). It has connections to soft-thresholding of wavelet coefficients, forward stage-wise regression, and boosting methods.</p>
              <p>The Lasso typically yields a sparse solution, of which the parameter vector β has relatively few nonzero coefficients. In contrast, the solution of L<sub>2</sub>-regularized least squares (i.e. ridge regression) typically has all coefficients nonzero. Because it effectively reduces the number of variables, the Lasso is useful in some contexts.</p>
              <p>For over-determined systems (more instances than variables, commonly in machine learning), we normalize variables with mean 0 and standard deviation</p>
              <ol>
               <li>For under-determined systems (fewer instances than variables, e.g. compressed sensing), we assume white noise (i.e. no intercept in the linear model) and do not perform normalization. Note that the solution is not unique in this case.</li>
              </ol>
              <p>There is no analytic formula or expression for the optimal solution to the L<sub>1</sub>-regularized least squares problems. Therefore, its solution must be computed numerically. The objective function in the L<sub>1</sub>-regularized least squares is convex but not differentiable, so solving it is more of a computational challenge than solving the L<sub>2</sub>-regularized least squares. The Lasso may be solved using quadratic programming or more general convex optimization methods, as well as by specific algorithms such as the least angle regression algorithm.</p>
              <p>====References:====</p>
              <ul>
               <li>R. Tibshirani. Regression shrinkage and selection via the lasso. J. Royal. Statist. Soc B., 58(1):267-288, 1996.</li>
               <li>B. Efron, I. Johnstone, T. Hastie, and R. Tibshirani. Least angle regression. Annals of Statistics, 2003</li>
               <li>Seung-Jean Kim, K. Koh, M. Lustig, Stephen Boyd, and Dimitry Gorinevsky. An Interior-Point Method for Large-Scale L1-Regularized Least Squares. IEEE JOURNAL OF SELECTED TOPICS IN SIGNAL PROCESSING, VOL. 1, NO. 4, 2007.</li>
              </ul>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               data
              </dt>
              <dd class="body-medium">
               <p>the data frame of the explanatory and response variables.</p>
              </dd>
              <dt class="body-small">
               formula
              </dt>
              <dd class="body-medium">
               <p>a symbolic description of the model to be fitted.</p>
              </dd>
              <dt class="body-small">
               lambda
              </dt>
              <dd class="body-medium">
               <p>the shrinkage/regularization parameter.</p>
              </dd>
              <dt class="body-small">
               maxIter
              </dt>
              <dd class="body-medium">
               <p>the maximum number of iterations.</p>
              </dd>
              <dt class="body-small">
               tol
              </dt>
              <dd class="body-medium">
               <p>the tolerance for stopping iterations (relative target duality gap).</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="lm-ffffff07">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="regression.html#lm-ffffff07" t="n" class="documentableName ">lm</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">formula</span>: <span data-unresolved-link="" t="t">Formula</span>, <span t="k"></span><span data-unresolved-link="" t="n">data</span>: <span data-unresolved-link="" t="t">DataFrame</span>, <span t="k"></span><span data-unresolved-link="" t="n">method</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Predef$.html#String" t="t">String</a>, <span t="k"></span><span data-unresolved-link="" t="n">stderr</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Boolean.html" t="t">Boolean</a>, <span t="k"></span><span data-unresolved-link="" t="n">recursive</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Boolean.html" t="t">Boolean</a>): <span data-unresolved-link="" t="t">LinearModel</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Fitting linear models (ordinary least squares). In linear regression, the model specification is that the dependent variable is a linear combination of the parameters (but need not be linear in the independent variables). The residual is the difference between the value of the dependent variable predicted by the model, and the true value of the dependent variable. Ordinary least squares obtains parameter estimates that minimize the sum of squared residuals, SSE (also denoted RSS).</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Fitting linear models (ordinary least squares). In linear regression, the model specification is that the dependent variable is a linear combination of the parameters (but need not be linear in the independent variables). The residual is the difference between the value of the dependent variable predicted by the model, and the true value of the dependent variable. Ordinary least squares obtains parameter estimates that minimize the sum of squared residuals, SSE (also denoted RSS).</p>
              <p>The OLS estimator is consistent when the independent variables are exogenous and there is no multicollinearity, and optimal in the class of linear unbiased estimators when the errors are homoscedastic and serially uncorrelated. Under these conditions, the method of OLS provides minimum-variance mean-unbiased estimation when the errors have finite variances.</p>
              <p>There are several different frameworks in which the linear regression model can be cast in order to make the OLS technique applicable. Each of these settings produces the same formulas and same results, the only difference is the interpretation and the assumptions which have to be imposed in order for the method to give meaningful results. The choice of the applicable framework depends mostly on the nature of data at hand, and on the inference task which has to be performed.</p>
              <p>Least squares corresponds to the maximum likelihood criterion if the experimental errors have a normal distribution and can also be derived as a method of moments estimator.</p>
              <p>Once a regression model has been constructed, it may be important to confirm the goodness of fit of the model and the statistical significance of the estimated parameters. Commonly used checks of goodness of fit include the R-squared, analysis of the pattern of residuals and hypothesis testing. Statistical significance can be checked by an F-test of the overall fit, followed by t-tests of individual parameters.</p>
              <p>Interpretations of these diagnostic tests rest heavily on the model assumptions. Although examination of the residuals can be used to invalidate a model, the results of a t-test or F-test are sometimes more difficult to interpret if the model's assumptions are violated. For example, if the error term does not have a normal distribution, in small samples the estimated parameters will not follow normal distributions and complicate inference. With relatively large samples, however, a central limit theorem can be invoked such that hypothesis testing may proceed using asymptotic approximations.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               data
              </dt>
              <dd class="body-medium">
               <p>the data frame of the explanatory and response variables.</p>
              </dd>
              <dt class="body-small">
               formula
              </dt>
              <dd class="body-medium">
               <p>a symbolic description of the model to be fitted.</p>
              </dd>
              <dt class="body-small">
               method
              </dt>
              <dd class="body-medium">
               <p>the fitting method ("svd" or "qr").</p>
              </dd>
              <dt class="body-small">
               recursive
              </dt>
              <dd class="body-medium">
               <p>if true, the return model supports recursive least squares.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="randomForest-fffffa0c">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="regression.html#randomForest-fffffa0c" t="n" class="documentableName ">randomForest</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">formula</span>: <span data-unresolved-link="" t="t">Formula</span>, <span t="k"></span><span data-unresolved-link="" t="n">data</span>: <span data-unresolved-link="" t="t">DataFrame</span>, <span t="k"></span><span data-unresolved-link="" t="n">ntrees</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">mtry</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxDepth</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxNodes</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">nodeSize</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">subsample</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>): <span data-unresolved-link="" t="t">RandomForest</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Random forest for regression. Random forest is an ensemble classifier that consists of many decision trees and outputs the majority vote of individual trees. The method combines bagging idea and the random selection of features.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Random forest for regression. Random forest is an ensemble classifier that consists of many decision trees and outputs the majority vote of individual trees. The method combines bagging idea and the random selection of features.</p>
              <p>Each tree is constructed using the following algorithm:</p>
              <p>i. If the number of cases in the training set is N, randomly sample N cases with replacement from the original data. This sample will be the training set for growing the tree. i. If there are M input variables, a number m &lt;&lt; M is specified such that at each node, m variables are selected at random out of the M and the best split on these m is used to split the node. The value of m is held constant during the forest growing. i. Each tree is grown to the largest extent possible. There is no pruning.</p>
              <p>The advantages of random forest are:</p>
              <ul>
               <li>For many data sets, it produces a highly accurate classifier.</li>
               <li>It runs efficiently on large data sets.</li>
               <li>It can handle thousands of input variables without variable deletion.</li>
               <li>It gives estimates of what variables are important in the classification.</li>
               <li>It generates an internal unbiased estimate of the generalization error as the forest building progresses.</li>
               <li>It has an effective method for estimating missing data and maintains accuracy when a large proportion of the data are missing.</li>
              </ul>
              <p>The disadvantages are</p>
              <ul>
               <li>Random forests are prone to over-fitting for some datasets. This is even more pronounced on noisy data.</li>
               <li>For data including categorical variables with different number of levels, random forests are biased in favor of those attributes with more levels. Therefore, the variable importance scores from random forest are not reliable for this type of data.</li>
              </ul>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               data
              </dt>
              <dd class="body-medium">
               <p>the data frame of the explanatory and response variables.</p>
              </dd>
              <dt class="body-small">
               formula
              </dt>
              <dd class="body-medium">
               <p>a symbolic description of the model to be fitted.</p>
              </dd>
              <dt class="body-small">
               maxDepth
              </dt>
              <dd class="body-medium">
               <p>the maximum depth of the tree.</p>
              </dd>
              <dt class="body-small">
               maxNodes
              </dt>
              <dd class="body-medium">
               <p>the maximum number of leaf nodes in the tree.</p>
              </dd>
              <dt class="body-small">
               mtry
              </dt>
              <dd class="body-medium">
               <p>the number of input variables to be used to determine the decision at a node of the tree. dim/3 seems to give generally good performance, where dim is the number of variables.</p>
              </dd>
              <dt class="body-small">
               nodeSize
              </dt>
              <dd class="body-medium">
               <p>the minimum size of leaf nodes.</p>
              </dd>
              <dt class="body-small">
               ntrees
              </dt>
              <dd class="body-medium">
               <p>the number of trees.</p>
              </dd>
              <dt class="body-small">
               subsample
              </dt>
              <dd class="body-medium">
               <p>the sampling rate for training tree. 1.0 means sampling with replacement. &lt; 1.0 means sampling without replacement.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>Random forest regression model.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="rbfnet-fffff829">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="regression.html#rbfnet-fffff829" t="n" class="documentableName ">rbfnet</a>[<span t="k"></span><span data-unresolved-link="" t="t">T</span><span t="k"> &lt;: </span><span data-unresolved-link="" t="t">AnyRef</span>](<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<span t="t">T</span>], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>], <span t="k"></span><span data-unresolved-link="" t="n">neurons</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<span data-unresolved-link="" t="t">RBF</span>[<span t="t">T</span>]], <span t="k"></span><span data-unresolved-link="" t="n">normalized</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Boolean.html" t="t">Boolean</a>): <span data-unresolved-link="" t="t">RBFNetwork</span>[<span data-unresolved-link="" t="t">T</span>]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Radial basis function networks. A radial basis function network is an artificial neural network that uses radial basis functions as activation functions. It is a linear combination of radial basis functions. They are used in function approximation, time series prediction, and control.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Radial basis function networks. A radial basis function network is an artificial neural network that uses radial basis functions as activation functions. It is a linear combination of radial basis functions. They are used in function approximation, time series prediction, and control.</p>
              <p>In its basic form, radial basis function network is in the form</p>
              <p>y(x) = Σ w<sub>i</sub> φ(||x-c<sub>i</sub>||)</p>
              <p>where the approximating function y(x) is represented as a sum of N radial basis functions φ, each associated with a different center c<sub>i</sub>, and weighted by an appropriate coefficient w<sub>i</sub>. For distance, one usually chooses Euclidean distance. The weights w<sub>i</sub> can be estimated using the matrix methods of linear least squares, because the approximating function is linear in the weights.</p>
              <p>The centers c<sub>i</sub> can be randomly selected from training data, or learned by some clustering method (e.g. k-means), or learned together with weight parameters undergo a supervised learning processing (e.g. error-correction learning).</p>
              <p>The popular choices for φ comprise the Gaussian function and the so-called thin plate splines. The advantage of the thin plate splines is that their conditioning is invariant under scalings. Gaussian, multi-quadric and inverse multi-quadric are infinitely smooth and involve a scale or shape parameter, r<sub><small>0</small></sub> &gt; 0. Decreasing r<sub><small>0</small></sub> tends to flatten the basis function. For a given function, the quality of approximation may strongly depend on this parameter. In particular, increasing r<sub><small>0</small></sub> has the effect of better conditioning (the separation distance of the scaled points increases).</p>
              <p>A variant on RBF networks is normalized radial basis function (NRBF) networks, in which we require the sum of the basis functions to be unity. NRBF arises more naturally from a Bayesian statistical perspective. However, there is no evidence that either the NRBF method is consistently superior to the RBF method, or vice versa.</p>
              <p>SVMs with Gaussian kernel have similar structure as RBF networks with Gaussian radial basis functions. However, the SVM approach "automatically" solves the network complexity problem since the size of the hidden layer is obtained as the result of the QP procedure. Hidden neurons and support vectors correspond to each other, so the center problems of the RBF network is also solved, as the support vectors serve as the basis function centers. It was reported that with similar number of support vectors/centers, SVM shows better generalization performance than RBF network when the training data size is relatively small. On the other hand, RBF network gives better generalization performance than SVM on large training data.</p>
              <p>====References:====</p>
              <ul>
               <li>Simon Haykin. Neural Networks: A Comprehensive Foundation (2nd edition). 1999.</li>
               <li>T. Poggio and F. Girosi. Networks for approximation and learning. Proc. IEEE 78(9):1484-1487, 1990.</li>
               <li>Nabil Benoudjit and Michel Verleysen. On the kernel widths in radial-basis function networks. Neural Process, 2003.</li>
              </ul>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               neurons
              </dt>
              <dd class="body-medium">
               <p>the radial basis functions.</p>
              </dd>
              <dt class="body-small">
               normalized
              </dt>
              <dd class="body-medium">
               <p>train a normalized RBF network or not.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training samples.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>response variable.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="rbfnet-ffffff0e">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="regression.html#rbfnet-ffffff0e" t="n" class="documentableName ">rbfnet</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>]], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>], <span t="k"></span><span data-unresolved-link="" t="n">k</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">normalized</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Boolean.html" t="t">Boolean</a>): <span data-unresolved-link="" t="t">RBFNetwork</span>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>]]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Trains a Gaussian RBF network with k-means.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Trains a Gaussian RBF network with k-means.</p>
             </div>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="ridge-b3b">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="regression.html#ridge-b3b" t="n" class="documentableName ">ridge</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">formula</span>: <span data-unresolved-link="" t="t">Formula</span>, <span t="k"></span><span data-unresolved-link="" t="n">data</span>: <span data-unresolved-link="" t="t">DataFrame</span>, <span t="k"></span><span data-unresolved-link="" t="n">lambda</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>): <span data-unresolved-link="" t="t">LinearModel</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Ridge Regression. When the predictor variables are highly correlated amongst themselves, the coefficients of the resulting least squares fit may be very imprecise. By allowing a small amount of bias in the estimates, more reasonable coefficients may often be obtained. Ridge regression is one method to address these issues. Often, small amounts of bias lead to dramatic reductions in the variance of the estimated model coefficients. Ridge regression is such a technique which shrinks the regression coefficients by imposing a penalty on their size. Ridge regression was originally developed to overcome the singularity of the X'X matrix. This matrix is perturbed to make its determinant appreciably different from 0.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Ridge Regression. When the predictor variables are highly correlated amongst themselves, the coefficients of the resulting least squares fit may be very imprecise. By allowing a small amount of bias in the estimates, more reasonable coefficients may often be obtained. Ridge regression is one method to address these issues. Often, small amounts of bias lead to dramatic reductions in the variance of the estimated model coefficients. Ridge regression is such a technique which shrinks the regression coefficients by imposing a penalty on their size. Ridge regression was originally developed to overcome the singularity of the X'X matrix. This matrix is perturbed to make its determinant appreciably different from 0.</p>
              <p>Ridge regression is a kind of Tikhonov regularization, which is the most commonly used method of regularization of ill-posed problems. Another interpretation of ridge regression is available through Bayesian estimation. In this setting the belief that weight should be small is coded into a prior distribution.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               data
              </dt>
              <dd class="body-medium">
               <p>the data frame of the explanatory and response variables.</p>
              </dd>
              <dt class="body-small">
               formula
              </dt>
              <dd class="body-medium">
               <p>a symbolic description of the model to be fitted.</p>
              </dd>
              <dt class="body-small">
               lambda
              </dt>
              <dd class="body-medium">
               <p>the shrinkage/regularization parameter.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="svm-d53">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="regression.html#svm-d53" t="n" class="documentableName ">svm</a>[<span t="k"></span><span data-unresolved-link="" t="t">T</span><span t="k"> &lt;: </span><span data-unresolved-link="" t="t">AnyRef</span>](<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<span t="t">T</span>], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>], <span t="k"></span><span data-unresolved-link="" t="n">kernel</span>: <span data-unresolved-link="" t="t">MercerKernel</span>[<span t="t">T</span>], <span t="k"></span><span data-unresolved-link="" t="n">eps</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">C</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">tol</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>): <span data-unresolved-link="" t="t">KernelMachine</span>[<span data-unresolved-link="" t="t">T</span>]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Support vector regression. Like SVM for classification, the model produced by SVR depends only on a subset of the training data, because the cost function ignores any training data close to the model prediction (within a threshold).</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Support vector regression. Like SVM for classification, the model produced by SVR depends only on a subset of the training data, because the cost function ignores any training data close to the model prediction (within a threshold).</p>
             </div>
             <h2 class="h200">Type parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               T
              </dt>
              <dd class="body-medium">
               <p>the data type</p>
              </dd>
             </dl>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               C
              </dt>
              <dd class="body-medium">
               <p>the soft margin penalty parameter.</p>
              </dd>
              <dt class="body-small">
               eps
              </dt>
              <dd class="body-medium">
               <p>the loss function error threshold.</p>
              </dd>
              <dt class="body-small">
               kernel
              </dt>
              <dd class="body-medium">
               <p>the kernel function.</p>
              </dd>
              <dt class="body-small">
               tol
              </dt>
              <dd class="body-medium">
               <p>the tolerance of convergence test.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training data.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>response variable.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>SVR model.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
       </div>
      </section>
     </div>
    </section>
   </div>
  </div>
 </div>
</section></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#attributes">Attributes</a></li><li><a href="#members-list">Members list</a><ul><li><a href="#Type-members">Type members</a><ul><li><a href="#Classlikes">Classlikes</a></li></ul></li><li><a href="#Value-members">Value members</a><ul><li><a href="#Concrete-methods">Concrete methods</a></li></ul></li></ul></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><div class="text">Copyright © 2010-2025 Haifeng Li. All rights reserved.
Use is subject to license terms.</div></div><div class="text-mobile">Copyright © 2010-2025 Haifeng Li. All rights reserved.
Use is subject to license terms.</div></div></div></div></body></html>