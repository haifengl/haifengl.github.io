<!DOCTYPE html><html data-pathToRoot="../" data-rawLocation="smile/association" data-dynamicSideMenu="true"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>smile.association</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/apistyles.css"></link><script>var pathToRoot = "../";</script></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../" class="logo-container"><span id="project-logo" class="project-logo"><img src="../project-logo/smile.jpg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/smile.jpg"></img></span><span class="project-name h300">Smile - Scala</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">4.2.0</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="../project-logo/smile.jpg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/smile.jpg"></img></span><span class="project-name h300">Smile - Scala</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><div class="text">Copyright © 2010-2025 Haifeng Li. All rights reserved.
<script async src="https://www.googletagmanager.com/gtag/js?id=G-57GD08QCML"></script>
<script type="text/javascript" src="/api/java/script-dir/gtag.js"></script>
Use is subject to license terms.</div></div><div class="text-mobile">Copyright © 2010-2025 Haifeng Li. All rights reserved.
Use is subject to license terms.</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">Smile - Scala</a>/<a href="../smile.html">smile</a>/<a href="association.html">smile.association</a></div><div id="content" class="body-medium"><div><div class="cover-header">
 <span class="icon"><span class="micon pa"></span></span>
 <h1 class="h600 single">smile.association</h1>
</div>
<div class="fqname body-large">
 <span></span>
</div>
<div class="main-signature mono-small-block">
 <div class="signature">
  <span class="modifiers"></span><span class="kind"><span t="k">package </span></span><a href="association.html" t="n" class="documentableName ">smile.association</a>
 </div>
</div>
<div class="cover">
 <div class="doc">
  <p>Frequent item set mining and association rule mining. Association rule learning is a popular and well researched method for discovering interesting relations between variables in large databases. Let I = {i<sub>1</sub>, i<sub>2</sub>,..., i<sub>n</sub>} be a set of n binary attributes called items. Let D = {t<sub>1</sub>, t<sub>2</sub>,..., t<sub>m</sub>} be a set of transactions called the database. Each transaction in D has a unique transaction ID and contains a subset of the items in I. An association rule is defined as an implication of the form X ⇒ Y where X, Y ⊆ I and X ∩ Y = Ø. The item sets X and Y are called antecedent (left-hand-side or LHS) and consequent (right-hand-side or RHS) of the rule, respectively. The support supp(X) of an item set X is defined as the proportion of transactions in the database which contain the item set. Note that the support of an association rule X ⇒ Y is supp(X ∪ Y). The confidence of a rule is defined conf(X ⇒ Y) = supp(X ∪ Y) / supp(X). Confidence can be interpreted as an estimate of the probability P(Y | X), the probability of finding the RHS of the rule in transactions under the condition that these transactions also contain the LHS.</p>
  <p>For example, the rule {onions, potatoes} ⇒ {burger} found in the sales data of a supermarket would indicate that if a customer buys onions and potatoes together, he or she is likely to also buy burger. Such information can be used as the basis for decisions about marketing activities such as promotional pricing or product placements.</p>
  <p>Association rules are usually required to satisfy a user-specified minimum support and a user-specified minimum confidence at the same time. Association rule generation is usually split up into two separate steps:</p>
  <ul>
   <li>First, minimum support is applied to find all frequent item sets in a database (i.e. frequent item set mining).</li>
   <li>Second, these frequent item sets and the minimum confidence constraint are used to form rules.</li>
  </ul>
  <p>Finding all frequent item sets in a database is difficult since it involves searching all possible item sets (item combinations). The set of possible item sets is the power set over I (the set of items) and has size 2<sup>n</sup> - 1 (excluding the empty set which is not a valid item set). Although the size of the power set grows exponentially in the number of items n in I, efficient search is possible using the downward-closure property of support (also called anti-monotonicity) which guarantees that for a frequent item set also all its subsets are frequent and thus for an infrequent item set, all its supersets must be infrequent.</p>
  <p>In practice, we may only consider the frequent item set that has the maximum number of items bypassing all the sub item sets. An item set is maximal frequent if none of its immediate supersets is frequent.</p>
  <p>For a maximal frequent item set, even though we know that all the sub item sets are frequent, we don't know the actual support of those sub item sets, which are very important to find the association rules within the item sets. If the final goal is association rule mining, we would like to discover closed frequent item sets. An item set is closed if none of its immediate supersets has the same support as the item set.</p>
  <p>Some well known algorithms of frequent item set mining are Apriori, Eclat and FP-Growth. Apriori is the best-known algorithm to mine association rules. It uses a breadth-first search strategy to counting the support of item sets and uses a candidate generation function which exploits the downward closure property of support. Eclat is a depth-first search algorithm using set intersection.</p>
  <p>FP-growth (frequent pattern growth) uses an extended prefix-tree (FP-tree) structure to store the database in a compressed form. FP-growth adopts a divide-and-conquer approach to decompose both the mining tasks and the databases. It uses a pattern fragment growth method to avoid the costly process of candidate generation and testing used by Apriori.</p>
  <p>====References:====</p>
  <ul>
   <li>R. Agrawal, T. Imielinski and A. Swami. Mining Association Rules Between Sets of Items in Large Databases, SIGMOD, 207-216, 1993.</li>
   <li>Rakesh Agrawal and Ramakrishnan Srikant. Fast algorithms for mining association rules in large databases. VLDB, 487-499, 1994.</li>
   <li>Mohammed J. Zaki. Scalable algorithms for association mining. IEEE Transactions on Knowledge and Data Engineering, 12(3):372-390, 2000.</li>
   <li>Jiawei Han, Jian Pei, Yiwen Yin, and Runying Mao. Mining frequent patterns without candidate generation. Data Mining and Knowledge Discovery 8:53-87, 2004.</li>
  </ul>
 </div>
 <section id="attributes">
  <h2 class="h500">Attributes</h2>
  <dl class="attributes"></dl>
 </section>
</div>
<section id="members-list">
 <h2 class="h500">Members list</h2>
 <div class="documentableFilter">
  <div class="filtersContainer"></div><input class="filterableInput" placeholder="Filter by any phrase" data-test-id="filterBarInput" type="search"><button class="clearButton label-only-button" data-test-id="filterBarClearButton">Clear all</button>
 </div>
 <div class="membersList expand">
  <div class="tabs">
   <div class="contents">
    <section id="Type-members">
     <div data-togglable="Type members" class="tab expand">
      <div class="member-group-header">
       <h3 data-togglable="Type members" class="h400">Type members</h3>
      </div>
      <section id="Classlikes">
       <div class="documentableList expand">
        <div class="documentableList-expander">
         <button class="icon-button show-content expand"></button>
         <h4 class="groupHeader h200">Classlikes</h4>
        </div>
        <div class="documentableElement">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">object </span></span><a href="association/$dummy$.html" t="n" class="documentableName ">$dummy</a>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Hacking scaladoc <a href="https://github.com/scala/bug/issues/8124">issue-8124</a>. The user should ignore this object.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Hacking scaladoc <a href="https://github.com/scala/bug/issues/8124">issue-8124</a>. The user should ignore this object.</p>
             </div>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Supertypes
              </dt>
              <dd class="body-medium">
               <div class="mono-small-block supertypes">
                <div>
                 class <span data-unresolved-link="" t="n">Object</span>
                </div>
                <div>
                 trait <span data-unresolved-link="" t="n">Matchable</span>
                </div>
                <div>
                 class <span data-unresolved-link="" t="n">Any</span>
                </div><span></span>
               </div>
              </dd>
              <dt class="body-small">
               Self type
              </dt>
              <dd class="body-medium">
               <div class="mono-small-block supertypes">
                <span></span>
                <div>
                 <a href="association/$dummy$.html" t="n">$dummy</a>.<span t="k">type</span>
                </div>
               </div>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
       </div>
      </section>
     </div>
    </section>
    <section id="Value-members">
     <div data-togglable="Value members" class="tab expand">
      <div class="member-group-header">
       <h3 data-togglable="Value members" class="h400">Value members</h3>
      </div>
      <section id="Concrete-methods">
       <div class="documentableList expand">
        <div class="documentableList-expander">
         <button class="icon-button show-content expand"></button>
         <h4 class="groupHeader h200">Concrete methods</h4>
        </div>
        <div class="documentableElement" id="arm-fffff423">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="association.html#arm-fffff423" t="n" class="documentableName ">arm</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">minSupport</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">confidence</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">itemsets</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>]]): <span data-unresolved-link="" t="t">Stream</span>[<span data-unresolved-link="" t="t">AssociationRule</span>]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Association Rule Mining. Let I = {i<sub>1</sub>, i<sub>2</sub>,..., i<sub>n</sub>} be a set of n binary attributes called items. Let D = {t<sub>1</sub>, t<sub>2</sub>,..., t<sub>m</sub>} be a set of transactions called the database. Each transaction in D has a unique transaction ID and contains a subset of the items in I. An association rule is defined as an implication of the form X ⇒ Y where X, Y ⊆ I and X ∩ Y = Ø. The item sets X and Y are called antecedent (left-hand-side or LHS) and consequent (right-hand-side or RHS) of the rule, respectively. The support supp(X) of an item set X is defined as the proportion of transactions in the database which contain the item set. Note that the support of an association rule X ⇒ Y is supp(X ∪ Y). The confidence of a rule is defined conf(X ⇒ Y) = supp(X ∪ Y) / supp(X). Confidence can be interpreted as an estimate of the probability P(Y | X), the probability of finding the RHS of the rule in transactions under the condition that these transactions also contain the LHS. Association rules are usually required to satisfy a user-specified minimum support and a user-specified minimum confidence at the same time.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Association Rule Mining. Let I = {i<sub>1</sub>, i<sub>2</sub>,..., i<sub>n</sub>} be a set of n binary attributes called items. Let D = {t<sub>1</sub>, t<sub>2</sub>,..., t<sub>m</sub>} be a set of transactions called the database. Each transaction in D has a unique transaction ID and contains a subset of the items in I. An association rule is defined as an implication of the form X ⇒ Y where X, Y ⊆ I and X ∩ Y = Ø. The item sets X and Y are called antecedent (left-hand-side or LHS) and consequent (right-hand-side or RHS) of the rule, respectively. The support supp(X) of an item set X is defined as the proportion of transactions in the database which contain the item set. Note that the support of an association rule X ⇒ Y is supp(X ∪ Y). The confidence of a rule is defined conf(X ⇒ Y) = supp(X ∪ Y) / supp(X). Confidence can be interpreted as an estimate of the probability P(Y | X), the probability of finding the RHS of the rule in transactions under the condition that these transactions also contain the LHS. Association rules are usually required to satisfy a user-specified minimum support and a user-specified minimum confidence at the same time.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               confidence
              </dt>
              <dd class="body-medium">
               <p>the confidence threshold for association rules.</p>
              </dd>
              <dt class="body-small">
               itemsets
              </dt>
              <dd class="body-medium">
               <p>the item set database. Each row is a item set, which may have different length. The item identifiers have to be in [0, n), where n is the number of items. Item set should NOT contain duplicated items. Note that it is reordered after the call.</p>
              </dd>
              <dt class="body-small">
               minSupport
              </dt>
              <dd class="body-medium">
               <p>the required minimum support of item sets in terms of frequency.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>the stream of discovered association rules.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="arm-da">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="association.html#arm-da" t="n" class="documentableName ">arm</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">confidence</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">tree</span>: <span data-unresolved-link="" t="t">FPTree</span>): <span data-unresolved-link="" t="t">Stream</span>[<span data-unresolved-link="" t="t">AssociationRule</span>]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Association Rule Mining. Let I = {i<sub>1</sub>, i<sub>2</sub>,..., i<sub>n</sub>} be a set of n binary attributes called items. Let D = {t<sub>1</sub>, t<sub>2</sub>,..., t<sub>m</sub>} be a set of transactions called the database. Each transaction in D has a unique transaction ID and contains a subset of the items in I. An association rule is defined as an implication of the form X ⇒ Y where X, Y ⊆ I and X ∩ Y = Ø. The item sets X and Y are called antecedent (left-hand-side or LHS) and consequent (right-hand-side or RHS) of the rule, respectively. The support supp(X) of an item set X is defined as the proportion of transactions in the database which contain the item set. Note that the support of an association rule X ⇒ Y is supp(X ∪ Y). The confidence of a rule is defined conf(X ⇒ Y) = supp(X ∪ Y) / supp(X). Confidence can be interpreted as an estimate of the probability P(Y | X), the probability of finding the RHS of the rule in transactions under the condition that these transactions also contain the LHS. Association rules are usually required to satisfy a user-specified minimum support and a user-specified minimum confidence at the same time.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Association Rule Mining. Let I = {i<sub>1</sub>, i<sub>2</sub>,..., i<sub>n</sub>} be a set of n binary attributes called items. Let D = {t<sub>1</sub>, t<sub>2</sub>,..., t<sub>m</sub>} be a set of transactions called the database. Each transaction in D has a unique transaction ID and contains a subset of the items in I. An association rule is defined as an implication of the form X ⇒ Y where X, Y ⊆ I and X ∩ Y = Ø. The item sets X and Y are called antecedent (left-hand-side or LHS) and consequent (right-hand-side or RHS) of the rule, respectively. The support supp(X) of an item set X is defined as the proportion of transactions in the database which contain the item set. Note that the support of an association rule X ⇒ Y is supp(X ∪ Y). The confidence of a rule is defined conf(X ⇒ Y) = supp(X ∪ Y) / supp(X). Confidence can be interpreted as an estimate of the probability P(Y | X), the probability of finding the RHS of the rule in transactions under the condition that these transactions also contain the LHS. Association rules are usually required to satisfy a user-specified minimum support and a user-specified minimum confidence at the same time.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               confidence
              </dt>
              <dd class="body-medium">
               <p>the confidence threshold for association rules.</p>
              </dd>
              <dt class="body-small">
               tree
              </dt>
              <dd class="body-medium">
               <p>the FP-tree of item set database.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>the stream of discovered association rules.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="fpgrowth-58a">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="association.html#fpgrowth-58a" t="n" class="documentableName ">fpgrowth</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">minSupport</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">itemsets</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>]]): <span data-unresolved-link="" t="t">Stream</span>[<span data-unresolved-link="" t="t">ItemSet</span>]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Frequent item set mining based on the FP-growth (frequent pattern growth) algorithm, which employs an extended prefix-tree (FP-tree) structure to store the database in a compressed form. The FP-growth algorithm is currently one of the fastest approaches to discover frequent item sets. FP-growth adopts a divide-and-conquer approach to decompose both the mining tasks and the databases. It uses a pattern fragment growth method to avoid the costly process of candidate generation and testing used by Apriori.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Frequent item set mining based on the FP-growth (frequent pattern growth) algorithm, which employs an extended prefix-tree (FP-tree) structure to store the database in a compressed form. The FP-growth algorithm is currently one of the fastest approaches to discover frequent item sets. FP-growth adopts a divide-and-conquer approach to decompose both the mining tasks and the databases. It uses a pattern fragment growth method to avoid the costly process of candidate generation and testing used by Apriori.</p>
              <p>The basic idea of the FP-growth algorithm can be described as a recursive elimination scheme: in a preprocessing step delete all items from the transactions that are not frequent individually, i.e., do not appear in a user-specified minimum number of transactions. Then select all transactions that contain the least frequent item (least frequent among those that are frequent) and delete this item from them. Recurse to process the obtained reduced (also known as projected) database, remembering that the item sets found in the recursion share the deleted item as a prefix. On return, remove the processed item from the database of all transactions and start over, i.e., process the second frequent item etc. In these processing steps the prefix tree, which is enhanced by links between the branches, is exploited to quickly find the transactions containing a given item and also to remove this item from the transactions after it has been processed.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               itemsets
              </dt>
              <dd class="body-medium">
               <p>the item set database. Each row is a item set, which may have different length. The item identifiers have to be in [0, n), where n is the number of items. Item set should NOT contain duplicated items. Note that it is reordered after the call.</p>
              </dd>
              <dt class="body-small">
               minSupport
              </dt>
              <dd class="body-medium">
               <p>the required minimum support of item sets in terms of frequency.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>the stream of frequent item sets.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="fpgrowth-fffffb93">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="association.html#fpgrowth-fffffb93" t="n" class="documentableName ">fpgrowth</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">tree</span>: <span data-unresolved-link="" t="t">FPTree</span>): <span data-unresolved-link="" t="t">Stream</span>[<span data-unresolved-link="" t="t">ItemSet</span>]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Frequent item set mining based on the FP-growth (frequent pattern growth) algorithm, which employs an extended prefix-tree (FP-tree) structure to store the database in a compressed form. The FP-growth algorithm is currently one of the fastest approaches to discover frequent item sets. FP-growth adopts a divide-and-conquer approach to decompose both the mining tasks and the databases. It uses a pattern fragment growth method to avoid the costly process of candidate generation and testing used by Apriori.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Frequent item set mining based on the FP-growth (frequent pattern growth) algorithm, which employs an extended prefix-tree (FP-tree) structure to store the database in a compressed form. The FP-growth algorithm is currently one of the fastest approaches to discover frequent item sets. FP-growth adopts a divide-and-conquer approach to decompose both the mining tasks and the databases. It uses a pattern fragment growth method to avoid the costly process of candidate generation and testing used by Apriori.</p>
              <p>The basic idea of the FP-growth algorithm can be described as a recursive elimination scheme: in a preprocessing step delete all items from the transactions that are not frequent individually, i.e., do not appear in a user-specified minimum number of transactions. Then select all transactions that contain the least frequent item (least frequent among those that are frequent) and delete this item from them. Recurse to process the obtained reduced (also known as projected) database, remembering that the item sets found in the recursion share the deleted item as a prefix. On return, remove the processed item from the database of all transactions and start over, i.e., process the second frequent item etc. In these processing steps the prefix tree, which is enhanced by links between the branches, is exploited to quickly find the transactions containing a given item and also to remove this item from the transactions after it has been processed.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               tree
              </dt>
              <dd class="body-medium">
               <p>the FP-tree of item set database.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>the stream of frequent item sets.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="fptree-f56">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="association.html#fptree-f56" t="n" class="documentableName ">fptree</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">minSupport</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">supplier</span>: <span data-unresolved-link="" t="t">Supplier</span>[<span data-unresolved-link="" t="t">Stream</span>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>]]]): <span data-unresolved-link="" t="t">FPTree</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Builds a FP-tree.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Builds a FP-tree.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               minSupport
              </dt>
              <dd class="body-medium">
               <p>the required minimum support of item sets in terms of frequency.</p>
              </dd>
              <dt class="body-small">
               supplier
              </dt>
              <dd class="body-medium">
               <p>the lambda to retrun a stream of item set database. Each item set may have different length. The item identifiers have to be in [0, n), where n is the number of items. Item set should NOT contain duplicated items. Note that it is reordered after the call.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>the FP-tree.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
       </div>
      </section>
     </div>
    </section>
   </div>
  </div>
 </div>
</section></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#attributes">Attributes</a></li><li><a href="#members-list">Members list</a><ul><li><a href="#Type-members">Type members</a><ul><li><a href="#Classlikes">Classlikes</a></li></ul></li><li><a href="#Value-members">Value members</a><ul><li><a href="#Concrete-methods">Concrete methods</a></li></ul></li></ul></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><div class="text">Copyright © 2010-2025 Haifeng Li. All rights reserved.
Use is subject to license terms.</div></div><div class="text-mobile">Copyright © 2010-2025 Haifeng Li. All rights reserved.
Use is subject to license terms.</div></div></div></div></body></html>