<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Smile - Statistical Machine Intelligence and Learning Engine  - smile.regression</title><meta content="Smile - Statistical Machine Intelligence and Learning Engine - smile.regression" name="description"/><meta content="Smile Statistical Machine Intelligence and Learning Engine smile.regression" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.min.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script></head><body><div id="search"><span id="doc-title">Smile - Statistical Machine Intelligence and Learning Engine<span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title="Smile (Statistical Machine Intelligence and Learning Engine) is a fast and comprehensive machine learning, NLP, linear algebra, graph, interpolation, and visualization system in Java and Scala."><span class="name">root</span></a></span><p class="shortcomment cmt">Smile (Statistical Machine Intelligence and Learning Engine) is
a fast and comprehensive machine learning, NLP, linear algebra,
graph, interpolation, and visualization system in Java and Scala.</p><div class="fullcomment"><div class="comment cmt"><p>Smile (Statistical Machine Intelligence and Learning Engine) is
a fast and comprehensive machine learning, NLP, linear algebra,
graph, interpolation, and visualization system in Java and Scala.
With advanced data structures and algorithms,
Smile delivers state-of-art performance.</p><p>Smile covers every aspect of machine learning, including classification,
regression, clustering, association rule mining, feature selection,
manifold learning, multidimensional scaling, genetic algorithms,
missing value imputation, efficient nearest neighbor search, etc.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.smile" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="smile" class="anchorToMember"></a><a id="smile:smile" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">smile</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="smile.association" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="association" class="anchorToMember"></a><a id="association:association" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/association/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../association/index.html" title="Frequent item set mining and association rule mining."><span class="name">association</span></a></span><p class="shortcomment cmt">Frequent item set mining and association rule mining.</p><div class="fullcomment"><div class="comment cmt"><p>Frequent item set mining and association rule mining.
Association rule learning is a popular and well researched method for
discovering interesting relations between variables in large databases.
Let I = {i<sub>1</sub>, i<sub>2</sub>,..., i<sub>n</sub>} be a set of n
binary attributes called items. Let D = {t<sub>1</sub>, t<sub>2</sub>,..., t<sub>m</sub>}
be a set of transactions called the database. Each transaction in D has a
unique transaction ID and contains a subset of the items in I.
An association rule is defined as an implication of the form X &rArr; Y
where X, Y &sube; I and X &cap; Y = &Oslash;. The item sets X and Y are called
antecedent (left-hand-side or LHS) and consequent (right-hand-side or RHS)
of the rule, respectively. The support supp(X) of an item set X is defined as
the proportion of transactions in the database which contain the item set.
Note that the support of an association rule X &rArr; Y is supp(X &cup; Y).
The confidence of a rule is defined conf(X &rArr; Y) = supp(X &cup; Y) / supp(X).
Confidence can be interpreted as an estimate of the probability P(Y | X),
the probability of finding the RHS of the rule in transactions under the
condition that these transactions also contain the LHS.</p><p>For example, the rule {onions, potatoes} &rArr; {burger} found in the sales
data of a supermarket would indicate that if a customer buys onions and
potatoes together, he or she is likely to also buy burger. Such information
can be used as the basis for decisions about marketing activities such as
promotional pricing or product placements.</p><p>Association rules are usually required to satisfy a user-specified minimum
support and a user-specified minimum confidence at the same time. Association
rule generation is usually split up into two separate steps:</p><ul><li>First, minimum support is applied to find all frequent item sets
   in a database (i.e. frequent item set mining).</li><li>Second, these frequent item sets and the minimum confidence constraint
   are used to form rules.</li></ul><p>Finding all frequent item sets in a database is difficult since it involves
searching all possible item sets (item combinations). The set of possible
item sets is the power set over I (the set of items) and has size 2<sup>n</sup> - 1
(excluding the empty set which is not a valid item set). Although the size
of the power set grows exponentially in the number of items n in I, efficient
search is possible using the downward-closure property of support
(also called anti-monotonicity) which guarantees that for a frequent item set
also all its subsets are frequent and thus for an infrequent item set, all
its supersets must be infrequent.</p><p>In practice, we may only consider the frequent item set that has the maximum
number of items bypassing all the sub item sets. An item set is maximal
frequent if none of its immediate supersets is frequent.</p><p>For a maximal frequent item set, even though we know that all the sub item
sets are frequent, we don't know the actual support of those sub item sets,
which are very important to find the association rules within the item sets.
If the final goal is association rule mining, we would like to discover
closed frequent item sets. An item set is closed if none of its immediate
supersets has the same support as the item set.</p><p>Some well known algorithms of frequent item set mining are Apriori,
Eclat and FP-Growth. Apriori is the best-known algorithm to mine association
rules. It uses a breadth-first search strategy to counting the support of
item sets and uses a candidate generation function which exploits the downward
closure property of support. Eclat is a depth-first search algorithm using
set intersection.</p><p>FP-growth (frequent pattern growth) uses an extended prefix-tree (FP-tree)
structure to store the database in a compressed form. FP-growth adopts a
divide-and-conquer approach to decompose both the mining tasks and the
databases. It uses a pattern fragment growth method to avoid the costly
process of candidate generation and testing used by Apriori.</p><h6>References:</h6><ul><li>R. Agrawal, T. Imielinski and A. Swami. Mining Association Rules Between Sets of Items in Large Databases, SIGMOD, 207-216, 1993.</li><li>Rakesh Agrawal and Ramakrishnan Srikant. Fast algorithms for mining association rules in large databases. VLDB, 487-499, 1994.</li><li>Mohammed J. Zaki. Scalable algorithms for association mining. IEEE Transactions on Knowledge and Data Engineering, 12(3):372-390, 2000.</li><li>Jiawei Han, Jian Pei, Yiwen Yin, and Runying Mao. Mining frequent patterns without candidate generation. Data Mining and Knowledge Discovery 8:53-87, 2004.
</li></ul></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.cas" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="cas" class="anchorToMember"></a><a id="cas:cas" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/cas/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../cas/index.html" title="Computer algebra system."><span class="name">cas</span></a></span><p class="shortcomment cmt">Computer algebra system.</p><div class="fullcomment"><div class="comment cmt"><p>Computer algebra system.
A computer algebra system (CAS) has the ability to manipulate mathematical
expressions in a way similar to the traditional manual computations of
mathematicians and scientists.</p><p>The symbolic manipulations supported include:</p><ul><li>simplification to a smaller expression or some standard form,
including automatic simplification with assumptions and
simplification with constraints</li><li>substitution of symbols or numeric values for certain expressions</li><li>change of form of expressions: expanding products and powers, partial
and full factorization, rewriting as partial fractions, constraint
satisfaction, rewriting trigonometric functions as exponentials,
transforming logic expressions, etc.</li><li>partial and total differentiation</li><li>matrix operations including products, inverses, etc.
</li></ul></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.classification" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="classification" class="anchorToMember"></a><a id="classification:classification" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/classification/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../classification/index.html" title="Classification algorithms."><span class="name">classification</span></a></span><p class="shortcomment cmt">Classification algorithms.</p><div class="fullcomment"><div class="comment cmt"><p>Classification algorithms. In machine learning and pattern recognition,
classification refers to an algorithmic procedure for assigning a given
input object into one of a given number of categories. The input
object is formally termed an instance, and the categories are termed classes.</p><p>The instance is usually described by a vector of features, which together
constitute a description of all known characteristics of the instance.
Typically, features are either categorical (also known as nominal, i.e.
consisting of one of a set of unordered items, such as a gender of "male"
or "female", or a blood type of "A", "B", "AB" or "O"), ordinal (consisting
of one of a set of ordered items, e.g. "large", "medium" or "small"),
integer-valued (e.g. a count of the number of occurrences of a particular
word in an email) or real-valued (e.g. a measurement of blood pressure).</p><p>Classification normally refers to a supervised procedure, i.e. a procedure
that produces an inferred function to predict the output value of new
instances based on a training set of pairs consisting of an input object
and a desired output value. The inferred function is called a classifier
if the output is discrete or a regression function if the output is
continuous.</p><p>The inferred function should predict the correct output value for any valid
input object. This requires the learning algorithm to generalize from the
training data to unseen situations in a "reasonable" way.</p><p>A wide range of supervised learning algorithms is available, each with
its strengths and weaknesses. There is no single learning algorithm that
works best on all supervised learning problems. The most widely used
learning algorithms are AdaBoost and gradient boosting, support vector
machines, linear regression, linear discriminant analysis, logistic
regression, naive Bayes, decision trees, k-nearest neighbor algorithm,
and neural networks (multilayer perceptron).</p><p>If the feature vectors include features of many different kinds (discrete,
discrete ordered, counts, continuous values), some algorithms cannot be
easily applied. Many algorithms, including linear regression, logistic
regression, neural networks, and nearest neighbor methods, require that
the input features be numerical and scaled to similar ranges (e.g., to
the [-1,1] interval). Methods that employ a distance function, such as
nearest neighbor methods and support vector machines with Gaussian kernels,
are particularly sensitive to this. An advantage of decision trees (and
boosting algorithms based on decision trees) is that they easily handle
heterogeneous data.</p><p>If the input features contain redundant information (e.g., highly correlated
features), some learning algorithms (e.g., linear regression, logistic
regression, and distance based methods) will perform poorly because of
numerical instabilities. These problems can often be solved by imposing
some form of regularization.</p><p>If each of the features makes an independent contribution to the output,
then algorithms based on linear functions (e.g., linear regression,
logistic regression, linear support vector machines, naive Bayes) generally
perform well. However, if there are complex interactions among features,
then algorithms such as nonlinear support vector machines, decision trees
and neural networks work better. Linear methods can also be applied, but
the engineer must manually specify the interactions when using them.</p><p>There are several major issues to consider in supervised learning:</p><ul><li><b>Features:</b>
The accuracy of the inferred function depends strongly on how the input
object is represented. Typically, the input object is transformed into
a feature vector, which contains a number of features that are descriptive
of the object. The number of features should not be too large, because of
the curse of dimensionality; but should contain enough information to
accurately predict the output.
There are many algorithms for feature selection that seek to identify
the relevant features and discard the irrelevant ones. More generally,
dimensionality reduction may seek to map the input data into a lower
dimensional space prior to running the supervised learning algorithm.</li><li><b>Overfitting:</b>
Overfitting occurs when a statistical model describes random error
or noise instead of the underlying relationship. Overfitting generally
occurs when a model is excessively complex, such as having too many
parameters relative to the number of observations. A model which has
been overfit will generally have poor predictive performance, as it can
exaggerate minor fluctuations in the data.
The potential for overfitting depends not only on the number of parameters
and data but also the conformability of the model structure with the data
shape, and the magnitude of model error compared to the expected level
of noise or error in the data.
In order to avoid overfitting, it is necessary to use additional techniques
(e.g. cross-validation, regularization, early stopping, pruning, Bayesian
priors on parameters or model comparison), that can indicate when further
training is not resulting in better generalization. The basis of some
techniques is either (1) to explicitly penalize overly complex models,
or (2) to test the model's ability to generalize by evaluating its
performance on a set of data not used for training, which is assumed to
approximate the typical unseen data that a model will encounter.</li><li><b>Regularization:</b>
Regularization involves introducing additional information in order
to solve an ill-posed problem or to prevent over-fitting. This information
is usually of the form of a penalty for complexity, such as restrictions
for smoothness or bounds on the vector space norm.
A theoretical justification for regularization is that it attempts to impose
Occam's razor on the solution. From a Bayesian point of view, many
regularization techniques correspond to imposing certain prior distributions
on model parameters.</li><li><b>Bias-variance tradeoff:</b>
Mean squared error (MSE) can be broken down into two components:
variance and squared bias, known as the bias-variance decomposition.
Thus in order to minimize the MSE, we need to minimize both the bias and
the variance. However, this is not trivial. Therefore, there is a tradeoff
between bias and variance.
</li></ul></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.clustering" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="clustering" class="anchorToMember"></a><a id="clustering:clustering" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/clustering/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../clustering/index.html" title="Clustering analysis."><span class="name">clustering</span></a></span><p class="shortcomment cmt">Clustering analysis.</p><div class="fullcomment"><div class="comment cmt"><p>Clustering analysis. Clustering is the assignment of a set of observations
into subsets (called clusters) so that observations in the same cluster are
similar in some sense. Clustering is a method of unsupervised learning,
and a common technique for statistical data analysis used in many fields.</p><p>Hierarchical algorithms find successive clusters using previously
established clusters. These algorithms usually are either agglomerative
("bottom-up") or divisive ("top-down"). Agglomerative algorithms begin
with each element as a separate cluster and merge them into successively
larger clusters. Divisive algorithms begin with the whole set and proceed
to divide it into successively smaller clusters.</p><p>Partitional algorithms typically determine all clusters at once, but can
also be used as divisive algorithms in the hierarchical clustering.
Many partitional clustering algorithms require the specification of
the number of clusters to produce in the input data set, prior to
execution of the algorithm. Barring knowledge of the proper value
beforehand, the appropriate value must be determined, a problem on
its own for which a number of techniques have been developed.</p><p>Density-based clustering algorithms are devised to discover
arbitrary-shaped clusters. In this approach, a cluster is regarded as
a region in which the density of data objects exceeds a threshold.</p><p>Subspace clustering methods look for clusters that can only be seen in
a particular projection (subspace, manifold) of the data. These methods
thus can ignore irrelevant attributes. The general problem is also known
as Correlation clustering while the special case of axis-parallel subspaces
is also known as two-way clustering, co-clustering or biclustering in
bioinformatics: in these methods not only the objects are clustered but
also the features of the objects, i.e., if the data is represented in
a data matrix, the rows and columns are clustered simultaneously. They
usually do not however work with arbitrary feature combinations as in general
subspace methods.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.data" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="data" class="anchorToMember"></a><a id="data:data" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/data/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../data/index.html" title="Data manipulation functions."><span class="name">data</span></a></span><p class="shortcomment cmt">Data manipulation functions.</p><div class="fullcomment"><div class="comment cmt"><p>Data manipulation functions.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.feature" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="feature" class="anchorToMember"></a><a id="feature:feature" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/feature/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../feature/index.html" title=""><span class="name">feature</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.manifold" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="manifold" class="anchorToMember"></a><a id="manifold:manifold" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/manifold/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../manifold/index.html" title="Manifold learning finds a low-dimensional basis for describing high-dimensional data."><span class="name">manifold</span></a></span><p class="shortcomment cmt">Manifold learning finds a low-dimensional basis for describing
high-dimensional data.</p><div class="fullcomment"><div class="comment cmt"><p>Manifold learning finds a low-dimensional basis for describing
high-dimensional data. Manifold learning is a popular approach to nonlinear
dimensionality reduction. Algorithms for this task are based on the idea
that the dimensionality of many data sets is only artificially high; though
each data point consists of perhaps thousands of features, it may be
described as a function of only a few underlying parameters. That is, the
data points are actually samples from a low-dimensional manifold that is
embedded in a high-dimensional space. Manifold learning algorithms attempt
to uncover these parameters in order to find a low-dimensional representation
of the data.</p><p>Some prominent approaches are locally linear embedding
(LLE), Hessian LLE, Laplacian eigenmaps, and LTSA. These techniques
construct a low-dimensional data representation using a cost function
that retains local properties of the data, and can be viewed as defining
a graph-based kernel for Kernel PCA. More recently, techniques have been
proposed that, instead of defining a fixed kernel, try to learn the kernel
using semidefinite programming. The most prominent example of such a
technique is maximum variance unfolding (MVU). The central idea of MVU
is to exactly preserve all pairwise distances between nearest neighbors
(in the inner product space), while maximizing the distances between points
that are not nearest neighbors.</p><p>An alternative approach to neighborhood preservation is through the
minimization of a cost function that measures differences between
distances in the input and output spaces. Important examples of such
techniques include classical multidimensional scaling (which is identical
to PCA), Isomap (which uses geodesic distances in the data space), diffusion
maps (which uses diffusion distances in the data space), t-SNE (which
minimizes the divergence between distributions over pairs of points),
and curvilinear component analysis.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.math" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="math" class="anchorToMember"></a><a id="math:math" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/math/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../math/index.html" title="Mathematical and statistical functions."><span class="name">math</span></a></span><p class="shortcomment cmt">Mathematical and statistical functions.</p><div class="fullcomment"><div class="comment cmt"><p>Mathematical and statistical functions.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.nlp" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="nlp" class="anchorToMember"></a><a id="nlp:nlp" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/nlp/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../nlp/index.html" title="Natural language processing."><span class="name">nlp</span></a></span><p class="shortcomment cmt">Natural language processing.</p><div class="fullcomment"><div class="comment cmt"><p>Natural language processing.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.plot" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="plot" class="anchorToMember"></a><a id="plot:plot" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/plot/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../plot/index.html" title="Data visualization."><span class="name">plot</span></a></span><p class="shortcomment cmt">Data visualization.</p><div class="fullcomment"><div class="comment cmt"><p>Data visualization.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 current" name="smile.regression" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="regression" class="anchorToMember"></a><a id="regression:regression" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/regression/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">regression</span></span><p class="shortcomment cmt">Regression analysis.</p><div class="fullcomment"><div class="comment cmt"><p>Regression analysis. Regression analysis includes any
techniques for modeling and analyzing several variables, when the focus
is on the relationship between a dependent variable and one or more
independent variables. Most commonly, regression analysis estimates the
conditional expectation of the dependent variable given the independent
variables. Therefore, the estimation target is a function of the independent
variables called the regression function. Regression analysis is widely
used for prediction and forecasting.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="current-entities indented2"><span class="separator"></span> <a href="package$$gpr$.html" title="Gaussian Process for Regression." class="object"></a><a href="package$$gpr$.html" title="Gaussian Process for Regression.">gpr</a></li><li class="indented2 " name="smile.sequence" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sequence" class="anchorToMember"></a><a id="sequence:sequence" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/sequence/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../sequence/index.html" title="Sequence labeling algorithms."><span class="name">sequence</span></a></span><p class="shortcomment cmt">Sequence labeling algorithms.</p><div class="fullcomment"><div class="comment cmt"><p>Sequence labeling algorithms.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.util" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="util" class="anchorToMember"></a><a id="util:util" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/util/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../util/index.html" title="Utility functions."><span class="name">util</span></a></span><p class="shortcomment cmt">Utility functions.</p><div class="fullcomment"><div class="comment cmt"><p>Utility functions.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.validation" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="validation" class="anchorToMember"></a><a id="validation:validation" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/validation/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../validation/index.html" title="Model validation."><span class="name">validation</span></a></span><p class="shortcomment cmt">Model validation.</p><div class="fullcomment"><div class="comment cmt"><p>Model validation.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li><li class="indented2 " name="smile.wavelet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wavelet" class="anchorToMember"></a><a id="wavelet:wavelet" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/wavelet/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../wavelet/index.html" title="A wavelet is a wave-like oscillation with an amplitude that starts out at zero, increases, and then decreases back to zero."><span class="name">wavelet</span></a></span><p class="shortcomment cmt">A wavelet is a wave-like oscillation with an amplitude that starts out at
zero, increases, and then decreases back to zero.</p><div class="fullcomment"><div class="comment cmt"><p>A wavelet is a wave-like oscillation with an amplitude that starts out at
zero, increases, and then decreases back to zero. Like the fast Fourier
transform (FFT), the discrete wavelet transform (DWT) is a fast, linear
operation that operates on a data vector whose length is an integer power
of 2, transforming it into a numerically different vector of the same length.
The wavelet transform is invertible and in fact orthogonal. Both FFT and DWT
can be viewed as a rotation in function space.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="smile" id="smile" class="extype">smile</a></dd></dl></div></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><p id="owner"><a href="../index.html" name="smile" id="smile" class="extype">smile</a></p><h1>regression<span class="permalink"><a href="../../smile/regression/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">regression</span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Regression analysis. Regression analysis includes any
techniques for modeling and analyzing several variables, when the focus
is on the relationship between a dependent variable and one or more
independent variables. Most commonly, regression analysis estimates the
conditional expectation of the dependent variable given the independent
variables. Therefore, the estimation target is a function of the independent
variables called the regression function. Regression analysis is widely
used for prediction and forecasting.
</p></div><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="https://www.scala-lang.org/api/2.13.11/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>, <a href="https://www.scala-lang.org/api/2.13.11/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="smile.regression"><span>regression</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="smile.regression#cart" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="cart(formula:smile.data.formula.Formula,data:smile.data.DataFrame,maxDepth:Int,maxNodes:Int,nodeSize:Int):smile.regression.RegressionTree" class="anchorToMember"></a><a id="cart(Formula,DataFrame,Int,Int,Int):RegressionTree" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/regression/index.html#cart(formula:smile.data.formula.Formula,data:smile.data.DataFrame,maxDepth:Int,maxNodes:Int,nodeSize:Int):smile.regression.RegressionTree" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">cart</span><span class="params">(<span name="formula">formula: <span name="smile.data.formula.Formula" class="extype">Formula</span></span>, <span name="data">data: <span name="smile.data.DataFrame" class="extype">DataFrame</span></span>, <span name="maxDepth">maxDepth: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">20</span></span>, <span name="maxNodes">maxNodes: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">0</span></span>, <span name="nodeSize">nodeSize: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">5</span></span>)</span><span class="result">: <span name="smile.regression.RegressionTree" class="extype">RegressionTree</span></span></span><p class="shortcomment cmt">Regression tree.</p><div class="fullcomment"><div class="comment cmt"><p>Regression tree. A classification/regression tree can be learned by
splitting the training set into subsets based on an attribute value
test. This process is repeated on each derived subset in a recursive
manner called recursive partitioning. The recursion is completed when
the subset at a node all has the same value of the target variable,
or when splitting no longer adds value to the predictions.</p><p>The algorithms that are used for constructing decision trees usually
work top-down by choosing a variable at each step that is the next best
variable to use in splitting the set of items. "Best" is defined by how
well the variable splits the set into homogeneous subsets that have
the same value of the target variable. Different algorithms use different
formulae for measuring "best". Used by the CART algorithm, Gini impurity
is a measure of how often a randomly chosen element from the set would
be incorrectly labeled if it were randomly labeled according to the
distribution of labels in the subset. Gini impurity can be computed by
summing the probability of each item being chosen times the probability
of a mistake in categorizing that item. It reaches its minimum (zero) when
all cases in the node fall into a single target category. Information gain
is another popular measure, used by the ID3, C4.5 and C5.0 algorithms.
Information gain is based on the concept of entropy used in information
theory. For categorical variables with different number of levels, however,
information gain are biased in favor of those attributes with more levels.
Instead, one may employ the information gain ratio, which solves the drawback
of information gain.</p><p>Classification and Regression Tree techniques have a number of advantages
over many of those alternative techniques.</p><ul><li><b>Simple to understand and interpret:</b>
In most cases, the interpretation of results summarized in a tree is
very simple. This simplicity is useful not only for purposes of rapid
classification of new observations, but can also often yield a much simpler
"model" for explaining why observations are classified or predicted in a
particular manner.</li><li><b>Able to handle both numerical and categorical data:</b>
Other techniques are usually specialized in analyzing datasets that
have only one type of variable.</li><li><b>Nonparametric and nonlinear:</b>
The final results of using tree methods for classification or regression
can be summarized in a series of (usually few) logical if-then conditions
(tree nodes). Therefore, there is no implicit assumption that the underlying
relationships between the predictor variables and the dependent variable
are linear, follow some specific non-linear link function, or that they
are even monotonic in nature. Thus, tree methods are particularly well
suited for data mining tasks, where there is often little a priori
knowledge nor any coherent set of theories or predictions regarding which
variables are related and how. In those types of data analytics, tree
methods can often reveal simple relationships between just a few variables
that could have easily gone unnoticed using other analytic techniques.</li></ul><p>One major problem with classification and regression trees is their high
variance. Often a small change in the data can result in a very different
series of splits, making interpretation somewhat precarious. Besides,
decision-tree learners can create over-complex trees that cause over-fitting.
Mechanisms such as pruning are necessary to avoid this problem.
Another limitation of trees is the lack of smoothness of the prediction
surface.</p><p>Some techniques such as bagging, boosting, and random forest use more than
one decision tree for their analysis.
</p></div><dl class="paramcmts block"><dt class="param">formula</dt><dd class="cmt"><p>a symbolic description of the model to be fitted.</p></dd><dt class="param">data</dt><dd class="cmt"><p>the data frame of the explanatory and response variables.</p></dd><dt class="param">maxDepth</dt><dd class="cmt"><p>the maximum depth of the tree.</p></dd><dt class="param">maxNodes</dt><dd class="cmt"><p>the maximum number of leaf nodes in the tree.</p></dd><dt class="param">nodeSize</dt><dd class="cmt"><p>the minimum size of leaf nodes.</p></dd><dt>returns</dt><dd class="cmt"><p>Regression tree model.</p></dd></dl></div></li><li class="indented0 " name="smile.regression#gbm" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="gbm(formula:smile.data.formula.Formula,data:smile.data.DataFrame,loss:smile.base.cart.Loss,ntrees:Int,maxDepth:Int,maxNodes:Int,nodeSize:Int,shrinkage:Double,subsample:Double):smile.regression.GradientTreeBoost" class="anchorToMember"></a><a id="gbm(Formula,DataFrame,Loss,Int,Int,Int,Int,Double,Double):GradientTreeBoost" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/regression/index.html#gbm(formula:smile.data.formula.Formula,data:smile.data.DataFrame,loss:smile.base.cart.Loss,ntrees:Int,maxDepth:Int,maxNodes:Int,nodeSize:Int,shrinkage:Double,subsample:Double):smile.regression.GradientTreeBoost" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">gbm</span><span class="params">(<span name="formula">formula: <span name="smile.data.formula.Formula" class="extype">Formula</span></span>, <span name="data">data: <span name="smile.data.DataFrame" class="extype">DataFrame</span></span>, <span name="loss">loss: <span name="smile.base.cart.Loss" class="extype">Loss</span> = <span class="symbol"><span class="name"><a href="../index.html">Loss.lad()</a></span></span></span>, <span name="ntrees">ntrees: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">500</span></span>, <span name="maxDepth">maxDepth: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">20</span></span>, <span name="maxNodes">maxNodes: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">6</span></span>, <span name="nodeSize">nodeSize: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">5</span></span>, <span name="shrinkage">shrinkage: <a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">0.05</span></span>, <span name="subsample">subsample: <a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">0.7</span></span>)</span><span class="result">: <span name="smile.regression.GradientTreeBoost" class="extype">GradientTreeBoost</span></span></span><p class="shortcomment cmt">Gradient boosted regression trees.</p><div class="fullcomment"><div class="comment cmt"><p>Gradient boosted regression trees.</p><p>Generic gradient boosting at the t-th step would fit a regression tree to
pseudo-residuals. Let J be the number of its leaves. The tree partitions
the input space into J disjoint regions and predicts a constant value in
each region. The parameter J controls the maximum allowed
level of interaction between variables in the model. With J = 2 (decision
stumps), no interaction between variables is allowed. With J = 3 the model
may include effects of the interaction between up to two variables, and
so on. Hastie et al. comment that typically 4 &le; J &le; 8 work well
for boosting and results are fairly insensitive to the choice of in
this range, J = 2 is insufficient for many applications, and J &gt; 10 is
unlikely to be required.</p><p>Fitting the training set too closely can lead to degradation of the model's
generalization ability. Several so-called regularization techniques reduce
this over-fitting effect by constraining the fitting procedure.
One natural regularization parameter is the number of gradient boosting
iterations T (i.e. the number of trees in the model when the base learner
is a decision tree). Increasing T reduces the error on training set,
but setting it too high may lead to over-fitting. An optimal value of T
is often selected by monitoring prediction error on a separate validation
data set.</p><p>Another regularization approach is the shrinkage which times a parameter
&eta; (called the "learning rate") to update term.
Empirically it has been found that using small learning rates (such as
&eta; &lt; 0.1) yields dramatic improvements in model's generalization ability
over gradient boosting without shrinking (&eta; = 1). However, it comes at
the price of increasing computational time both during training and
prediction: lower learning rate requires more iterations.</p><p>Soon after the introduction of gradient boosting Friedman proposed a
minor modification to the algorithm, motivated by Breiman's bagging method.
Specifically, he proposed that at each iteration of the algorithm, a base
learner should be fit on a subsample of the training set drawn at random
without replacement. Friedman observed a substantial improvement in
gradient boosting's accuracy with this modification.</p><p>Subsample size is some constant fraction f of the size of the training set.
When f = 1, the algorithm is deterministic and identical to the one
described above. Smaller values of f introduce randomness into the
algorithm and help prevent over-fitting, acting as a kind of regularization.
The algorithm also becomes faster, because regression trees have to be fit
to smaller datasets at each iteration. Typically, f is set to 0.5, meaning
that one half of the training set is used to build each base learner.</p><p>Also, like in bagging, sub-sampling allows one to define an out-of-bag
estimate of the prediction performance improvement by evaluating predictions
on those observations which were not used in the building of the next
base learner. Out-of-bag estimates help avoid the need for an independent
validation dataset, but often underestimate actual performance improvement
and the optimal number of iterations.</p><p>Gradient tree boosting implementations often also use regularization by
limiting the minimum number of observations in trees' terminal nodes.
It's used in the tree building process by ignoring any splits that lead
to nodes containing fewer than this number of training set instances.
Imposing this limit helps to reduce variance in predictions at leaves.</p><h6>References:</h6><ul><li>J. H. Friedman. Greedy Function Approximation: A Gradient Boosting Machine, 1999.</li><li>J. H. Friedman. Stochastic Gradient Boosting, 1999.
</li></ul></div><dl class="paramcmts block"><dt class="param">formula</dt><dd class="cmt"><p>a symbolic description of the model to be fitted.</p></dd><dt class="param">data</dt><dd class="cmt"><p>the data frame of the explanatory and response variables.</p></dd><dt class="param">loss</dt><dd class="cmt"><p>loss function for regression. By default, least absolute
            deviation is employed for robust regression.</p></dd><dt class="param">ntrees</dt><dd class="cmt"><p>the number of iterations (trees).</p></dd><dt class="param">maxDepth</dt><dd class="cmt"><p>the maximum depth of the tree.</p></dd><dt class="param">maxNodes</dt><dd class="cmt"><p>the maximum number of leaf nodes in the tree.</p></dd><dt class="param">nodeSize</dt><dd class="cmt"><p>the minimum size of leaf nodes.</p></dd><dt class="param">shrinkage</dt><dd class="cmt"><p>the shrinkage parameter in (0, 1] controls the learning rate of procedure.</p></dd><dt class="param">subsample</dt><dd class="cmt"><p>the sampling fraction for stochastic tree boosting.</p></dd><dt>returns</dt><dd class="cmt"><p>Gradient boosted trees.</p></dd></dl></div></li><li class="indented0 " name="smile.regression#lasso" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lasso(formula:smile.data.formula.Formula,data:smile.data.DataFrame,lambda:Double,tol:Double,maxIter:Int):smile.regression.LinearModel" class="anchorToMember"></a><a id="lasso(Formula,DataFrame,Double,Double,Int):LinearModel" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/regression/index.html#lasso(formula:smile.data.formula.Formula,data:smile.data.DataFrame,lambda:Double,tol:Double,maxIter:Int):smile.regression.LinearModel" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lasso</span><span class="params">(<span name="formula">formula: <span name="smile.data.formula.Formula" class="extype">Formula</span></span>, <span name="data">data: <span name="smile.data.DataFrame" class="extype">DataFrame</span></span>, <span name="lambda">lambda: <a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a></span>, <span name="tol">tol: <a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">1E-3</span></span>, <span name="maxIter">maxIter: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">5000</span></span>)</span><span class="result">: <span name="smile.regression.LinearModel" class="extype">LinearModel</span></span></span><p class="shortcomment cmt">Least absolute shrinkage and selection operator.</p><div class="fullcomment"><div class="comment cmt"><p>Least absolute shrinkage and selection operator.
The Lasso is a shrinkage and selection method for linear regression.
It minimizes the usual sum of squared errors, with a bound on the sum
of the absolute values of the coefficients (i.e. L<sub>1</sub>-regularized).
It has connections to soft-thresholding of wavelet coefficients, forward
stage-wise regression, and boosting methods.</p><p>The Lasso typically yields a sparse solution, of which the parameter
vector &beta; has relatively few nonzero coefficients. In contrast, the
solution of L<sub>2</sub>-regularized least squares (i.e. ridge regression)
typically has all coefficients nonzero. Because it effectively
reduces the number of variables, the Lasso is useful in some contexts.</p><p>For over-determined systems (more instances than variables, commonly in
machine learning), we normalize variables with mean 0 and standard deviation
1. For under-determined systems (less instances than variables, e.g.
compressed sensing), we assume white noise (i.e. no intercept in the linear
model) and do not perform normalization. Note that the solution
is not unique in this case.</p><p>There is no analytic formula or expression for the optimal solution to the
L<sub>1</sub>-regularized least squares problems. Therefore, its solution
must be computed numerically. The objective function in the
L<sub>1</sub>-regularized least squares is convex but not differentiable,
so solving it is more of a computational challenge than solving the
L<sub>2</sub>-regularized least squares. The Lasso may be solved using
quadratic programming or more general convex optimization methods, as well
as by specific algorithms such as the least angle regression algorithm.</p><h6>References:</h6><ul><li>R. Tibshirani. Regression shrinkage and selection via the lasso. J. Royal. Statist. Soc B., 58(1):267-288, 1996.</li><li>B. Efron, I. Johnstone, T. Hastie, and R. Tibshirani. Least angle regression. Annals of Statistics, 2003</li><li>Seung-Jean Kim, K. Koh, M. Lustig, Stephen Boyd, and Dimitry Gorinevsky. An Interior-Point Method for Large-Scale L1-Regularized Least Squares. IEEE JOURNAL OF SELECTED TOPICS IN SIGNAL PROCESSING, VOL. 1, NO. 4, 2007.
</li></ul></div><dl class="paramcmts block"><dt class="param">formula</dt><dd class="cmt"><p>a symbolic description of the model to be fitted.</p></dd><dt class="param">data</dt><dd class="cmt"><p>the data frame of the explanatory and response variables.</p></dd><dt class="param">lambda</dt><dd class="cmt"><p>the shrinkage/regularization parameter.</p></dd><dt class="param">tol</dt><dd class="cmt"><p>the tolerance for stopping iterations (relative target duality gap).</p></dd><dt class="param">maxIter</dt><dd class="cmt"><p>the maximum number of iterations.</p></dd></dl></div></li><li class="indented0 " name="smile.regression#lm" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lm(formula:smile.data.formula.Formula,data:smile.data.DataFrame,method:String,stderr:Boolean,recursive:Boolean):smile.regression.LinearModel" class="anchorToMember"></a><a id="lm(Formula,DataFrame,String,Boolean,Boolean):LinearModel" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/regression/index.html#lm(formula:smile.data.formula.Formula,data:smile.data.DataFrame,method:String,stderr:Boolean,recursive:Boolean):smile.regression.LinearModel" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lm</span><span class="params">(<span name="formula">formula: <span name="smile.data.formula.Formula" class="extype">Formula</span></span>, <span name="data">data: <span name="smile.data.DataFrame" class="extype">DataFrame</span></span>, <span name="method">method: <span name="scala.Predef.String" class="extype">String</span> = <span class="symbol">"qr"</span></span>, <span name="stderr">stderr: <a href="https://www.scala-lang.org/api/2.13.11/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">true</span></span>, <span name="recursive">recursive: <a href="https://www.scala-lang.org/api/2.13.11/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">true</span></span>)</span><span class="result">: <span name="smile.regression.LinearModel" class="extype">LinearModel</span></span></span><p class="shortcomment cmt">Fitting linear models (ordinary least squares).</p><div class="fullcomment"><div class="comment cmt"><p>Fitting linear models (ordinary least squares). In linear regression,
the model specification is that the dependent variable is a linear
combination of the parameters (but need not be linear in the independent
variables). The residual is the difference between the value of the
dependent variable predicted by the model, and the true value of the
dependent variable. Ordinary least squares obtains parameter estimates
that minimize the sum of squared residuals, SSE (also denoted RSS).</p><p>The OLS estimator is consistent when the independent variables are
exogenous and there is no multicollinearity, and optimal in the class
of linear unbiased estimators when the errors are homoscedastic and
serially uncorrelated. Under these conditions, the method of OLS provides
minimum-variance mean-unbiased estimation when the errors have finite
variances.</p><p>There are several different frameworks in which the linear regression
model can be cast in order to make the OLS technique applicable. Each
of these settings produces the same formulas and same results, the only
difference is the interpretation and the assumptions which have to be
imposed in order for the method to give meaningful results. The choice
of the applicable framework depends mostly on the nature of data at hand,
and on the inference task which has to be performed.</p><p>Least squares corresponds to the maximum likelihood criterion if the
experimental errors have a normal distribution and can also be derived
as a method of moments estimator.</p><p>Once a regression model has been constructed, it may be important to
confirm the goodness of fit of the model and the statistical significance
of the estimated parameters. Commonly used checks of goodness of fit
include the R-squared, analysis of the pattern of residuals and hypothesis
testing. Statistical significance can be checked by an F-test of the overall
fit, followed by t-tests of individual parameters.</p><p>Interpretations of these diagnostic tests rest heavily on the model
assumptions. Although examination of the residuals can be used to
invalidate a model, the results of a t-test or F-test are sometimes more
difficult to interpret if the model's assumptions are violated.
For example, if the error term does not have a normal distribution,
in small samples the estimated parameters will not follow normal
distributions and complicate inference. With relatively large samples,
however, a central limit theorem can be invoked such that hypothesis
testing may proceed using asymptotic approximations.
</p></div><dl class="paramcmts block"><dt class="param">formula</dt><dd class="cmt"><p>a symbolic description of the model to be fitted.</p></dd><dt class="param">data</dt><dd class="cmt"><p>the data frame of the explanatory and response variables.</p></dd><dt class="param">method</dt><dd class="cmt"><p>the fitting method ("svd" or "qr").</p></dd><dt class="param">recursive</dt><dd class="cmt"><p>if true, the return model supports recursive least squares.</p></dd></dl></div></li><li class="indented0 " name="smile.regression#randomForest" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="randomForest(formula:smile.data.formula.Formula,data:smile.data.DataFrame,ntrees:Int,mtry:Int,maxDepth:Int,maxNodes:Int,nodeSize:Int,subsample:Double):smile.regression.RandomForest" class="anchorToMember"></a><a id="randomForest(Formula,DataFrame,Int,Int,Int,Int,Int,Double):RandomForest" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/regression/index.html#randomForest(formula:smile.data.formula.Formula,data:smile.data.DataFrame,ntrees:Int,mtry:Int,maxDepth:Int,maxNodes:Int,nodeSize:Int,subsample:Double):smile.regression.RandomForest" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">randomForest</span><span class="params">(<span name="formula">formula: <span name="smile.data.formula.Formula" class="extype">Formula</span></span>, <span name="data">data: <span name="smile.data.DataFrame" class="extype">DataFrame</span></span>, <span name="ntrees">ntrees: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">500</span></span>, <span name="mtry">mtry: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">0</span></span>, <span name="maxDepth">maxDepth: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">20</span></span>, <span name="maxNodes">maxNodes: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">500</span></span>, <span name="nodeSize">nodeSize: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">5</span></span>, <span name="subsample">subsample: <a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">1.0</span></span>)</span><span class="result">: <span name="smile.regression.RandomForest" class="extype">RandomForest</span></span></span><p class="shortcomment cmt">Random forest for regression.</p><div class="fullcomment"><div class="comment cmt"><p>Random forest for regression. Random forest is an ensemble classifier
that consists of many decision trees and outputs the majority vote of
individual trees. The method combines bagging idea and the random
selection of features.</p><p>Each tree is constructed using the following algorithm:</p><ol class="lowerRoman"><li>If the number of cases in the training set is N, randomly sample N cases
with replacement from the original data. This sample will
be the training set for growing the tree.</li><li>If there are M input variables, a number m &lt;&lt; M is specified such
that at each node, m variables are selected at random out of the M and
the best split on these m is used to split the node. The value of m is
held constant during the forest growing.</li><li>Each tree is grown to the largest extent possible. There is no pruning.</li></ol><p>The advantages of random forest are:</p><ul><li>For many data sets, it produces a highly accurate classifier.</li><li>It runs efficiently on large data sets.</li><li>It can handle thousands of input variables without variable deletion.</li><li>It gives estimates of what variables are important in the classification.</li><li>It generates an internal unbiased estimate of the generalization error
as the forest building progresses.</li><li>It has an effective method for estimating missing data and maintains
accuracy when a large proportion of the data are missing.</li></ul><p>The disadvantages are</p><ul><li>Random forests are prone to over-fitting for some datasets. This is
even more pronounced on noisy data.</li><li>For data including categorical variables with different number of
levels, random forests are biased in favor of those attributes with more
levels. Therefore, the variable importance scores from random forest are
not reliable for this type of data.
</li></ul></div><dl class="paramcmts block"><dt class="param">formula</dt><dd class="cmt"><p>a symbolic description of the model to be fitted.</p></dd><dt class="param">data</dt><dd class="cmt"><p>the data frame of the explanatory and response variables.</p></dd><dt class="param">ntrees</dt><dd class="cmt"><p>the number of trees.</p></dd><dt class="param">mtry</dt><dd class="cmt"><p>the number of input variables to be used to determine the decision
            at a node of the tree. dim/3 seems to give generally good performance,
            where dim is the number of variables.</p></dd><dt class="param">maxDepth</dt><dd class="cmt"><p>the maximum depth of the tree.</p></dd><dt class="param">maxNodes</dt><dd class="cmt"><p>the maximum number of leaf nodes in the tree.</p></dd><dt class="param">nodeSize</dt><dd class="cmt"><p>the minimum size of leaf nodes.</p></dd><dt class="param">subsample</dt><dd class="cmt"><p>the sampling rate for training tree. 1.0 means sampling with replacement.
                 &lt; 1.0 means sampling without replacement.</p></dd><dt>returns</dt><dd class="cmt"><p>Random forest regression model.</p></dd></dl></div></li><li class="indented0 " name="smile.regression#rbfnet" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="rbfnet(x:Array[Array[Double]],y:Array[Double],k:Int,normalized:Boolean):smile.regression.RBFNetwork[Array[Double]]" class="anchorToMember"></a><a id="rbfnet(Array[Array[Double]],Array[Double],Int,Boolean):RBFNetwork[Array[Double]]" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/regression/index.html#rbfnet(x:Array[Array[Double]],y:Array[Double],k:Int,normalized:Boolean):smile.regression.RBFNetwork[Array[Double]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">rbfnet</span><span class="params">(<span name="x">x: <a href="https://www.scala-lang.org/api/2.13.11/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.11/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]]</span>, <span name="y">y: <a href="https://www.scala-lang.org/api/2.13.11/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]</span>, <span name="k">k: <a href="https://www.scala-lang.org/api/2.13.11/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="normalized">normalized: <a href="https://www.scala-lang.org/api/2.13.11/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">false</span></span>)</span><span class="result">: <span name="smile.regression.RBFNetwork" class="extype">RBFNetwork</span>[<a href="https://www.scala-lang.org/api/2.13.11/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]]</span></span><p class="shortcomment cmt">Trains a Gaussian RBF network with k-means.</p></li><li class="indented0 " name="smile.regression#rbfnet" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="rbfnet[T&lt;:AnyRef](x:Array[T],y:Array[Double],neurons:Array[smile.base.rbf.RBF[T]],normalized:Boolean):smile.regression.RBFNetwork[T]" class="anchorToMember"></a><a id="rbfnet[T&lt;:AnyRef](Array[T],Array[Double],Array[RBF[T]],Boolean):RBFNetwork[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/regression/index.html#rbfnet[T&lt;:AnyRef](x:Array[T],y:Array[Double],neurons:Array[smile.base.rbf.RBF[T]],normalized:Boolean):smile.regression.RBFNetwork[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">rbfnet</span><span class="tparams">[<span name="T">T &lt;: <a href="https://www.scala-lang.org/api/2.13.11/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>]</span><span class="params">(<span name="x">x: <a href="https://www.scala-lang.org/api/2.13.11/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<span name="smile.regression.rbfnet.T" class="extype">T</span>]</span>, <span name="y">y: <a href="https://www.scala-lang.org/api/2.13.11/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]</span>, <span name="neurons">neurons: <a href="https://www.scala-lang.org/api/2.13.11/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<span name="smile.base.rbf.RBF" class="extype">RBF</span>[<span name="smile.regression.rbfnet.T" class="extype">T</span>]]</span>, <span name="normalized">normalized: <a href="https://www.scala-lang.org/api/2.13.11/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <span name="smile.regression.RBFNetwork" class="extype">RBFNetwork</span>[<span name="smile.regression.rbfnet.T" class="extype">T</span>]</span></span><p class="shortcomment cmt">Radial basis function networks.</p><div class="fullcomment"><div class="comment cmt"><p>Radial basis function networks. A radial basis function network is an
artificial neural network that uses radial basis functions as activation
functions. It is a linear combination of radial basis functions. They are
used in function approximation, time series prediction, and control.</p><p>In its basic form, radial basis function network is in the form</p><p>y(x) = &Sigma; w<sub>i</sub> &phi;(||x-c<sub>i</sub>||)</p><p>where the approximating function y(x) is represented as a sum of N radial
basis functions &phi;, each associated with a different center c<sub>i</sub>,
and weighted by an appropriate coefficient w<sub>i</sub>. For distance,
one usually chooses Euclidean distance. The weights w<sub>i</sub> can
be estimated using the matrix methods of linear least squares, because
the approximating function is linear in the weights.</p><p>The centers c<sub>i</sub> can be randomly selected from training data,
or learned by some clustering method (e.g. k-means), or learned together
with weight parameters undergo a supervised learning processing
(e.g. error-correction learning).</p><p>The popular choices for &phi; comprise the Gaussian function and the so
called thin plate splines. The advantage of the thin plate splines is that
their conditioning is invariant under scalings. Gaussian, multi-quadric
and inverse multi-quadric are infinitely smooth and and involve a scale
or shape parameter, r<sub><small>0</small></sub> &gt; 0. Decreasing
r<sub><small>0</small></sub> tends to flatten the basis function. For a
given function, the quality of approximation may strongly depend on this
parameter. In particular, increasing r<sub><small>0</small></sub> has the
effect of better conditioning (the separation distance of the scaled points
increases).</p><p>A variant on RBF networks is normalized radial basis function (NRBF)
networks, in which we require the sum of the basis functions to be unity.
NRBF arises more naturally from a Bayesian statistical perspective. However,
there is no evidence that either the NRBF method is consistently superior
to the RBF method, or vice versa.</p><p>SVMs with Gaussian kernel have similar structure as RBF networks with
Gaussian radial basis functions. However, the SVM approach "automatically"
solves the network complexity problem since the size of the hidden layer
is obtained as the result of the QP procedure. Hidden neurons and
support vectors correspond to each other, so the center problems of
the RBF network is also solved, as the support vectors serve as the
basis function centers. It was reported that with similar number of support
vectors/centers, SVM shows better generalization performance than RBF
network when the training data size is relatively small. On the other hand,
RBF network gives better generalization performance than SVM on large
training data.</p><h6>References:</h6><ul><li>Simon Haykin. Neural Networks: A Comprehensive Foundation (2nd edition). 1999.</li><li>T. Poggio and F. Girosi. Networks for approximation and learning. Proc. IEEE 78(9):1484-1487, 1990.</li><li>Nabil Benoudjit and Michel Verleysen. On the kernel widths in radial-basis function networks. Neural Process, 2003.
</li></ul></div><dl class="paramcmts block"><dt class="param">x</dt><dd class="cmt"><p>training samples.</p></dd><dt class="param">y</dt><dd class="cmt"><p>response variable.</p></dd><dt class="param">neurons</dt><dd class="cmt"><p>the radial basis functions.</p></dd><dt class="param">normalized</dt><dd class="cmt"><p>train a normalized RBF network or not.</p></dd></dl></div></li><li class="indented0 " name="smile.regression#ridge" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ridge(formula:smile.data.formula.Formula,data:smile.data.DataFrame,lambda:Double):smile.regression.LinearModel" class="anchorToMember"></a><a id="ridge(Formula,DataFrame,Double):LinearModel" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/regression/index.html#ridge(formula:smile.data.formula.Formula,data:smile.data.DataFrame,lambda:Double):smile.regression.LinearModel" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ridge</span><span class="params">(<span name="formula">formula: <span name="smile.data.formula.Formula" class="extype">Formula</span></span>, <span name="data">data: <span name="smile.data.DataFrame" class="extype">DataFrame</span></span>, <span name="lambda">lambda: <a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a></span>)</span><span class="result">: <span name="smile.regression.LinearModel" class="extype">LinearModel</span></span></span><p class="shortcomment cmt">Ridge Regression.</p><div class="fullcomment"><div class="comment cmt"><p>Ridge Regression. When the predictor variables are highly correlated amongst
themselves, the coefficients of the resulting least squares fit may be very
imprecise. By allowing a small amount of bias in the estimates, more
reasonable coefficients may often be obtained. Ridge regression is one
method to address these issues. Often, small amounts of bias lead to
dramatic reductions in the variance of the estimated model coefficients.
Ridge regression is such a technique which shrinks the regression
coefficients by imposing a penalty on their size. Ridge regression was
originally developed to overcome the singularity of the X'X matrix.
This matrix is perturbed so as to make its determinant appreciably
different from 0.</p><p>Ridge regression is a kind of Tikhonov regularization, which is the most
commonly used method of regularization of ill-posed problems. Another
interpretation of ridge regression is available through Bayesian estimation.
In this setting the belief that weight should be small is coded into a prior
distribution.
</p></div><dl class="paramcmts block"><dt class="param">formula</dt><dd class="cmt"><p>a symbolic description of the model to be fitted.</p></dd><dt class="param">data</dt><dd class="cmt"><p>the data frame of the explanatory and response variables.</p></dd><dt class="param">lambda</dt><dd class="cmt"><p>the shrinkage/regularization parameter.</p></dd></dl></div></li><li class="indented0 " name="smile.regression#svm" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="svm[T&lt;:AnyRef](x:Array[T],y:Array[Double],kernel:smile.math.kernel.MercerKernel[T],eps:Double,C:Double,tol:Double):smile.regression.KernelMachine[T]" class="anchorToMember"></a><a id="svm[T&lt;:AnyRef](Array[T],Array[Double],MercerKernel[T],Double,Double,Double):KernelMachine[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/regression/index.html#svm[T&lt;:AnyRef](x:Array[T],y:Array[Double],kernel:smile.math.kernel.MercerKernel[T],eps:Double,C:Double,tol:Double):smile.regression.KernelMachine[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">svm</span><span class="tparams">[<span name="T">T &lt;: <a href="https://www.scala-lang.org/api/2.13.11/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>]</span><span class="params">(<span name="x">x: <a href="https://www.scala-lang.org/api/2.13.11/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<span name="smile.regression.svm.T" class="extype">T</span>]</span>, <span name="y">y: <a href="https://www.scala-lang.org/api/2.13.11/scala/Array.html#scala.Array" name="scala.Array" id="scala.Array" class="extype">Array</a>[<a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a>]</span>, <span name="kernel">kernel: <span name="smile.math.kernel.MercerKernel" class="extype">MercerKernel</span>[<span name="smile.regression.svm.T" class="extype">T</span>]</span>, <span name="eps">eps: <a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a></span>, <span name="C">C: <a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a></span>, <span name="tol">tol: <a href="https://www.scala-lang.org/api/2.13.11/scala/Double.html#scala.Double" name="scala.Double" id="scala.Double" class="extype">Double</a> = <span class="symbol">1E-3</span></span>)</span><span class="result">: <span name="smile.regression.KernelMachine" class="extype">KernelMachine</span>[<span name="smile.regression.svm.T" class="extype">T</span>]</span></span><p class="shortcomment cmt">Support vector regression.</p><div class="fullcomment"><div class="comment cmt"><p>Support vector regression. Like SVM for classification, the model produced
by SVR depends only on a subset of the training data, because the cost
function ignores any training data close to the model prediction (within
a threshold).
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the data type</p></dd><dt class="param">x</dt><dd class="cmt"><p>training data.</p></dd><dt class="param">y</dt><dd class="cmt"><p>response variable.</p></dd><dt class="param">kernel</dt><dd class="cmt"><p>the kernel function.</p></dd><dt class="param">eps</dt><dd class="cmt"><p>the loss function error threshold.</p></dd><dt class="param">C</dt><dd class="cmt"><p>the soft margin penalty parameter.</p></dd><dt class="param">tol</dt><dd class="cmt"><p>the tolerance of convergence test.</p></dd><dt>returns</dt><dd class="cmt"><p>SVR model.</p></dd></dl></div></li><li class="indented0 " name="smile.regression.gpr" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="gpr" class="anchorToMember"></a><a id="gpr:gpr" class="anchorToMember"></a> <span class="permalink"><a href="../../smile/regression/package$$gpr$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="package$$gpr$.html" title="Gaussian Process for Regression."><span class="name">gpr</span></a></span><p class="shortcomment cmt">Gaussian Process for Regression.</p></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.11/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.11/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
