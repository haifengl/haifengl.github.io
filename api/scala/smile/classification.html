<!DOCTYPE html><html data-pathToRoot="../" data-rawLocation="smile/classification" data-dynamicSideMenu="true"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>smile.classification</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/apistyles.css"></link><script>var pathToRoot = "../";</script></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../" class="logo-container"><span id="project-logo" class="project-logo"><img src="../project-logo/smile.jpg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/smile.jpg"></img></span><span class="project-name h300">Smile - Scala</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">4.2.0</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="../project-logo/smile.jpg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/smile.jpg"></img></span><span class="project-name h300">Smile - Scala</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><div class="text">Copyright © 2010-2025 Haifeng Li. All rights reserved.
<script async src="https://www.googletagmanager.com/gtag/js?id=G-57GD08QCML"></script>
<script type="text/javascript" src="/api/java/script-dir/gtag.js"></script>
Use is subject to license terms.</div></div><div class="text-mobile">Copyright © 2010-2025 Haifeng Li. All rights reserved.
Use is subject to license terms.</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">Smile - Scala</a>/<a href="../smile.html">smile</a>/<a href="classification.html">smile.classification</a></div><div id="content" class="body-medium"><div><div class="cover-header">
 <span class="icon"><span class="micon pa"></span></span>
 <h1 class="h600 single">smile.classification</h1>
</div>
<div class="fqname body-large">
 <span></span>
</div>
<div class="main-signature mono-small-block">
 <div class="signature">
  <span class="modifiers"></span><span class="kind"><span t="k">package </span></span><a href="classification.html" t="n" class="documentableName ">smile.classification</a>
 </div>
</div>
<div class="cover">
 <div class="doc">
  <p>Classification algorithms. In machine learning and pattern recognition, classification refers to an algorithmic procedure for assigning a given input object into one of a given number of categories. The input object is formally termed an instance, and the categories are termed classes.</p>
  <p>The instance is usually described by a vector of features, which together constitute a description of all known characteristics of the instance. Typically, features are either categorical (also known as nominal, i.e. consisting of one of a set of unordered items, such as a gender of "male" or "female", or a blood type of "A", "B", "AB" or "O"), ordinal (consisting of one of a set of ordered items, e.g. "large", "medium" or "small"), integer-valued (e.g. a count of the number of occurrences of a particular word in an email) or real-valued (e.g. a measurement of blood pressure).</p>
  <p>Classification normally refers to a supervised procedure, i.e. a procedure that produces an inferred function to predict the output value of new instances based on a training set of pairs consisting of an input object and a desired output value. The inferred function is called a classifier if the output is discrete or a regression function if the output is continuous.</p>
  <p>The inferred function should predict the correct output value for any valid input object. This requires the learning algorithm to generalize from the training data to unseen situations in a "reasonable" way.</p>
  <p>A wide range of supervised learning algorithms is available, each with its strengths and weaknesses. There is no single learning algorithm that works best on all supervised learning problems. The most widely used learning algorithms are AdaBoost and gradient boosting, support vector machines, linear regression, linear discriminant analysis, logistic regression, naive Bayes, decision trees, k-nearest neighbor algorithm, and neural networks (multilayer perceptron).</p>
  <p>If the feature vectors include features of many different kinds (discrete, discrete ordered, counts, continuous values), some algorithms cannot be easily applied. Many algorithms, including linear regression, logistic regression, neural networks, and nearest neighbor methods, require that the input features be numerical and scaled to similar ranges (e.g., to the [-1,1] interval). Methods that employ a distance function, such as nearest neighbor methods and support vector machines with Gaussian kernels, are particularly sensitive to this. An advantage of decision trees (and boosting algorithms based on decision trees) is that they easily handle heterogeneous data.</p>
  <p>If the input features contain redundant information (e.g., highly correlated features), some learning algorithms (e.g., linear regression, logistic regression, and distance based methods) will perform poorly because of numerical instabilities. These problems can often be solved by imposing some form of regularization.</p>
  <p>If each of the features makes an independent contribution to the output, then algorithms based on linear functions (e.g., linear regression, logistic regression, linear support vector machines, naive Bayes) generally perform well. However, if there are complex interactions among features, then algorithms such as nonlinear support vector machines, decision trees and neural networks work better. Linear methods can also be applied, but the engineer must manually specify the interactions when using them.</p>
  <p>There are several major issues to consider in supervised learning:</p>
  <ul>
   <li>
    <p>'''Features:''' The accuracy of the inferred function depends strongly on how the input object is represented. Typically, the input object is transformed into a feature vector, which contains a number of features that are descriptive of the object. The number of features should not be too large, because of the curse of dimensionality; but should contain enough information to accurately predict the output. There are many algorithms for feature selection that seek to identify the relevant features and discard the irrelevant ones. More generally, dimensionality reduction may seek to map the input data into a lower dimensional space prior to running the supervised learning algorithm.</p></li>
   <li>
    <p>'''Overfitting:''' Overfitting occurs when a statistical model describes random error or noise instead of the underlying relationship. Overfitting generally occurs when a model is excessively complex, such as having too many parameters relative to the number of observations. A model which has been overfit will generally have poor predictive performance, as it can exaggerate minor fluctuations in the data. The potential for overfitting depends not only on the number of parameters and data but also the conformability of the model structure with the data shape, and the magnitude of model error compared to the expected level of noise or error in the data. In order to avoid overfitting, it is necessary to use additional techniques (e.g. cross-validation, regularization, early stopping, pruning, Bayesian priors on parameters or model comparison), that can indicate when further training is not resulting in better generalization. The basis of some techniques is either (1) to explicitly penalize overly complex models, or (2) to test the model's ability to generalize by evaluating its performance on a set of data not used for training, which is assumed to approximate the typical unseen data that a model will encounter.</p></li>
   <li>
    <p>'''Regularization:''' Regularization involves introducing additional information in order to solve an ill-posed problem or to prevent over-fitting. This information is usually of the form of a penalty for complexity, such as restrictions for smoothness or bounds on the vector space norm. A theoretical justification for regularization is that it attempts to impose Occam's razor on the solution. From a Bayesian point of view, many regularization techniques correspond to imposing certain prior distributions on model parameters.</p></li>
   <li>
    <p>'''Bias-variance tradeoff:''' Mean squared error (MSE) can be broken down into two components: variance and squared bias, known as the bias-variance decomposition. Thus in order to minimize the MSE, we need to minimize both the bias and the variance. However, this is not trivial. Therefore, there is a tradeoff between bias and variance.</p></li>
  </ul>
 </div>
 <section id="attributes">
  <h2 class="h500">Attributes</h2>
  <dl class="attributes"></dl>
 </section>
</div>
<section id="members-list">
 <h2 class="h500">Members list</h2>
 <div class="documentableFilter">
  <div class="filtersContainer"></div><input class="filterableInput" placeholder="Filter by any phrase" data-test-id="filterBarInput" type="search"><button class="clearButton label-only-button" data-test-id="filterBarClearButton">Clear all</button>
 </div>
 <div class="membersList expand">
  <div class="tabs">
   <div class="contents">
    <section id="Type-members">
     <div data-togglable="Type members" class="tab expand">
      <div class="member-group-header">
       <h3 data-togglable="Type members" class="h400">Type members</h3>
      </div>
      <section id="Classlikes">
       <div class="documentableList expand">
        <div class="documentableList-expander">
         <button class="icon-button show-content expand"></button>
         <h4 class="groupHeader h200">Classlikes</h4>
        </div>
        <div class="documentableElement">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">object </span></span><a href="classification/$dummy$.html" t="n" class="documentableName ">$dummy</a>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Hacking scaladoc <a href="https://github.com/scala/bug/issues/8124">issue-8124</a>. The user should ignore this object.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Hacking scaladoc <a href="https://github.com/scala/bug/issues/8124">issue-8124</a>. The user should ignore this object.</p>
             </div>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Supertypes
              </dt>
              <dd class="body-medium">
               <div class="mono-small-block supertypes">
                <div>
                 class <span data-unresolved-link="" t="n">Object</span>
                </div>
                <div>
                 trait <span data-unresolved-link="" t="n">Matchable</span>
                </div>
                <div>
                 class <span data-unresolved-link="" t="n">Any</span>
                </div><span></span>
               </div>
              </dd>
              <dt class="body-small">
               Self type
              </dt>
              <dd class="body-medium">
               <div class="mono-small-block supertypes">
                <span></span>
                <div>
                 <a href="classification/$dummy$.html" t="n">$dummy</a>.<span t="k">type</span>
                </div>
               </div>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
       </div>
      </section>
     </div>
    </section>
    <section id="Value-members">
     <div data-togglable="Value members" class="tab expand">
      <div class="member-group-header">
       <h3 data-togglable="Value members" class="h400">Value members</h3>
      </div>
      <section id="Concrete-methods">
       <div class="documentableList expand">
        <div class="documentableList-expander">
         <button class="icon-button show-content expand"></button>
         <h4 class="groupHeader h200">Concrete methods</h4>
        </div>
        <div class="documentableElement" id="adaboost-702">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#adaboost-702" t="n" class="documentableName ">adaboost</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">formula</span>: <span data-unresolved-link="" t="t">Formula</span>, <span t="k"></span><span data-unresolved-link="" t="n">data</span>: <span data-unresolved-link="" t="t">DataFrame</span>, <span t="k"></span><span data-unresolved-link="" t="n">ntrees</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxDepth</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxNodes</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">nodeSize</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>): <span data-unresolved-link="" t="t">AdaBoost</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>AdaBoost (Adaptive Boosting) classifier with decision trees. In principle, AdaBoost is a meta-algorithm, and can be used in conjunction with many other learning algorithms to improve their performance. In practice, AdaBoost with decision trees is probably the most popular combination. AdaBoost is adaptive in the sense that subsequent classifiers built are tweaked in favor of those instances misclassified by previous classifiers. AdaBoost is sensitive to noisy data and outliers. However, in some problems it can be less susceptible to the over-fitting problem than most learning algorithms.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>AdaBoost (Adaptive Boosting) classifier with decision trees. In principle, AdaBoost is a meta-algorithm, and can be used in conjunction with many other learning algorithms to improve their performance. In practice, AdaBoost with decision trees is probably the most popular combination. AdaBoost is adaptive in the sense that subsequent classifiers built are tweaked in favor of those instances misclassified by previous classifiers. AdaBoost is sensitive to noisy data and outliers. However, in some problems it can be less susceptible to the over-fitting problem than most learning algorithms.</p>
              <p>AdaBoost calls a weak classifier repeatedly in a series of rounds from total T classifiers. For each call a distribution of weights is updated that indicates the importance of examples in the data set for the classification. On each round, the weights of each incorrectly classified example are increased (or alternatively, the weights of each correctly classified example are decreased), so that the new classifier focuses more on those examples.</p>
              <p>The basic AdaBoost algorithm is only for binary classification problem. For multi-class classification, a common approach is reducing the multi-class classification problem to multiple two-class problems. This implementation is a multi-class AdaBoost without such reductions.</p>
              <p>====References:====</p>
              <ul>
               <li>Yoav Freund, Robert E. Schapire. A Decision-Theoretic Generalization of on-Line Learning and an Application to Boosting, 1995.</li>
               <li>Ji Zhu, Hui Zhou, Saharon Rosset and Trevor Hastie. Multi-class Adaboost, 2009.</li>
              </ul>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               data
              </dt>
              <dd class="body-medium">
               <p>the data frame of the explanatory and response variables.</p>
              </dd>
              <dt class="body-small">
               formula
              </dt>
              <dd class="body-medium">
               <p>a symbolic description of the model to be fitted.</p>
              </dd>
              <dt class="body-small">
               maxDepth
              </dt>
              <dd class="body-medium">
               <p>the maximum depth of the tree.</p>
              </dd>
              <dt class="body-small">
               maxNodes
              </dt>
              <dd class="body-medium">
               <p>the maximum number of leaf nodes in the tree.</p>
              </dd>
              <dt class="body-small">
               nodeSize
              </dt>
              <dd class="body-medium">
               <p>the minimum size of leaf nodes.</p>
              </dd>
              <dt class="body-small">
               ntrees
              </dt>
              <dd class="body-medium">
               <p>the number of trees.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>AdaBoost model.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="cart-bef">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#cart-bef" t="n" class="documentableName ">cart</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">formula</span>: <span data-unresolved-link="" t="t">Formula</span>, <span t="k"></span><span data-unresolved-link="" t="n">data</span>: <span data-unresolved-link="" t="t">DataFrame</span>, <span t="k"></span><span data-unresolved-link="" t="n">splitRule</span>: <span data-unresolved-link="" t="t">SplitRule</span>, <span t="k"></span><span data-unresolved-link="" t="n">maxDepth</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxNodes</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">nodeSize</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>): <span data-unresolved-link="" t="t">DecisionTree</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Decision tree. A classification/regression tree can be learned by splitting the training set into subsets based on an attribute value test. This process is repeated on each derived subset in a recursive manner called recursive partitioning. The recursion is completed when the subset at a node all has the same value of the target variable, or when splitting no longer adds value to the predictions.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Decision tree. A classification/regression tree can be learned by splitting the training set into subsets based on an attribute value test. This process is repeated on each derived subset in a recursive manner called recursive partitioning. The recursion is completed when the subset at a node all has the same value of the target variable, or when splitting no longer adds value to the predictions.</p>
              <p>The algorithms that are used for constructing decision trees usually work top-down by choosing a variable at each step that is the next best variable to use in splitting the set of items. "Best" is defined by how well the variable splits the set into homogeneous subsets that have the same value of the target variable. Different algorithms use different formulae for measuring "best". Used by the CART algorithm, Gini impurity is a measure of how often a randomly chosen element from the set would be incorrectly labeled if it were randomly labeled according to the distribution of labels in the subset. Gini impurity can be computed by summing the probability of each item being chosen times the probability of a mistake in categorizing that item. It reaches its minimum (zero) when all cases in the node fall into a single target category. Information gain is another popular measure, used by the ID3, C4.5 and C5.0 algorithms. Information gain is based on the concept of entropy used in information theory. For categorical variables with different number of levels, however, information gain are biased in favor of those attributes with more levels. Instead, one may employ the information gain ratio, which solves the drawback of information gain.</p>
              <p>Classification and Regression Tree techniques have a number of advantages over many of those alternative techniques.</p>
              <ul>
               <li>'''Simple to understand and interpret:''' In most cases, the interpretation of results summarized in a tree is very simple. This simplicity is useful not only for purposes of rapid classification of new observations, but can also often yield a much simpler "model" for explaining why observations are classified or predicted in a particular manner.</li>
               <li>'''Able to handle both numerical and categorical data:''' Other techniques are usually specialized in analyzing datasets that have only one type of variable.</li>
               <li>'''Nonparametric and nonlinear:''' The final results of using tree methods for classification or regression can be summarized in a series of (usually few) logical if-then conditions (tree nodes). Therefore, there is no implicit assumption that the underlying relationships between the predictor variables and the dependent variable are linear, follow some specific non-linear link function, or that they are even monotonic in nature. Thus, tree methods are particularly well suited for data mining tasks, where there is often little a priori knowledge nor any coherent set of theories or predictions regarding which variables are related and how. In those types of data analytics, tree methods can often reveal simple relationships between just a few variables that could have easily gone unnoticed using other analytic techniques.</li>
              </ul>
              <p>One major problem with classification and regression trees is their high variance. Often a small change in the data can result in a very different series of splits, making interpretation somewhat precarious. Besides, decision-tree learners can create over-complex trees that cause over-fitting. Mechanisms such as pruning are necessary to avoid this problem. Another limitation of trees is the lack of smoothness of the prediction surface.</p>
              <p>Some techniques such as bagging, boosting, and random forest use more than one decision tree for their analysis.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               data
              </dt>
              <dd class="body-medium">
               <p>the data frame of the explanatory and response variables.</p>
              </dd>
              <dt class="body-small">
               formula
              </dt>
              <dd class="body-medium">
               <p>a symbolic description of the model to be fitted.</p>
              </dd>
              <dt class="body-small">
               maxDepth
              </dt>
              <dd class="body-medium">
               <p>the maximum depth of the tree.</p>
              </dd>
              <dt class="body-small">
               maxNodes
              </dt>
              <dd class="body-medium">
               <p>the maximum number of leaf nodes in the tree.</p>
              </dd>
              <dt class="body-small">
               nodeSize
              </dt>
              <dd class="body-medium">
               <p>the minimum size of leaf nodes.</p>
              </dd>
              <dt class="body-small">
               splitRule
              </dt>
              <dd class="body-medium">
               <p>the splitting rule.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>Decision tree model.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="fisher-fffff750">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#fisher-fffff750" t="n" class="documentableName ">fisher</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>]], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">L</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">tol</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>): <span data-unresolved-link="" t="t">FLD</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Fisher's linear discriminant. Fisher defined the separation between two distributions to be the ratio of the variance between the classes to the variance within the classes, which is, in some sense, a measure of the signal-to-noise ratio for the class labeling. FLD finds a linear combination of features which maximizes the separation after the projection. The resulting combination may be used for dimensionality reduction before later classification.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Fisher's linear discriminant. Fisher defined the separation between two distributions to be the ratio of the variance between the classes to the variance within the classes, which is, in some sense, a measure of the signal-to-noise ratio for the class labeling. FLD finds a linear combination of features which maximizes the separation after the projection. The resulting combination may be used for dimensionality reduction before later classification.</p>
              <p>The terms Fisher's linear discriminant and LDA are often used interchangeably, although FLD actually describes a slightly different discriminant, which does not make some of the assumptions of LDA such as normally distributed classes or equal class covariances. When the assumptions of LDA are satisfied, FLD is equivalent to LDA.</p>
              <p>FLD is also closely related to principal component analysis (PCA), which also looks for linear combinations of variables which best explain the data. As a supervised method, FLD explicitly attempts to model the difference between the classes of data. On the other hand, PCA is a unsupervised method and does not take into account any difference in class.</p>
              <p>One complication in applying FLD (and LDA) to real data occurs when the number of variables/features does not exceed the number of samples. In this case, the covariance estimates do not have full rank, and so cannot be inverted. This is known as small sample size problem.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               L
              </dt>
              <dd class="body-medium">
               <p>the dimensionality of mapped space. The default value is the number of classes - 1.</p>
              </dd>
              <dt class="body-small">
               tol
              </dt>
              <dd class="body-medium">
               <p>a tolerance to decide if a covariance matrix is singular; it will reject variables whose variance is less than tol<sup>2</sup>.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training instances.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>training labels in [0, k), where k is the number of classes.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>fisher discriminant analysis model.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="gbm-fffff1ca">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#gbm-fffff1ca" t="n" class="documentableName ">gbm</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">formula</span>: <span data-unresolved-link="" t="t">Formula</span>, <span t="k"></span><span data-unresolved-link="" t="n">data</span>: <span data-unresolved-link="" t="t">DataFrame</span>, <span t="k"></span><span data-unresolved-link="" t="n">ntrees</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxDepth</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxNodes</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">nodeSize</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">shrinkage</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">subsample</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>): <span data-unresolved-link="" t="t">GradientTreeBoost</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Gradient boosted classification trees.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Gradient boosted classification trees.</p>
              <p>Generic gradient boosting at the t-th step would fit a regression tree to pseudo-residuals. Let J be the number of its leaves. The tree partitions the input space into J disjoint regions and predicts a constant value in each region. The parameter J controls the maximum allowed level of interaction between variables in the model. With J = 2 (decision stumps), no interaction between variables is allowed. With J = 3 the model may include effects of the interaction between up to two variables, and so on. Hastie et al. comment that typically 4 ≤ J ≤ 8 work well for boosting and results are fairly insensitive to the choice of in this range, J = 2 is insufficient for many applications, and J &gt; 10 is unlikely to be required.</p>
              <p>Fitting the training set too closely can lead to degradation of the model's generalization ability. Several so-called regularization techniques reduce this over-fitting effect by constraining the fitting procedure. One natural regularization parameter is the number of gradient boosting iterations T (i.e. the number of trees in the model when the base learner is a decision tree). Increasing T reduces the error on training set, but setting it too high may lead to over-fitting. An optimal value of T is often selected by monitoring prediction error on a separate validation data set.</p>
              <p>Another regularization approach is the shrinkage which times a parameter η (called the "learning rate") to update term. Empirically it has been found that using small learning rates (such as η &lt; 0.1) yields dramatic improvements in model's generalization ability over gradient boosting without shrinking (η = 1). However, it comes at the price of increasing computational time both during training and prediction: lower learning rate requires more iterations.</p>
              <p>Soon after the introduction of gradient boosting Friedman proposed a minor modification to the algorithm, motivated by Breiman's bagging method. Specifically, he proposed that at each iteration of the algorithm, a base learner should be fit on a subsample of the training set drawn at random without replacement. Friedman observed a substantial improvement in gradient boosting's accuracy with this modification.</p>
              <p>Subsample size is some constant fraction f of the size of the training set. When f = 1, the algorithm is deterministic and identical to the one described above. Smaller values of f introduce randomness into the algorithm and help prevent over-fitting, acting as a kind of regularization. The algorithm also becomes faster, because regression trees have to be fit to smaller datasets at each iteration. Typically, f is set to 0.5, meaning that one half of the training set is used to build each base learner.</p>
              <p>Also, like in bagging, sub-sampling allows one to define an out-of-bag estimate of the prediction performance improvement by evaluating predictions on those observations which were not used in the building of the next base learner. Out-of-bag estimates help avoid the need for an independent validation dataset, but often underestimate actual performance improvement and the optimal number of iterations.</p>
              <p>Gradient tree boosting implementations often also use regularization by limiting the minimum number of observations in trees' terminal nodes. It's used in the tree building process by ignoring any splits that lead to nodes containing fewer than this number of training set instances. Imposing this limit helps to reduce variance in predictions at leaves.</p>
              <p>====References:====</p>
              <ul>
               <li>J. H. Friedman. Greedy Function Approximation: A Gradient Boosting Machine, 1999.</li>
               <li>J. H. Friedman. Stochastic Gradient Boosting, 1999.</li>
              </ul>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               data
              </dt>
              <dd class="body-medium">
               <p>the data frame of the explanatory and response variables.</p>
              </dd>
              <dt class="body-small">
               formula
              </dt>
              <dd class="body-medium">
               <p>a symbolic description of the model to be fitted.</p>
              </dd>
              <dt class="body-small">
               maxDepth
              </dt>
              <dd class="body-medium">
               <p>the maximum depth of the tree.</p>
              </dd>
              <dt class="body-small">
               maxNodes
              </dt>
              <dd class="body-medium">
               <p>the maximum number of leaf nodes in the tree.</p>
              </dd>
              <dt class="body-small">
               nodeSize
              </dt>
              <dd class="body-medium">
               <p>the minimum size of leaf nodes.</p>
              </dd>
              <dt class="body-small">
               ntrees
              </dt>
              <dd class="body-medium">
               <p>the number of iterations (trees).</p>
              </dd>
              <dt class="body-small">
               shrinkage
              </dt>
              <dd class="body-medium">
               <p>the shrinkage parameter in (0, 1] controls the learning rate of procedure.</p>
              </dd>
              <dt class="body-small">
               subsample
              </dt>
              <dd class="body-medium">
               <p>the sampling fraction for stochastic tree boosting.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>Gradient boosted trees.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="knn-215">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#knn-215" t="n" class="documentableName ">knn</a>[<span t="k"></span><span data-unresolved-link="" t="t">T</span><span t="k"> &lt;: </span><span data-unresolved-link="" t="t">AnyRef</span>](<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <span data-unresolved-link="" t="t">KNNSearch</span>[<span t="t">T</span>, <span t="t">T</span>], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">k</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>): <span data-unresolved-link="" t="t">KNN</span>[<span data-unresolved-link="" t="t">T</span>]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>K-nearest neighbor classifier. The k-nearest neighbor algorithm (k-NN) is a method for classifying objects by a majority vote of its neighbors, with the object being assigned to the class most common amongst its k nearest neighbors (k is a positive integer, typically small). k-NN is a type of instance-based learning, or lazy learning where the function is only approximated locally and all computation is deferred until classification.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>K-nearest neighbor classifier. The k-nearest neighbor algorithm (k-NN) is a method for classifying objects by a majority vote of its neighbors, with the object being assigned to the class most common amongst its k nearest neighbors (k is a positive integer, typically small). k-NN is a type of instance-based learning, or lazy learning where the function is only approximated locally and all computation is deferred until classification.</p>
              <p>The best choice of k depends upon the data; generally, larger values of k reduce the effect of noise on the classification, but make boundaries between classes less distinct. A good k can be selected by various heuristic techniques, e.g. cross-validation. In binary problems, it is helpful to choose k to be an odd number as this avoids tied votes.</p>
              <p>A drawback to the basic majority voting classification is that the classes with the more frequent instances tend to dominate the prediction of the new object, as they tend to come up in the k nearest neighbors when the neighbors are computed due to their large number. One way to overcome this problem is to weight the classification taking into account the distance from the test point to each of its k nearest neighbors.</p>
              <p>Often, the classification accuracy of k-NN can be improved significantly if the distance metric is learned with specialized algorithms such as Large Margin Nearest Neighbor or Neighborhood Components Analysis.</p>
              <p>Nearest neighbor rules in effect compute the decision boundary in an implicit manner. It is also possible to compute the decision boundary itself explicitly, and to do so in an efficient manner so that the computational complexity is a function of the boundary complexity.</p>
              <p>The nearest neighbor algorithm has some strong consistency results. As the amount of data approaches infinity, the algorithm is guaranteed to yield an error rate no worse than twice the Bayes error rate (the minimum achievable error rate given the distribution of the data). k-NN is guaranteed to approach the Bayes error rate, for some value of k (where k increases as a function of the number of data points).</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               k
              </dt>
              <dd class="body-medium">
               <p>the number of neighbors for classification.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>k-nearest neighbor search data structure of training instances.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>training labels in [0, c), where c is the number of classes.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="knn-ffffffbb">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#knn-ffffffbb" t="n" class="documentableName ">knn</a>[<span t="k"></span><span data-unresolved-link="" t="t">T</span><span t="k"> &lt;: </span><span data-unresolved-link="" t="t">AnyRef</span>](<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<span t="t">T</span>], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">k</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">distance</span>: <span data-unresolved-link="" t="t">Distance</span>[<span t="t">T</span>]): <span data-unresolved-link="" t="t">KNN</span>[<span data-unresolved-link="" t="t">T</span>]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>K-nearest neighbor classifier.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>K-nearest neighbor classifier.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               distance
              </dt>
              <dd class="body-medium">
               <p>the distance measure for finding nearest neighbors.</p>
              </dd>
              <dt class="body-small">
               k
              </dt>
              <dd class="body-medium">
               <p>the number of neighbors for classification.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training samples.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>training labels in [0, c), where c is the number of classes.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="knn-fffffc44">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#knn-fffffc44" t="n" class="documentableName ">knn</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>]], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">k</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>): <span data-unresolved-link="" t="t">KNN</span>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>]]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>K-nearest neighbor classifier with Euclidean distance as the similarity measure.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>K-nearest neighbor classifier with Euclidean distance as the similarity measure.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               k
              </dt>
              <dd class="body-medium">
               <p>the number of neighbors for classification.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training samples.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>training labels in [0, c), where c is the number of classes.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="lda-a87">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#lda-a87" t="n" class="documentableName ">lda</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>]], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">priori</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>], <span t="k"></span><span data-unresolved-link="" t="n">tol</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>): <span data-unresolved-link="" t="t">LDA</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Linear discriminant analysis. LDA is based on the Bayes decision theory and assumes that the conditional probability density functions are normally distributed. LDA also makes the simplifying homoscedastic assumption (i.e. that the class covariances are identical) and that the covariances have full rank. With these assumptions, the discriminant function of an input being in a class is purely a function of this linear combination of independent variables.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Linear discriminant analysis. LDA is based on the Bayes decision theory and assumes that the conditional probability density functions are normally distributed. LDA also makes the simplifying homoscedastic assumption (i.e. that the class covariances are identical) and that the covariances have full rank. With these assumptions, the discriminant function of an input being in a class is purely a function of this linear combination of independent variables.</p>
              <p>LDA is closely related to ANOVA (analysis of variance) and linear regression analysis, which also attempt to express one dependent variable as a linear combination of other features or measurements. In the other two methods, however, the dependent variable is a numerical quantity, while for LDA it is a categorical variable (i.e. the class label). Logistic regression and probit regression are more similar to LDA, as they also explain a categorical variable. These other methods are preferable in applications where it is not reasonable to assume that the independent variables are normally distributed, which is a fundamental assumption of the LDA method.</p>
              <p>One complication in applying LDA (and Fisher's discriminant) to real data occurs when the number of variables/features does not exceed the number of samples. In this case, the covariance estimates do not have full rank, and so cannot be inverted. This is known as small sample size problem.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               priori
              </dt>
              <dd class="body-medium">
               <p>the priori probability of each class. If null, it will be estimated from the training data.</p>
              </dd>
              <dt class="body-small">
               tol
              </dt>
              <dd class="body-medium">
               <p>a tolerance to decide if a covariance matrix is singular; it will reject variables whose variance is less than tol<sup>2</sup>.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training samples.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>training labels in [0, k), where k is the number of classes.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>linear discriminant analysis model.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="logit-fffffe7a">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#logit-fffffe7a" t="n" class="documentableName ">logit</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>]], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">lambda</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">tol</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxIter</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>): <span data-unresolved-link="" t="t">LogisticRegression</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Logistic regression. Logistic regression (logit model) is a generalized linear model used for binomial regression. Logistic regression applies maximum likelihood estimation after transforming the dependent into a logit variable. A logit is the natural log of the odds of the dependent equaling a certain value or not (usually 1 in binary logistic models, the highest value in multinomial models). In this way, logistic regression estimates the odds of a certain event (value) occurring.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Logistic regression. Logistic regression (logit model) is a generalized linear model used for binomial regression. Logistic regression applies maximum likelihood estimation after transforming the dependent into a logit variable. A logit is the natural log of the odds of the dependent equaling a certain value or not (usually 1 in binary logistic models, the highest value in multinomial models). In this way, logistic regression estimates the odds of a certain event (value) occurring.</p>
              <p>Goodness-of-fit tests such as the likelihood ratio test are available as indicators of model appropriateness, as is the Wald statistic to test the significance of individual independent variables.</p>
              <p>Logistic regression has many analogies to ordinary least squares (OLS) regression. Unlike OLS regression, however, logistic regression does not assume linearity of relationship between the raw values of the independent variables and the dependent, does not require normally distributed variables, does not assume homoscedasticity, and in general has less stringent requirements.</p>
              <p>Compared with linear discriminant analysis, logistic regression has several advantages:</p>
              <ul>
               <li>
                <p>It is more robust: the independent variables don't have to be normally distributed, or have equal variance in each group</p></li>
               <li>
                <p>It does not assume a linear relationship between the independent variables and dependent variable.</p></li>
               <li>
                <p>It may handle nonlinear effects since one can add explicit interaction and power terms.</p></li>
              </ul>
              <p>However, it requires much more data to achieve stable, meaningful results.</p>
              <p>Logistic regression also has strong connections with neural network and maximum entropy modeling. For example, binary logistic regression is equivalent to a one-layer, single-output neural network with a logistic activation function trained under log loss. Similarly, multinomial logistic regression is equivalent to a one-layer, softmax-output neural network.</p>
              <p>Logistic regression estimation also obeys the maximum entropy principle, and thus logistic regression is sometimes called "maximum entropy modeling", and the resulting classifier the "maximum entropy classifier".</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               lambda
              </dt>
              <dd class="body-medium">
               <p>λ &gt; 0 gives a "regularized" estimate of linear weights which often has superior generalization performance, especially when the dimensionality is high.</p>
              </dd>
              <dt class="body-small">
               maxIter
              </dt>
              <dd class="body-medium">
               <p>the maximum number of iterations.</p>
              </dd>
              <dt class="body-small">
               tol
              </dt>
              <dd class="body-medium">
               <p>the tolerance for stopping iterations.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training samples.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>training labels in [0, k), where k is the number of classes.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>Logistic regression model.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="maxent-25d">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#maxent-25d" t="n" class="documentableName ">maxent</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>]], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">p</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">lambda</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">tol</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxIter</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>): <span data-unresolved-link="" t="t">Maxent</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Maximum entropy classifier. Maximum entropy is a technique for learning probability distributions from data. In maximum entropy models, the observed data itself is assumed to be the testable information. Maximum entropy models don't assume anything about the probability distribution other than what have been observed and always choose the most uniform distribution subject to the observed constraints.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Maximum entropy classifier. Maximum entropy is a technique for learning probability distributions from data. In maximum entropy models, the observed data itself is assumed to be the testable information. Maximum entropy models don't assume anything about the probability distribution other than what have been observed and always choose the most uniform distribution subject to the observed constraints.</p>
              <p>Basically, maximum entropy classifier is another name of multinomial logistic regression applied to categorical independent variables, which are converted to binary dummy variables. Maximum entropy models are widely used in natural language processing. Here, we provide an implementation which assumes that binary features are stored in a sparse array, of which entries are the indices of nonzero features.</p>
              <p>====References:====</p>
              <ul>
               <li>A. L. Berger, S. D. Pietra, and V. J. D. Pietra. A maximum entropy approach to natural language processing. Computational Linguistics 22(1):39-71, 1996.</li>
              </ul>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               lambda
              </dt>
              <dd class="body-medium">
               <p>λ &gt; 0 gives a "regularized" estimate of linear weights which often has superior generalization performance, especially when the dimensionality is high.</p>
              </dd>
              <dt class="body-small">
               maxIter
              </dt>
              <dd class="body-medium">
               <p>maximum number of iterations.</p>
              </dd>
              <dt class="body-small">
               p
              </dt>
              <dd class="body-medium">
               <p>the dimension of feature space.</p>
              </dd>
              <dt class="body-small">
               tol
              </dt>
              <dd class="body-medium">
               <p>tolerance for stopping iterations.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training samples. Each sample is represented by a set of sparse binary features. The features are stored in an integer array, of which are the indices of nonzero features.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>training labels in [0, k), where k is the number of classes.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>Maximum entropy model.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="mlp-fffffa4d">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#mlp-fffffa4d" t="n" class="documentableName ">mlp</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>]], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">builders</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<span data-unresolved-link="" t="t">LayerBuilder</span>], <span t="k"></span><span data-unresolved-link="" t="n">epochs</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">learningRate</span>: <span data-unresolved-link="" t="t">TimeFunction</span>, <span t="k"></span><span data-unresolved-link="" t="n">momentum</span>: <span data-unresolved-link="" t="t">TimeFunction</span>, <span t="k"></span><span data-unresolved-link="" t="n">weightDecay</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">rho</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">epsilon</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>): <span data-unresolved-link="" t="t">MLP</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Multilayer perceptron neural network. An MLP consists of several layers of nodes, interconnected through weighted acyclic arcs from each preceding layer to the following, without lateral or feedback connections. Each node calculates a transformed weighted linear combination of its inputs (output activations from the preceding layer), with one of the weights acting as a trainable bias connected to a constant input. The transformation, called activation function, is a bounded non-decreasing (non-linear) function, such as the sigmoid functions (ranges from 0 to 1). Another popular activation function is hyperbolic tangent which is actually equivalent to the sigmoid function in shape but ranges from -1 to 1. More specialized activation functions include radial basis functions which are used in RBF networks.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Multilayer perceptron neural network. An MLP consists of several layers of nodes, interconnected through weighted acyclic arcs from each preceding layer to the following, without lateral or feedback connections. Each node calculates a transformed weighted linear combination of its inputs (output activations from the preceding layer), with one of the weights acting as a trainable bias connected to a constant input. The transformation, called activation function, is a bounded non-decreasing (non-linear) function, such as the sigmoid functions (ranges from 0 to 1). Another popular activation function is hyperbolic tangent which is actually equivalent to the sigmoid function in shape but ranges from -1 to 1. More specialized activation functions include radial basis functions which are used in RBF networks.</p>
              <p>The representational capabilities of a MLP are determined by the range of mappings it may implement through weight variation. Single layer perceptrons are capable of solving only linearly separable problems. With the sigmoid function as activation function, the single-layer network is identical to the logistic regression model.</p>
              <p>The universal approximation theorem for neural networks states that every continuous function that maps intervals of real numbers to some output interval of real numbers can be approximated arbitrarily closely by a multi-layer perceptron with just one hidden layer. This result holds only for restricted classes of activation functions, which are extremely complex and NOT smooth for subtle mathematical reasons. On the other hand, smoothness is important for gradient descent learning. Besides, the proof is not constructive regarding the number of neurons required or the settings of the weights. Therefore, complex systems will have more layers of neurons with some having increased layers of input neurons and output neurons in practice.</p>
              <p>The most popular algorithm to train MLPs is back-propagation, which is a gradient descent method. Based on chain rule, the algorithm propagates the error back through the network and adjusts the weights of each connection in order to reduce the value of the error function by some small amount. For this reason, back-propagation can only be applied on networks with differentiable activation functions.</p>
              <p>During error back propagation, we usually times the gradient with a small number η, called learning rate, which is carefully selected to ensure that the network converges to a local minimum of the error function fast enough, without producing oscillations. One way to avoid oscillation at large η, is to make the change in weight dependent on the past weight change by adding a momentum term.</p>
              <p>Although the back-propagation algorithm may perform gradient descent on the total error of all instances in a batch way, the learning rule is often applied to each instance separately in an online way or stochastic way. There exists empirical indication that the stochastic way results in faster convergence.</p>
              <p>In practice, the problem of over-fitting has emerged. This arises in convoluted or over-specified systems when the capacity of the network significantly exceeds the needed free parameters. There are two general approaches for avoiding this problem: The first is to use cross-validation and similar techniques to check for the presence of over-fitting and optimally select hyper-parameters such as to minimize the generalization error. The second is to use some form of regularization, which emerges naturally in a Bayesian framework, where the regularization can be performed by selecting a larger prior probability over simpler models; but also in statistical learning theory, where the goal is to minimize over the "empirical risk" and the "structural risk".</p>
              <p>For neural networks, the input patterns usually should be scaled/standardized. Commonly, each input variable is scaled into interval [0, 1] or to have mean 0 and standard deviation 1.</p>
              <p>For penalty functions and output units, the following natural pairings are recommended:</p>
              <ul>
               <li>linear output units and a least squares penalty function.</li>
               <li>a two-class cross-entropy penalty function and a logistic activation function.</li>
               <li>a multi-class cross-entropy penalty function and a softmax activation function.</li>
              </ul>
              <p>By assigning a softmax activation function on the output layer of the neural network for categorical target variables, the outputs can be interpreted as posterior probabilities, which are very useful.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               builders
              </dt>
              <dd class="body-medium">
               <p>the builders of layers from bottom to top.</p>
              </dd>
              <dt class="body-small">
               epochs
              </dt>
              <dd class="body-medium">
               <p>the number of epochs of stochastic learning.</p>
              </dd>
              <dt class="body-small">
               epsilon
              </dt>
              <dd class="body-medium">
               <p>A small constant for RMSProp numerical stability.</p>
              </dd>
              <dt class="body-small">
               learningRate
              </dt>
              <dd class="body-medium">
               <p>the learning rate.</p>
              </dd>
              <dt class="body-small">
               momentum
              </dt>
              <dd class="body-medium">
               <p>the momentum factor.</p>
              </dd>
              <dt class="body-small">
               rho
              </dt>
              <dd class="body-medium">
               <p>The RMSProp discounting factor for the history/coming gradient.</p>
              </dd>
              <dt class="body-small">
               weightDecay
              </dt>
              <dd class="body-medium">
               <p>the weight decay for regularization.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training samples.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>training labels in [0, k), where k is the number of classes.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="naiveBayes-fffff64b">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#naiveBayes-fffff64b" t="n" class="documentableName ">naiveBayes</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>]], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">model</span>: <span data-unresolved-link="" t="t">Model</span>, <span t="k"></span><span data-unresolved-link="" t="n">priori</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>], <span t="k"></span><span data-unresolved-link="" t="n">sigma</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>): <span data-unresolved-link="" t="t">DiscreteNaiveBayes</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Creates a naive Bayes classifier for document classification. Add-k smoothing.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Creates a naive Bayes classifier for document classification. Add-k smoothing.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               model
              </dt>
              <dd class="body-medium">
               <p>the generation model of naive Bayes classifier.</p>
              </dd>
              <dt class="body-small">
               priori
              </dt>
              <dd class="body-medium">
               <p>the priori probability of each class. If null, equal probability is assumed for each class.</p>
              </dd>
              <dt class="body-small">
               sigma
              </dt>
              <dd class="body-medium">
               <p>the prior count of add-k smoothing of evidence.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training samples.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>training labels in [0, k), where k is the number of classes.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="naiveBayes-fffff44c">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#naiveBayes-fffff44c" t="n" class="documentableName ">naiveBayes</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">priori</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>], <span t="k"></span><span data-unresolved-link="" t="n">condprob</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<span data-unresolved-link="" t="t">Distribution</span>]]): <span data-unresolved-link="" t="t">NaiveBayes</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Creates a general naive Bayes classifier.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Creates a general naive Bayes classifier.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               condprob
              </dt>
              <dd class="body-medium">
               <p>the conditional distribution of each variable in each class. In particular, condprob[i][j] is the conditional distribution P(x<sub>j</sub> | class i).</p>
              </dd>
              <dt class="body-small">
               priori
              </dt>
              <dd class="body-medium">
               <p>the priori probability of each class.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="ovo-fffff5c5">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#ovo-fffff5c5" t="n" class="documentableName ">ovo</a>[<span t="k"></span><span data-unresolved-link="" t="t">T</span><span t="k"> &lt;: </span><span data-unresolved-link="" t="t">AnyRef</span>](<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<span t="t">T</span>], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>])(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">trainer</span>: (<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<span t="t">T</span>], <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>])<span t="k"> =&gt; </span><span data-unresolved-link="" t="t">Classifier</span>[<span t="t">T</span>]): <span data-unresolved-link="" t="t">OneVersusOne</span>[<span data-unresolved-link="" t="t">T</span>]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>One-vs-one strategy for reducing the problem of multiclass classification to multiple binary classification problems. This approach trains K (K − 1) / 2 binary classifiers for a K-way multiclass problem; each receives the samples of a pair of classes from the original training set, and must learn to distinguish these two classes. At prediction time, a voting scheme is applied: all K (K − 1) / 2 classifiers are applied to an unseen sample and the class that got the highest number of positive predictions gets predicted by the combined classifier. Like One-vs-rest, one-vs-one suffers from ambiguities in that some regions of its input space may receive the same number of votes.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>One-vs-one strategy for reducing the problem of multiclass classification to multiple binary classification problems. This approach trains K (K − 1) / 2 binary classifiers for a K-way multiclass problem; each receives the samples of a pair of classes from the original training set, and must learn to distinguish these two classes. At prediction time, a voting scheme is applied: all K (K − 1) / 2 classifiers are applied to an unseen sample and the class that got the highest number of positive predictions gets predicted by the combined classifier. Like One-vs-rest, one-vs-one suffers from ambiguities in that some regions of its input space may receive the same number of votes.</p>
             </div>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="ovr-fffff055">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#ovr-fffff055" t="n" class="documentableName ">ovr</a>[<span t="k"></span><span data-unresolved-link="" t="t">T</span><span t="k"> &lt;: </span><span data-unresolved-link="" t="t">AnyRef</span>](<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<span t="t">T</span>], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>])(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">trainer</span>: (<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<span t="t">T</span>], <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>])<span t="k"> =&gt; </span><span data-unresolved-link="" t="t">Classifier</span>[<span t="t">T</span>]): <span data-unresolved-link="" t="t">OneVersusRest</span>[<span data-unresolved-link="" t="t">T</span>]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>One-vs-rest (or one-vs-all) strategy for reducing the problem of multiclass classification to multiple binary classification problems. It involves training a single classifier per class, with the samples of that class as positive samples and all other samples as negatives. This strategy requires the base classifiers to produce a real-valued confidence score for its decision, rather than just a class label; discrete class labels alone can lead to ambiguities, where multiple classes are predicted for a single sample.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>One-vs-rest (or one-vs-all) strategy for reducing the problem of multiclass classification to multiple binary classification problems. It involves training a single classifier per class, with the samples of that class as positive samples and all other samples as negatives. This strategy requires the base classifiers to produce a real-valued confidence score for its decision, rather than just a class label; discrete class labels alone can lead to ambiguities, where multiple classes are predicted for a single sample.</p>
              <p>Making decisions means applying all classifiers to an unseen sample x and predicting the label k for which the corresponding classifier reports the highest confidence score.</p>
              <p>Although this strategy is popular, it is a heuristic that suffers from several problems. Firstly, the scale of the confidence values may differ between the binary classifiers. Second, even if the class distribution is balanced in the training set, the binary classification learners see unbalanced distributions because typically the set of negatives they see is much larger than the set of positives.</p>
             </div>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="qda-d4c">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#qda-d4c" t="n" class="documentableName ">qda</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>]], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">priori</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>], <span t="k"></span><span data-unresolved-link="" t="n">tol</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>): <span data-unresolved-link="" t="t">QDA</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Quadratic discriminant analysis. QDA is closely related to linear discriminant analysis (LDA). Like LDA, QDA models the conditional probability density functions as a Gaussian distribution, then uses the posterior distributions to estimate the class for a given test data. Unlike LDA, however, in QDA there is no assumption that the covariance of each of the classes is identical. Therefore, the resulting separating surface between the classes is quadratic.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Quadratic discriminant analysis. QDA is closely related to linear discriminant analysis (LDA). Like LDA, QDA models the conditional probability density functions as a Gaussian distribution, then uses the posterior distributions to estimate the class for a given test data. Unlike LDA, however, in QDA there is no assumption that the covariance of each of the classes is identical. Therefore, the resulting separating surface between the classes is quadratic.</p>
              <p>The Gaussian parameters for each class can be estimated from training data with maximum likelihood (ML) estimation. However, when the number of training instances is small compared to the dimension of input space, the ML covariance estimation can be ill-posed. One approach to resolve the ill-posed estimation is to regularize the covariance estimation. One of these regularization methods is <a href="classification.html#rda-fffff066">rda</a>.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               priori
              </dt>
              <dd class="body-medium">
               <p>the priori probability of each class. If null, it will be estimated from the training data.</p>
              </dd>
              <dt class="body-small">
               tol
              </dt>
              <dd class="body-medium">
               <p>a tolerance to decide if a covariance matrix is singular; it will reject variables whose variance is less than tol<sup>2</sup>.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training samples.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>training labels in [0, k), where k is the number of classes.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>Quadratic discriminant analysis model.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="randomForest-1bb">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#randomForest-1bb" t="n" class="documentableName ">randomForest</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">formula</span>: <span data-unresolved-link="" t="t">Formula</span>, <span t="k"></span><span data-unresolved-link="" t="n">data</span>: <span data-unresolved-link="" t="t">DataFrame</span>, <span t="k"></span><span data-unresolved-link="" t="n">ntrees</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">mtry</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">splitRule</span>: <span data-unresolved-link="" t="t">SplitRule</span>, <span t="k"></span><span data-unresolved-link="" t="n">maxDepth</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">maxNodes</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">nodeSize</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">subsample</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">classWeight</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">seeds</span>: <span data-unresolved-link="" t="t">LongStream</span>): <span data-unresolved-link="" t="t">RandomForest</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Random forest for classification. Random forest is an ensemble classifier that consists of many decision trees and outputs the majority vote of individual trees. The method combines bagging idea and the random selection of features.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Random forest for classification. Random forest is an ensemble classifier that consists of many decision trees and outputs the majority vote of individual trees. The method combines bagging idea and the random selection of features.</p>
              <p>Each tree is constructed using the following algorithm:</p>
              <p>i. If the number of cases in the training set is N, randomly sample N cases with replacement from the original data. This sample will be the training set for growing the tree. i. If there are M input variables, a number m &lt;&lt; M is specified such that at each node, m variables are selected at random out of the M and the best split on these m is used to split the node. The value of m is held constant during the forest growing. i. Each tree is grown to the largest extent possible. There is no pruning.</p>
              <p>The advantages of random forest are:</p>
              <ul>
               <li>For many data sets, it produces a highly accurate classifier.</li>
               <li>It runs efficiently on large data sets.</li>
               <li>It can handle thousands of input variables without variable deletion.</li>
               <li>It gives estimates of what variables are important in the classification.</li>
               <li>It generates an internal unbiased estimate of the generalization error as the forest building progresses.</li>
               <li>It has an effective method for estimating missing data and maintains accuracy when a large proportion of the data are missing.</li>
              </ul>
              <p>The disadvantages are</p>
              <ul>
               <li>Random forests are prone to over-fitting for some datasets. This is even more pronounced on noisy data.</li>
               <li>For data including categorical variables with different number of levels, random forests are biased in favor of those attributes with more levels. Therefore, the variable importance scores from random forest are not reliable for this type of data.</li>
              </ul>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               data
              </dt>
              <dd class="body-medium">
               <p>the data frame of the explanatory and response variables.</p>
              </dd>
              <dt class="body-small">
               formula
              </dt>
              <dd class="body-medium">
               <p>a symbolic description of the model to be fitted.</p>
              </dd>
              <dt class="body-small">
               maxDepth
              </dt>
              <dd class="body-medium">
               <p>the maximum depth of the tree.</p>
              </dd>
              <dt class="body-small">
               maxNodes
              </dt>
              <dd class="body-medium">
               <p>the maximum number of leaf nodes in the tree.</p>
              </dd>
              <dt class="body-small">
               mtry
              </dt>
              <dd class="body-medium">
               <p>the number of random selected features to be used to determine the decision at a node of the tree. floor(sqrt(dim)) seems to give generally good performance, where dim is the number of variables.</p>
              </dd>
              <dt class="body-small">
               nodeSize
              </dt>
              <dd class="body-medium">
               <p>the minimum size of leaf nodes.</p>
              </dd>
              <dt class="body-small">
               ntrees
              </dt>
              <dd class="body-medium">
               <p>the number of trees.</p>
              </dd>
              <dt class="body-small">
               splitRule
              </dt>
              <dd class="body-medium">
               <p>Decision tree node split rule.</p>
              </dd>
              <dt class="body-small">
               subsample
              </dt>
              <dd class="body-medium">
               <p>the sampling rate for training tree. 1.0 means sampling with replacement. &lt; 1.0 means sampling without replacement.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>Random forest classification model.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="rbfnet-fffff5e6">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#rbfnet-fffff5e6" t="n" class="documentableName ">rbfnet</a>[<span t="k"></span><span data-unresolved-link="" t="t">T</span><span t="k"> &lt;: </span><span data-unresolved-link="" t="t">AnyRef</span>](<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<span t="t">T</span>], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">neurons</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<span data-unresolved-link="" t="t">RBF</span>[<span t="t">T</span>]], <span t="k"></span><span data-unresolved-link="" t="n">normalized</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Boolean.html" t="t">Boolean</a>): <span data-unresolved-link="" t="t">RBFNetwork</span>[<span data-unresolved-link="" t="t">T</span>]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Radial basis function networks. A radial basis function network is an artificial neural network that uses radial basis functions as activation functions. It is a linear combination of radial basis functions. They are used in function approximation, time series prediction, and control.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Radial basis function networks. A radial basis function network is an artificial neural network that uses radial basis functions as activation functions. It is a linear combination of radial basis functions. They are used in function approximation, time series prediction, and control.</p>
              <p>In its basic form, radial basis function network is in the form</p>
              <p>y(x) = Σ w<sub>i</sub> φ(||x-c<sub>i</sub>||)</p>
              <p>where the approximating function y(x) is represented as a sum of N radial basis functions φ, each associated with a different center c<sub>i</sub>, and weighted by an appropriate coefficient w<sub>i</sub>. For distance, one usually chooses Euclidean distance. The weights w<sub>i</sub> can be estimated using the matrix methods of linear least squares, because the approximating function is linear in the weights.</p>
              <p>The centers c<sub>i</sub> can be randomly selected from training data, or learned by some clustering method (e.g. k-means), or learned together with weight parameters undergo a supervised learning processing (e.g. error-correction learning).</p>
              <p>The popular choices for φ comprise the Gaussian function and the so called thin plate splines. The advantage of the thin plate splines is that their conditioning is invariant under scalings. Gaussian, multi-quadric and inverse multi-quadric are infinitely smooth and involve a scale or shape parameter, r<sub><small>0</small></sub> &gt; 0. Decreasing r<sub><small>0</small></sub> tends to flatten the basis function. For a given function, the quality of approximation may strongly depend on this parameter. In particular, increasing r<sub><small>0</small></sub> has the effect of better conditioning (the separation distance of the scaled points increases).</p>
              <p>A variant on RBF networks is normalized radial basis function (NRBF) networks, in which we require the sum of the basis functions to be unity. NRBF arises more naturally from a Bayesian statistical perspective. However, there is no evidence that either the NRBF method is consistently superior to the RBF method, or vice versa.</p>
              <p>SVMs with Gaussian kernel have similar structure as RBF networks with Gaussian radial basis functions. However, the SVM approach "automatically" solves the network complexity problem since the size of the hidden layer is obtained as the result of the QP procedure. Hidden neurons and support vectors correspond to each other, so the center problems of the RBF network is also solved, as the support vectors serve as the basis function centers. It was reported that with similar number of support vectors/centers, SVM shows better generalization performance than RBF network when the training data size is relatively small. On the other hand, RBF network gives better generalization performance than SVM on large training data.</p>
              <p>====References:====</p>
              <ul>
               <li>Simon Haykin. Neural Networks: A Comprehensive Foundation (2nd edition). 1999.</li>
               <li>T. Poggio and F. Girosi. Networks for approximation and learning. Proc. IEEE 78(9):1484-1487, 1990.</li>
               <li>Nabil Benoudjit and Michel Verleysen. On the kernel widths in radial-basis function networks. Neural Process, 2003.</li>
              </ul>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               neurons
              </dt>
              <dd class="body-medium">
               <p>the radial basis functions.</p>
              </dd>
              <dt class="body-small">
               normalized
              </dt>
              <dd class="body-medium">
               <p>train a normalized RBF network or not.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training samples.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>training labels in [0, k), where k is the number of classes.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="rbfnet-855">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#rbfnet-855" t="n" class="documentableName ">rbfnet</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>]], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">k</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>, <span t="k"></span><span data-unresolved-link="" t="n">normalized</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Boolean.html" t="t">Boolean</a>): <span data-unresolved-link="" t="t">RBFNetwork</span>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>]]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Trains a Gaussian RBF network with k-means.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Trains a Gaussian RBF network with k-means.</p>
             </div>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small"></dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="rda-fffff066">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#rda-fffff066" t="n" class="documentableName ">rda</a>(<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>]], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">alpha</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">priori</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>], <span t="k"></span><span data-unresolved-link="" t="n">tol</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>): <span data-unresolved-link="" t="t">RDA</span>
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Regularized discriminant analysis. RDA is a compromise between LDA and QDA, which allows one to shrink the separate covariances of QDA toward a common variance as in LDA. This method is very similar in flavor to ridge regression. The regularized covariance matrices of each class is Σ<sub>k</sub>(α) = α Σ<sub>k</sub> + (1 - α) Σ. The quadratic discriminant function is defined using the shrunken covariance matrices Σ<sub>k</sub>(α). The parameter α in [0, 1] controls the complexity of the model. When α is one, RDA becomes QDA. While α is zero, RDA is equivalent to LDA. Therefore, the regularization factor α allows a continuum of models between LDA and QDA.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Regularized discriminant analysis. RDA is a compromise between LDA and QDA, which allows one to shrink the separate covariances of QDA toward a common variance as in LDA. This method is very similar in flavor to ridge regression. The regularized covariance matrices of each class is Σ<sub>k</sub>(α) = α Σ<sub>k</sub> + (1 - α) Σ. The quadratic discriminant function is defined using the shrunken covariance matrices Σ<sub>k</sub>(α). The parameter α in [0, 1] controls the complexity of the model. When α is one, RDA becomes QDA. While α is zero, RDA is equivalent to LDA. Therefore, the regularization factor α allows a continuum of models between LDA and QDA.</p>
             </div>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               alpha
              </dt>
              <dd class="body-medium">
               <p>regularization factor in [0, 1] allows a continuum of models between LDA and QDA.</p>
              </dd>
              <dt class="body-small">
               priori
              </dt>
              <dd class="body-medium">
               <p>the priori probability of each class.</p>
              </dd>
              <dt class="body-small">
               tol
              </dt>
              <dd class="body-medium">
               <p>tolerance to decide if a covariance matrix is singular; it will reject variables whose variance is less than tol<sup>2</sup>.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training samples.</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>training labels in [0, k), where k is the number of classes.</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>Regularized discriminant analysis model.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
        <div class="documentableElement" id="svm-fffff8c1">
         <div class="documentableElement-expander">
          <button class="icon-button ar show-content"></button>
          <div class="header monospace mono-medium">
           <div class="signature">
            <span class="modifiers"></span><span class="kind"><span t="k">def </span></span><a href="classification.html#svm-fffff8c1" t="n" class="documentableName ">svm</a>[<span t="k"></span><span data-unresolved-link="" t="t">T</span><span t="k"> &lt;: </span><span data-unresolved-link="" t="t">AnyRef</span>](<span t="k"></span><span t="k"></span><span data-unresolved-link="" t="n">x</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<span t="t">T</span>], <span t="k"></span><span data-unresolved-link="" t="n">y</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Array.html" t="t">Array</a>[<a href="https://www.scala-lang.org/api/2.13.14/scala/Int.html" t="t">Int</a>], <span t="k"></span><span data-unresolved-link="" t="n">kernel</span>: <span data-unresolved-link="" t="t">MercerKernel</span>[<span t="t">T</span>], <span t="k"></span><span data-unresolved-link="" t="n">C</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>, <span t="k"></span><span data-unresolved-link="" t="n">tol</span>: <a href="https://www.scala-lang.org/api/2.13.14/scala/Double.html" t="t">Double</a>): <span data-unresolved-link="" t="t">SVM</span>[<span data-unresolved-link="" t="t">T</span>]
           </div>
          </div>
         </div>
         <div class="docs">
          <span class="modifiers"></span>
          <div>
           <div class="originInfo"></div>
           <div class="memberDocumentation">
            <div class="documentableBrief doc">
             <p>Support vector machines for classification. The basic support vector machine is a binary linear classifier which chooses the hyperplane that represents the largest separation, or margin, between the two classes. If such a hyperplane exists, it is known as the maximum-margin hyperplane and the linear classifier it defines is known as a maximum margin classifier.</p>
            </div>
            <div class="cover">
             <div class="doc">
              <p>Support vector machines for classification. The basic support vector machine is a binary linear classifier which chooses the hyperplane that represents the largest separation, or margin, between the two classes. If such a hyperplane exists, it is known as the maximum-margin hyperplane and the linear classifier it defines is known as a maximum margin classifier.</p>
              <p>If there exists no hyperplane that can perfectly split the positive and negative instances, the soft margin method will choose a hyperplane that splits the instances as cleanly as possible, while still maximizing the distance to the nearest cleanly split instances.</p>
              <p>The nonlinear SVMs are created by applying the kernel trick to maximum-margin hyperplanes. The resulting algorithm is formally similar, except that every dot product is replaced by a nonlinear kernel function. This allows the algorithm to fit the maximum-margin hyperplane in a transformed feature space. The transformation may be nonlinear and the transformed space be high dimensional. For example, the feature space corresponding Gaussian kernel is a Hilbert space of infinite dimension. Thus, though the classifier is a hyperplane in the high-dimensional feature space, it may be nonlinear in the original input space. Maximum margin classifiers are well regularized, so the infinite dimension does not spoil the results.</p>
              <p>The effectiveness of SVM depends on the selection of kernel, the kernel's parameters, and soft margin parameter C. Given a kernel, best combination of C and kernel's parameters is often selected by a grid-search with cross validation.</p>
              <p>The dominant approach for creating multi-class SVMs is to reduce the single multi-class problem into multiple binary classification problems. Common methods for such reduction is to build binary classifiers which distinguish between (i) one of the labels to the rest (one-versus-all) or (ii) between every pair of classes (one-versus-one). Classification of new instances for one-versus-all case is done by a winner-takes-all strategy, in which the classifier with the highest output function assigns the class. For the one-versus-one approach, classification is done by a max-wins voting strategy, in which every classifier assigns the instance to one of the two classes, then the vote for the assigned class is increased by one vote, and finally the class with most votes determines the instance classification.</p>
             </div>
             <h2 class="h200">Type parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               T
              </dt>
              <dd class="body-medium">
               <p>the data type</p>
              </dd>
             </dl>
             <h2 class="h200">Value parameters</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               C
              </dt>
              <dd class="body-medium">
               <p>the regularization parameter</p>
              </dd>
              <dt class="body-small">
               kernel
              </dt>
              <dd class="body-medium">
               <p>Mercer kernel</p>
              </dd>
              <dt class="body-small">
               tol
              </dt>
              <dd class="body-medium">
               <p>the tolerance of convergence test.</p>
              </dd>
              <dt class="body-small">
               x
              </dt>
              <dd class="body-medium">
               <p>training data</p>
              </dd>
              <dt class="body-small">
               y
              </dt>
              <dd class="body-medium">
               <p>training labels</p>
              </dd>
             </dl>
             <h2 class="h200">Attributes</h2>
             <dl class="attributes attributes-small">
              <dt class="body-small">
               Returns
              </dt>
              <dd class="body-medium">
               <p>SVM model.</p>
              </dd>
             </dl>
            </div>
           </div>
          </div>
         </div>
        </div>
       </div>
      </section>
     </div>
    </section>
   </div>
  </div>
 </div>
</section></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#attributes">Attributes</a></li><li><a href="#members-list">Members list</a><ul><li><a href="#Type-members">Type members</a><ul><li><a href="#Classlikes">Classlikes</a></li></ul></li><li><a href="#Value-members">Value members</a><ul><li><a href="#Concrete-methods">Concrete methods</a></li></ul></li></ul></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><div class="text">Copyright © 2010-2025 Haifeng Li. All rights reserved.
Use is subject to license terms.</div></div><div class="text-mobile">Copyright © 2010-2025 Haifeng Li. All rights reserved.
Use is subject to license terms.</div></div></div></div></body></html>