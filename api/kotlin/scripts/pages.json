[{"name":"fun <T> approx(x: Array<T>, y: DoubleArray, t: Array<T>, kernel: MercerKernel<T>, noise: Double, normalize: Boolean = true): GaussianProcessRegression<T>","description":"smile.regression.gpr.approx","location":"smile-kotlin/smile.regression/gpr/approx.html","searchKeys":["approx","fun <T> approx(x: Array<T>, y: DoubleArray, t: Array<T>, kernel: MercerKernel<T>, noise: Double, normalize: Boolean = true): GaussianProcessRegression<T>","smile.regression.gpr.approx"]},{"name":"fun <T> clarans(data: Array<T>, distance: Distance<T>, k: Int, maxNeighbor: Int, numLocal: Int = 16): CLARANS<T>","description":"smile.clustering.clarans","location":"smile-kotlin/smile.clustering/clarans.html","searchKeys":["clarans","fun <T> clarans(data: Array<T>, distance: Distance<T>, k: Int, maxNeighbor: Int, numLocal: Int = 16): CLARANS<T>","smile.clustering.clarans"]},{"name":"fun <T> dbscan(data: Array<T>, distance: Distance<T>, minPts: Int, radius: Double): DBSCAN<T>","description":"smile.clustering.dbscan","location":"smile-kotlin/smile.clustering/dbscan.html","searchKeys":["dbscan","fun <T> dbscan(data: Array<T>, distance: Distance<T>, minPts: Int, radius: Double): DBSCAN<T>","smile.clustering.dbscan"]},{"name":"fun <T> dbscan(data: Array<T>, nns: RNNSearch<T, T>, minPts: Int, radius: Double): DBSCAN<T>","description":"smile.clustering.dbscan","location":"smile-kotlin/smile.clustering/dbscan.html","searchKeys":["dbscan","fun <T> dbscan(data: Array<T>, nns: RNNSearch<T, T>, minPts: Int, radius: Double): DBSCAN<T>","smile.clustering.dbscan"]},{"name":"fun <T> gpr(x: Array<T>, y: DoubleArray, kernel: MercerKernel<T>, noise: Double, normalize: Boolean = true, tol: Double = 1.0E-5, maxIter: Int = 0): GaussianProcessRegression<T>","description":"smile.regression.gpr","location":"smile-kotlin/smile.regression/gpr.html","searchKeys":["gpr","fun <T> gpr(x: Array<T>, y: DoubleArray, kernel: MercerKernel<T>, noise: Double, normalize: Boolean = true, tol: Double = 1.0E-5, maxIter: Int = 0): GaussianProcessRegression<T>","smile.regression.gpr"]},{"name":"fun <T> hclust(data: Array<T>, distance: Distance<T>, method: String): HierarchicalClustering","description":"smile.clustering.hclust","location":"smile-kotlin/smile.clustering/hclust.html","searchKeys":["hclust","fun <T> hclust(data: Array<T>, distance: Distance<T>, method: String): HierarchicalClustering","smile.clustering.hclust"]},{"name":"fun <T> knn(x: Array<T>, y: IntArray, k: Int, distance: Distance<T>): KNN<T>","description":"smile.classification.knn","location":"smile-kotlin/smile.classification/knn.html","searchKeys":["knn","fun <T> knn(x: Array<T>, y: IntArray, k: Int, distance: Distance<T>): KNN<T>","smile.classification.knn"]},{"name":"fun <T> knn(x: KNNSearch<T, T>, y: IntArray, k: Int): KNN<T>","description":"smile.classification.knn","location":"smile-kotlin/smile.classification/knn.html","searchKeys":["knn","fun <T> knn(x: KNNSearch<T, T>, y: IntArray, k: Int): KNN<T>","smile.classification.knn"]},{"name":"fun <T> kpca(data: DataFrame, kernel: MercerKernel<DoubleArray>, k: Int, threshold: Double = 1.0E-4): KernelPCA","description":"smile.feature.extraction.kpca","location":"smile-kotlin/smile.feature.extraction/kpca.html","searchKeys":["kpca","fun <T> kpca(data: DataFrame, kernel: MercerKernel<DoubleArray>, k: Int, threshold: Double = 1.0E-4): KernelPCA","smile.feature.extraction.kpca"]},{"name":"fun <T> mec(data: Array<T>, distance: Distance<T>, k: Int, radius: Double): MEC<T>","description":"smile.clustering.mec","location":"smile-kotlin/smile.clustering/mec.html","searchKeys":["mec","fun <T> mec(data: Array<T>, distance: Distance<T>, k: Int, radius: Double): MEC<T>","smile.clustering.mec"]},{"name":"fun <T> mec(data: Array<T>, distance: Metric<T>, k: Int, radius: Double): MEC<T>","description":"smile.clustering.mec","location":"smile-kotlin/smile.clustering/mec.html","searchKeys":["mec","fun <T> mec(data: Array<T>, distance: Metric<T>, k: Int, radius: Double): MEC<T>","smile.clustering.mec"]},{"name":"fun <T> mec(data: Array<T>, nns: RNNSearch<T, T>, k: Int, radius: Double, y: IntArray, tol: Double = 1.0E-4): MEC<T>","description":"smile.clustering.mec","location":"smile-kotlin/smile.clustering/mec.html","searchKeys":["mec","fun <T> mec(data: Array<T>, nns: RNNSearch<T, T>, k: Int, radius: Double, y: IntArray, tol: Double = 1.0E-4): MEC<T>","smile.clustering.mec"]},{"name":"fun <T> nystrom(x: Array<T>, y: DoubleArray, t: Array<T>, kernel: MercerKernel<T>, noise: Double, normalize: Boolean = true): GaussianProcessRegression<T>","description":"smile.regression.gpr.nystrom","location":"smile-kotlin/smile.regression/gpr/nystrom.html","searchKeys":["nystrom","fun <T> nystrom(x: Array<T>, y: DoubleArray, t: Array<T>, kernel: MercerKernel<T>, noise: Double, normalize: Boolean = true): GaussianProcessRegression<T>","smile.regression.gpr.nystrom"]},{"name":"fun <T> ovo(x: Array<T>, y: IntArray, trainer: (Array<T>, IntArray) -> Classifier<T>): OneVersusOne<T>","description":"smile.classification.ovo","location":"smile-kotlin/smile.classification/ovo.html","searchKeys":["ovo","fun <T> ovo(x: Array<T>, y: IntArray, trainer: (Array<T>, IntArray) -> Classifier<T>): OneVersusOne<T>","smile.classification.ovo"]},{"name":"fun <T> ovr(x: Array<T>, y: IntArray, trainer: (Array<T>, IntArray) -> Classifier<T>): OneVersusRest<T>","description":"smile.classification.ovr","location":"smile-kotlin/smile.classification/ovr.html","searchKeys":["ovr","fun <T> ovr(x: Array<T>, y: IntArray, trainer: (Array<T>, IntArray) -> Classifier<T>): OneVersusRest<T>","smile.classification.ovr"]},{"name":"fun <T> rbfnet(x: Array<T>, y: DoubleArray, neurons: Array<RBF<T>>, normalized: Boolean = false): RBFNetwork<T>","description":"smile.regression.rbfnet","location":"smile-kotlin/smile.regression/rbfnet.html","searchKeys":["rbfnet","fun <T> rbfnet(x: Array<T>, y: DoubleArray, neurons: Array<RBF<T>>, normalized: Boolean = false): RBFNetwork<T>","smile.regression.rbfnet"]},{"name":"fun <T> rbfnet(x: Array<T>, y: IntArray, neurons: Array<RBF<T>>, normalized: Boolean = false): RBFNetwork<T>","description":"smile.classification.rbfnet","location":"smile-kotlin/smile.classification/rbfnet.html","searchKeys":["rbfnet","fun <T> rbfnet(x: Array<T>, y: IntArray, neurons: Array<RBF<T>>, normalized: Boolean = false): RBFNetwork<T>","smile.classification.rbfnet"]},{"name":"fun <T> svm(x: Array<T>, y: DoubleArray, kernel: MercerKernel<T>, eps: Double, C: Double, tol: Double = 0.001): KernelMachine<T>","description":"smile.regression.svm","location":"smile-kotlin/smile.regression/svm.html","searchKeys":["svm","fun <T> svm(x: Array<T>, y: DoubleArray, kernel: MercerKernel<T>, eps: Double, C: Double, tol: Double = 0.001): KernelMachine<T>","smile.regression.svm"]},{"name":"fun <T> svm(x: Array<T>, y: IntArray, kernel: MercerKernel<T>, C: Double, tol: Double = 0.001): SVM<T>","description":"smile.classification.svm","location":"smile-kotlin/smile.classification/svm.html","searchKeys":["svm","fun <T> svm(x: Array<T>, y: IntArray, kernel: MercerKernel<T>, C: Double, tol: Double = 0.001): SVM<T>","smile.classification.svm"]},{"name":"fun <T> umap(data: Array<T>, distance: Metric<T>, k: Int = 15, d: Int = 2, epochs: Int = 0, learningRate: Double = 1.0, minDist: Double = 0.1, spread: Double = 1.0, negativeSamples: Int = 5, repulsionStrength: Double = 1.0, localConnectivity: Double = 1.0): Array<DoubleArray>","description":"smile.manifold.umap","location":"smile-kotlin/smile.manifold/umap.html","searchKeys":["umap","fun <T> umap(data: Array<T>, distance: Metric<T>, k: Int = 15, d: Int = 2, epochs: Int = 0, learningRate: Double = 1.0, minDist: Double = 0.1, spread: Double = 1.0, negativeSamples: Int = 5, repulsionStrength: Double = 1.0, localConnectivity: Double = 1.0): Array<DoubleArray>","smile.manifold.umap"]},{"name":"fun String.bag(filter: String = \"default\", stemmer: Stemmer? = porter): Map<String, Int>","description":"smile.nlp.bag","location":"smile-kotlin/smile.nlp/bag.html","searchKeys":["bag","fun String.bag(filter: String = \"default\", stemmer: Stemmer? = porter): Map<String, Int>","smile.nlp.bag"]},{"name":"fun String.bag2(filter: String = \"default\", stemmer: Stemmer? = porter): Set<String>","description":"smile.nlp.bag2","location":"smile-kotlin/smile.nlp/bag2.html","searchKeys":["bag2","fun String.bag2(filter: String = \"default\", stemmer: Stemmer? = porter): Set<String>","smile.nlp.bag2"]},{"name":"fun String.keywords(k: Int = 10): Array<NGram>","description":"smile.nlp.keywords","location":"smile-kotlin/smile.nlp/keywords.html","searchKeys":["keywords","fun String.keywords(k: Int = 10): Array<NGram>","smile.nlp.keywords"]},{"name":"fun String.normalize(): String","description":"smile.nlp.normalize","location":"smile-kotlin/smile.nlp/normalize.html","searchKeys":["normalize","fun String.normalize(): String","smile.nlp.normalize"]},{"name":"fun String.postag(): Array<PennTreebankPOS>","description":"smile.nlp.postag","location":"smile-kotlin/smile.nlp/postag.html","searchKeys":["postag","fun String.postag(): Array<PennTreebankPOS>","smile.nlp.postag"]},{"name":"fun String.sentences(): Array<String>","description":"smile.nlp.sentences","location":"smile-kotlin/smile.nlp/sentences.html","searchKeys":["sentences","fun String.sentences(): Array<String>","smile.nlp.sentences"]},{"name":"fun String.words(filter: String = \"default\"): Array<String>","description":"smile.nlp.words","location":"smile-kotlin/smile.nlp/words.html","searchKeys":["words","fun String.words(filter: String = \"default\"): Array<String>","smile.nlp.words"]},{"name":"fun adaboost(formula: Formula, data: DataFrame, ntrees: Int = 500, maxDepth: Int = 20, maxNodes: Int = 6, nodeSize: Int = 1): AdaBoost","description":"smile.classification.adaboost","location":"smile-kotlin/smile.classification/adaboost.html","searchKeys":["adaboost","fun adaboost(formula: Formula, data: DataFrame, ntrees: Int = 500, maxDepth: Int = 20, maxNodes: Int = 6, nodeSize: Int = 1): AdaBoost","smile.classification.adaboost"]},{"name":"fun arff(data: DataFrame, file: Path, relation: String)","description":"smile.write.arff","location":"smile-kotlin/smile/write/arff.html","searchKeys":["arff","fun arff(data: DataFrame, file: Path, relation: String)","smile.write.arff"]},{"name":"fun arff(data: DataFrame, file: String, relation: String)","description":"smile.write.arff","location":"smile-kotlin/smile/write/arff.html","searchKeys":["arff","fun arff(data: DataFrame, file: String, relation: String)","smile.write.arff"]},{"name":"fun arff(file: Path): DataFrame","description":"smile.read.arff","location":"smile-kotlin/smile/read/arff.html","searchKeys":["arff","fun arff(file: Path): DataFrame","smile.read.arff"]},{"name":"fun arff(file: String): DataFrame","description":"smile.read.arff","location":"smile-kotlin/smile/read/arff.html","searchKeys":["arff","fun arff(file: String): DataFrame","smile.read.arff"]},{"name":"fun arm(confidence: Double, tree: FPTree): Stream<AssociationRule>","description":"smile.association.arm","location":"smile-kotlin/smile.association/arm.html","searchKeys":["arm","fun arm(confidence: Double, tree: FPTree): Stream<AssociationRule>","smile.association.arm"]},{"name":"fun arm(minSupport: Int, confidence: Double, itemsets: Array<IntArray>): Stream<AssociationRule>","description":"smile.association.arm","location":"smile-kotlin/smile.association/arm.html","searchKeys":["arm","fun arm(minSupport: Int, confidence: Double, itemsets: Array<IntArray>): Stream<AssociationRule>","smile.association.arm"]},{"name":"fun arrow(data: DataFrame, file: Path)","description":"smile.write.arrow","location":"smile-kotlin/smile/write/arrow.html","searchKeys":["arrow","fun arrow(data: DataFrame, file: Path)","smile.write.arrow"]},{"name":"fun arrow(data: DataFrame, file: String)","description":"smile.write.arrow","location":"smile-kotlin/smile/write/arrow.html","searchKeys":["arrow","fun arrow(data: DataFrame, file: String)","smile.write.arrow"]},{"name":"fun arrow(file: Path): DataFrame","description":"smile.read.arrow","location":"smile-kotlin/smile/read/arrow.html","searchKeys":["arrow","fun arrow(file: Path): DataFrame","smile.read.arrow"]},{"name":"fun arrow(file: String): DataFrame","description":"smile.read.arrow","location":"smile-kotlin/smile/read/arrow.html","searchKeys":["arrow","fun arrow(file: String): DataFrame","smile.read.arrow"]},{"name":"fun avro(file: Path, schema: InputStream): DataFrame","description":"smile.read.avro","location":"smile-kotlin/smile/read/avro.html","searchKeys":["avro","fun avro(file: Path, schema: InputStream): DataFrame","smile.read.avro"]},{"name":"fun avro(file: Path, schema: Path): DataFrame","description":"smile.read.avro","location":"smile-kotlin/smile/read/avro.html","searchKeys":["avro","fun avro(file: Path, schema: Path): DataFrame","smile.read.avro"]},{"name":"fun avro(file: String, schema: InputStream): DataFrame","description":"smile.read.avro","location":"smile-kotlin/smile/read/avro.html","searchKeys":["avro","fun avro(file: String, schema: InputStream): DataFrame","smile.read.avro"]},{"name":"fun avro(file: String, schema: String): DataFrame","description":"smile.read.avro","location":"smile-kotlin/smile/read/avro.html","searchKeys":["avro","fun avro(file: String, schema: String): DataFrame","smile.read.avro"]},{"name":"fun bigram(k: Int, minFreq: Int, text: List<String>): Array<Bigram>","description":"smile.nlp.bigram","location":"smile-kotlin/smile.nlp/bigram.html","searchKeys":["bigram","fun bigram(k: Int, minFreq: Int, text: List<String>): Array<Bigram>","smile.nlp.bigram"]},{"name":"fun bigram(p: Double, minFreq: Int, text: List<String>): Array<Bigram>","description":"smile.nlp.bigram","location":"smile-kotlin/smile.nlp/bigram.html","searchKeys":["bigram","fun bigram(p: Double, minFreq: Int, text: List<String>): Array<Bigram>","smile.nlp.bigram"]},{"name":"fun cart(formula: Formula, data: DataFrame, maxDepth: Int = 20, maxNodes: Int = 0, nodeSize: Int = 5): RegressionTree","description":"smile.regression.cart","location":"smile-kotlin/smile.regression/cart.html","searchKeys":["cart","fun cart(formula: Formula, data: DataFrame, maxDepth: Int = 20, maxNodes: Int = 0, nodeSize: Int = 5): RegressionTree","smile.regression.cart"]},{"name":"fun cart(formula: Formula, data: DataFrame, splitRule: SplitRule = SplitRule.GINI, maxDepth: Int = 20, maxNodes: Int = 0, nodeSize: Int = 5): DecisionTree","description":"smile.classification.cart","location":"smile-kotlin/smile.classification/cart.html","searchKeys":["cart","fun cart(formula: Formula, data: DataFrame, splitRule: SplitRule = SplitRule.GINI, maxDepth: Int = 20, maxNodes: Int = 0, nodeSize: Int = 5): DecisionTree","smile.classification.cart"]},{"name":"fun corpus(text: List<String>): SimpleCorpus","description":"smile.nlp.corpus","location":"smile-kotlin/smile.nlp/corpus.html","searchKeys":["corpus","fun corpus(text: List<String>): SimpleCorpus","smile.nlp.corpus"]},{"name":"fun csv(data: DataFrame, file: Path, delimiter: Char)","description":"smile.write.csv","location":"smile-kotlin/smile/write/csv.html","searchKeys":["csv","fun csv(data: DataFrame, file: Path, delimiter: Char)","smile.write.csv"]},{"name":"fun csv(data: DataFrame, file: String, delimiter: Char = ',')","description":"smile.write.csv","location":"smile-kotlin/smile/write/csv.html","searchKeys":["csv","fun csv(data: DataFrame, file: String, delimiter: Char = ',')","smile.write.csv"]},{"name":"fun csv(file: Path, delimiter: Char = ',', header: Boolean = true, quote: Char = '\"', escape: Char = '\\\\', schema: StructType? = null): DataFrame","description":"smile.read.csv","location":"smile-kotlin/smile/read/csv.html","searchKeys":["csv","fun csv(file: Path, delimiter: Char = ',', header: Boolean = true, quote: Char = '\"', escape: Char = '\\\\', schema: StructType? = null): DataFrame","smile.read.csv"]},{"name":"fun csv(file: Path, format: CSVFormat, schema: StructType? = null): DataFrame","description":"smile.read.csv","location":"smile-kotlin/smile/read/csv.html","searchKeys":["csv","fun csv(file: Path, format: CSVFormat, schema: StructType? = null): DataFrame","smile.read.csv"]},{"name":"fun csv(file: String, delimiter: Char = ',', header: Boolean = true, quote: Char = '\"', escape: Char = '\\\\', schema: StructType? = null): DataFrame","description":"smile.read.csv","location":"smile-kotlin/smile/read/csv.html","searchKeys":["csv","fun csv(file: String, delimiter: Char = ',', header: Boolean = true, quote: Char = '\"', escape: Char = '\\\\', schema: StructType? = null): DataFrame","smile.read.csv"]},{"name":"fun csv(file: String, format: CSVFormat, schema: StructType? = null): DataFrame","description":"smile.read.csv","location":"smile-kotlin/smile/read/csv.html","searchKeys":["csv","fun csv(file: String, format: CSVFormat, schema: StructType? = null): DataFrame","smile.read.csv"]},{"name":"fun dac(data: Array<DoubleArray>, k: Int, alpha: Double = 0.9, maxIter: Int = 100, tol: Double = 1.0E-4, splitTol: Double = 0.01): DeterministicAnnealing","description":"smile.clustering.dac","location":"smile-kotlin/smile.clustering/dac.html","searchKeys":["dac","fun dac(data: Array<DoubleArray>, k: Int, alpha: Double = 0.9, maxIter: Int = 100, tol: Double = 1.0E-4, splitTol: Double = 0.01): DeterministicAnnealing","smile.clustering.dac"]},{"name":"fun dbscan(data: Array<DoubleArray>, minPts: Int, radius: Double): DBSCAN<DoubleArray>","description":"smile.clustering.dbscan","location":"smile-kotlin/smile.clustering/dbscan.html","searchKeys":["dbscan","fun dbscan(data: Array<DoubleArray>, minPts: Int, radius: Double): DBSCAN<DoubleArray>","smile.clustering.dbscan"]},{"name":"fun denclue(data: Array<DoubleArray>, sigma: Double, m: Int): DENCLUE","description":"smile.clustering.denclue","location":"smile-kotlin/smile.clustering/denclue.html","searchKeys":["denclue","fun denclue(data: Array<DoubleArray>, sigma: Double, m: Int): DENCLUE","smile.clustering.denclue"]},{"name":"fun df(terms: List<String>, corpus: List<Map<String, Int>>): IntArray","description":"smile.nlp.df","location":"smile-kotlin/smile.nlp/df.html","searchKeys":["df","fun df(terms: List<String>, corpus: List<Map<String, Int>>): IntArray","smile.nlp.df"]},{"name":"fun dwt(t: DoubleArray, filter: String)","description":"smile.wavelet.dwt","location":"smile-kotlin/smile.wavelet/dwt.html","searchKeys":["dwt","fun dwt(t: DoubleArray, filter: String)","smile.wavelet.dwt"]},{"name":"fun fisher(x: Array<DoubleArray>, y: IntArray, L: Int = -1, tol: Double = 1.0E-4): FLD","description":"smile.classification.fisher","location":"smile-kotlin/smile.classification/fisher.html","searchKeys":["fisher","fun fisher(x: Array<DoubleArray>, y: IntArray, L: Int = -1, tol: Double = 1.0E-4): FLD","smile.classification.fisher"]},{"name":"fun fpgrowth(minSupport: Int, itemsets: Array<IntArray>): Stream<ItemSet>","description":"smile.association.fpgrowth","location":"smile-kotlin/smile.association/fpgrowth.html","searchKeys":["fpgrowth","fun fpgrowth(minSupport: Int, itemsets: Array<IntArray>): Stream<ItemSet>","smile.association.fpgrowth"]},{"name":"fun fpgrowth(tree: FPTree): Stream<ItemSet>","description":"smile.association.fpgrowth","location":"smile-kotlin/smile.association/fpgrowth.html","searchKeys":["fpgrowth","fun fpgrowth(tree: FPTree): Stream<ItemSet>","smile.association.fpgrowth"]},{"name":"fun fptree(minSupport: Int, supplier: Supplier<Stream<IntArray>>): FPTree","description":"smile.association.fptree","location":"smile-kotlin/smile.association/fptree.html","searchKeys":["fptree","fun fptree(minSupport: Int, supplier: Supplier<Stream<IntArray>>): FPTree","smile.association.fptree"]},{"name":"fun gbm(formula: Formula, data: DataFrame, loss: Loss = Loss.lad(), ntrees: Int = 500, maxDepth: Int = 20, maxNodes: Int = 6, nodeSize: Int = 5, shrinkage: Double = 0.05, subsample: Double = 0.7): GradientTreeBoost","description":"smile.regression.gbm","location":"smile-kotlin/smile.regression/gbm.html","searchKeys":["gbm","fun gbm(formula: Formula, data: DataFrame, loss: Loss = Loss.lad(), ntrees: Int = 500, maxDepth: Int = 20, maxNodes: Int = 6, nodeSize: Int = 5, shrinkage: Double = 0.05, subsample: Double = 0.7): GradientTreeBoost","smile.regression.gbm"]},{"name":"fun gbm(formula: Formula, data: DataFrame, ntrees: Int = 500, maxDepth: Int = 20, maxNodes: Int = 6, nodeSize: Int = 5, shrinkage: Double = 0.05, subsample: Double = 0.7): GradientTreeBoost","description":"smile.classification.gbm","location":"smile-kotlin/smile.classification/gbm.html","searchKeys":["gbm","fun gbm(formula: Formula, data: DataFrame, ntrees: Int = 500, maxDepth: Int = 20, maxNodes: Int = 6, nodeSize: Int = 5, shrinkage: Double = 0.05, subsample: Double = 0.7): GradientTreeBoost","smile.classification.gbm"]},{"name":"fun gha(data: Array<DoubleArray>, k: Int, r: TimeFunction): GHA","description":"smile.feature.extraction.gha","location":"smile-kotlin/smile.feature.extraction/gha.html","searchKeys":["gha","fun gha(data: Array<DoubleArray>, k: Int, r: TimeFunction): GHA","smile.feature.extraction.gha"]},{"name":"fun gha(data: Array<DoubleArray>, w: Array<DoubleArray>, r: TimeFunction): GHA","description":"smile.feature.extraction.gha","location":"smile-kotlin/smile.feature.extraction/gha.html","searchKeys":["gha","fun gha(data: Array<DoubleArray>, w: Array<DoubleArray>, r: TimeFunction): GHA","smile.feature.extraction.gha"]},{"name":"fun gmeans(data: Array<DoubleArray>, k: Int = 100): GMeans","description":"smile.clustering.gmeans","location":"smile-kotlin/smile.clustering/gmeans.html","searchKeys":["gmeans","fun gmeans(data: Array<DoubleArray>, k: Int = 100): GMeans","smile.clustering.gmeans"]},{"name":"fun hclust(data: Array<DoubleArray>, method: String): HierarchicalClustering","description":"smile.clustering.hclust","location":"smile-kotlin/smile.clustering/hclust.html","searchKeys":["hclust","fun hclust(data: Array<DoubleArray>, method: String): HierarchicalClustering","smile.clustering.hclust"]},{"name":"fun idwt(wt: DoubleArray, filter: String)","description":"smile.wavelet.idwt","location":"smile-kotlin/smile.wavelet/idwt.html","searchKeys":["idwt","fun idwt(wt: DoubleArray, filter: String)","smile.wavelet.idwt"]},{"name":"fun isomap(data: Array<DoubleArray>, k: Int, d: Int = 2, CIsomap: Boolean = true): Array<DoubleArray>","description":"smile.manifold.isomap","location":"smile-kotlin/smile.manifold/isomap.html","searchKeys":["isomap","fun isomap(data: Array<DoubleArray>, k: Int, d: Int = 2, CIsomap: Boolean = true): Array<DoubleArray>","smile.manifold.isomap"]},{"name":"fun isomds(proximity: Array<DoubleArray>, k: Int, tol: Double = 1.0E-4, maxIter: Int = 200): IsotonicMDS","description":"smile.manifold.isomds","location":"smile-kotlin/smile.manifold/isomds.html","searchKeys":["isomds","fun isomds(proximity: Array<DoubleArray>, k: Int, tol: Double = 1.0E-4, maxIter: Int = 200): IsotonicMDS","smile.manifold.isomds"]},{"name":"fun jdbc(rs: ResultSet): DataFrame","description":"smile.read.jdbc","location":"smile-kotlin/smile/read/jdbc.html","searchKeys":["jdbc","fun jdbc(rs: ResultSet): DataFrame","smile.read.jdbc"]},{"name":"fun json(file: Path): DataFrame","description":"smile.read.json","location":"smile-kotlin/smile/read/json.html","searchKeys":["json","fun json(file: Path): DataFrame","smile.read.json"]},{"name":"fun json(file: Path, mode: JSON.Mode, schema: StructType): DataFrame","description":"smile.read.json","location":"smile-kotlin/smile/read/json.html","searchKeys":["json","fun json(file: Path, mode: JSON.Mode, schema: StructType): DataFrame","smile.read.json"]},{"name":"fun json(file: String): DataFrame","description":"smile.read.json","location":"smile-kotlin/smile/read/json.html","searchKeys":["json","fun json(file: String): DataFrame","smile.read.json"]},{"name":"fun json(file: String, mode: JSON.Mode, schema: StructType): DataFrame","description":"smile.read.json","location":"smile-kotlin/smile/read/json.html","searchKeys":["json","fun json(file: String, mode: JSON.Mode, schema: StructType): DataFrame","smile.read.json"]},{"name":"fun kmeans(data: Array<DoubleArray>, k: Int, maxIter: Int = 100, tol: Double = 1.0E-4, runs: Int = 16): KMeans","description":"smile.clustering.kmeans","location":"smile-kotlin/smile.clustering/kmeans.html","searchKeys":["kmeans","fun kmeans(data: Array<DoubleArray>, k: Int, maxIter: Int = 100, tol: Double = 1.0E-4, runs: Int = 16): KMeans","smile.clustering.kmeans"]},{"name":"fun kmodes(data: Array<IntArray>, k: Int, maxIter: Int = 100, runs: Int = 10): KModes","description":"smile.clustering.kmodes","location":"smile-kotlin/smile.clustering/kmodes.html","searchKeys":["kmodes","fun kmodes(data: Array<IntArray>, k: Int, maxIter: Int = 100, runs: Int = 10): KModes","smile.clustering.kmodes"]},{"name":"fun knn(x: Array<DoubleArray>, y: IntArray, k: Int): KNN<DoubleArray>","description":"smile.classification.knn","location":"smile-kotlin/smile.classification/knn.html","searchKeys":["knn","fun knn(x: Array<DoubleArray>, y: IntArray, k: Int): KNN<DoubleArray>","smile.classification.knn"]},{"name":"fun lancaster(word: String): String","description":"smile.nlp.lancaster","location":"smile-kotlin/smile.nlp/lancaster.html","searchKeys":["lancaster","fun lancaster(word: String): String","smile.nlp.lancaster"]},{"name":"fun laplacian(data: Array<DoubleArray>, k: Int, d: Int = 2, t: Double = -1.0): Array<DoubleArray>","description":"smile.manifold.laplacian","location":"smile-kotlin/smile.manifold/laplacian.html","searchKeys":["laplacian","fun laplacian(data: Array<DoubleArray>, k: Int, d: Int = 2, t: Double = -1.0): Array<DoubleArray>","smile.manifold.laplacian"]},{"name":"fun lasso(formula: Formula, data: DataFrame, lambda: Double, tol: Double = 0.001, maxIter: Int = 5000): LinearModel","description":"smile.regression.lasso","location":"smile-kotlin/smile.regression/lasso.html","searchKeys":["lasso","fun lasso(formula: Formula, data: DataFrame, lambda: Double, tol: Double = 0.001, maxIter: Int = 5000): LinearModel","smile.regression.lasso"]},{"name":"fun lda(x: Array<DoubleArray>, y: IntArray, priori: DoubleArray? = null, tol: Double = 1.0E-4): LDA","description":"smile.classification.lda","location":"smile-kotlin/smile.classification/lda.html","searchKeys":["lda","fun lda(x: Array<DoubleArray>, y: IntArray, priori: DoubleArray? = null, tol: Double = 1.0E-4): LDA","smile.classification.lda"]},{"name":"fun libsvm(file: Path): SparseDataset<Int>","description":"smile.read.libsvm","location":"smile-kotlin/smile/read/libsvm.html","searchKeys":["libsvm","fun libsvm(file: Path): SparseDataset<Int>","smile.read.libsvm"]},{"name":"fun libsvm(file: String): SparseDataset<Int>","description":"smile.read.libsvm","location":"smile-kotlin/smile/read/libsvm.html","searchKeys":["libsvm","fun libsvm(file: String): SparseDataset<Int>","smile.read.libsvm"]},{"name":"fun lle(data: Array<DoubleArray>, k: Int, d: Int = 2): Array<DoubleArray>","description":"smile.manifold.lle","location":"smile-kotlin/smile.manifold/lle.html","searchKeys":["lle","fun lle(data: Array<DoubleArray>, k: Int, d: Int = 2): Array<DoubleArray>","smile.manifold.lle"]},{"name":"fun lm(formula: Formula, data: DataFrame, method: String = \"qr\", stderr: Boolean = true, recursive: Boolean = true): LinearModel","description":"smile.regression.lm","location":"smile-kotlin/smile.regression/lm.html","searchKeys":["lm","fun lm(formula: Formula, data: DataFrame, method: String = \"qr\", stderr: Boolean = true, recursive: Boolean = true): LinearModel","smile.regression.lm"]},{"name":"fun logit(x: Array<DoubleArray>, y: IntArray, lambda: Double = 0.0, tol: Double = 1.0E-5, maxIter: Int = 500): LogisticRegression","description":"smile.classification.logit","location":"smile-kotlin/smile.classification/logit.html","searchKeys":["logit","fun logit(x: Array<DoubleArray>, y: IntArray, lambda: Double = 0.0, tol: Double = 1.0E-5, maxIter: Int = 500): LogisticRegression","smile.classification.logit"]},{"name":"fun maxent(x: Array<IntArray>, y: IntArray, p: Int, lambda: Double = 0.1, tol: Double = 1.0E-5, maxIter: Int = 500): Maxent","description":"smile.classification.maxent","location":"smile-kotlin/smile.classification/maxent.html","searchKeys":["maxent","fun maxent(x: Array<IntArray>, y: IntArray, p: Int, lambda: Double = 0.1, tol: Double = 1.0E-5, maxIter: Int = 500): Maxent","smile.classification.maxent"]},{"name":"fun mds(proximity: Array<DoubleArray>, k: Int, positive: Boolean = false): MDS","description":"smile.manifold.mds","location":"smile-kotlin/smile.manifold/mds.html","searchKeys":["mds","fun mds(proximity: Array<DoubleArray>, k: Int, positive: Boolean = false): MDS","smile.manifold.mds"]},{"name":"fun mec(data: Array<DoubleArray>, k: Int, radius: Double): MEC<DoubleArray>","description":"smile.clustering.mec","location":"smile-kotlin/smile.clustering/mec.html","searchKeys":["mec","fun mec(data: Array<DoubleArray>, k: Int, radius: Double): MEC<DoubleArray>","smile.clustering.mec"]},{"name":"fun mlp(x: Array<DoubleArray>, y: IntArray, builders: Array<LayerBuilder>, epochs: Int = 10, learningRate: TimeFunction = TimeFunction.linear(0.01, 10000.0, 0.001), momentum: TimeFunction = TimeFunction.constant(0.0), weightDecay: Double = 0.0, rho: Double = 0.0, epsilon: Double = 1.0E-7): MLP","description":"smile.classification.mlp","location":"smile-kotlin/smile.classification/mlp.html","searchKeys":["mlp","fun mlp(x: Array<DoubleArray>, y: IntArray, builders: Array<LayerBuilder>, epochs: Int = 10, learningRate: TimeFunction = TimeFunction.linear(0.01, 10000.0, 0.001), momentum: TimeFunction = TimeFunction.constant(0.0), weightDecay: Double = 0.0, rho: Double = 0.0, epsilon: Double = 1.0E-7): MLP","smile.classification.mlp"]},{"name":"fun naiveBayes(priori: DoubleArray, condprob: Array<Array<Distribution>>): NaiveBayes","description":"smile.classification.naiveBayes","location":"smile-kotlin/smile.classification/naive-bayes.html","searchKeys":["naiveBayes","fun naiveBayes(priori: DoubleArray, condprob: Array<Array<Distribution>>): NaiveBayes","smile.classification.naiveBayes"]},{"name":"fun naiveBayes(x: Array<IntArray>, y: IntArray, model: DiscreteNaiveBayes.Model, priori: DoubleArray? = null, sigma: Double = 1.0): DiscreteNaiveBayes","description":"smile.classification.naiveBayes","location":"smile-kotlin/smile.classification/naive-bayes.html","searchKeys":["naiveBayes","fun naiveBayes(x: Array<IntArray>, y: IntArray, model: DiscreteNaiveBayes.Model, priori: DoubleArray? = null, sigma: Double = 1.0): DiscreteNaiveBayes","smile.classification.naiveBayes"]},{"name":"fun ngram(maxNGramSize: Int, minFreq: Int, text: List<String>): Array<Array<NGram>>","description":"smile.nlp.ngram","location":"smile-kotlin/smile.nlp/ngram.html","searchKeys":["ngram","fun ngram(maxNGramSize: Int, minFreq: Int, text: List<String>): Array<Array<NGram>>","smile.nlp.ngram"]},{"name":"fun parquet(file: Path): DataFrame","description":"smile.read.parquet","location":"smile-kotlin/smile/read/parquet.html","searchKeys":["parquet","fun parquet(file: Path): DataFrame","smile.read.parquet"]},{"name":"fun parquet(file: String): DataFrame","description":"smile.read.parquet","location":"smile-kotlin/smile/read/parquet.html","searchKeys":["parquet","fun parquet(file: String): DataFrame","smile.read.parquet"]},{"name":"fun pca(data: Array<DoubleArray>, cor: Boolean = false): PCA","description":"smile.feature.extraction.pca","location":"smile-kotlin/smile.feature.extraction/pca.html","searchKeys":["pca","fun pca(data: Array<DoubleArray>, cor: Boolean = false): PCA","smile.feature.extraction.pca"]},{"name":"fun porter(word: String): String","description":"smile.nlp.porter","location":"smile-kotlin/smile.nlp/porter.html","searchKeys":["porter","fun porter(word: String): String","smile.nlp.porter"]},{"name":"fun postag(sentence: Array<String>): Array<PennTreebankPOS>","description":"smile.nlp.postag","location":"smile-kotlin/smile.nlp/postag.html","searchKeys":["postag","fun postag(sentence: Array<String>): Array<PennTreebankPOS>","smile.nlp.postag"]},{"name":"fun ppca(data: Array<DoubleArray>, k: Int): ProbabilisticPCA","description":"smile.feature.extraction.ppca","location":"smile-kotlin/smile.feature.extraction/ppca.html","searchKeys":["ppca","fun ppca(data: Array<DoubleArray>, k: Int): ProbabilisticPCA","smile.feature.extraction.ppca"]},{"name":"fun qda(x: Array<DoubleArray>, y: IntArray, priori: DoubleArray? = null, tol: Double = 1.0E-4): QDA","description":"smile.classification.qda","location":"smile-kotlin/smile.classification/qda.html","searchKeys":["qda","fun qda(x: Array<DoubleArray>, y: IntArray, priori: DoubleArray? = null, tol: Double = 1.0E-4): QDA","smile.classification.qda"]},{"name":"fun randomForest(formula: Formula, data: DataFrame, ntrees: Int = 500, mtry: Int = 0, maxDepth: Int = 20, maxNodes: Int = 500, nodeSize: Int = 5, subsample: Double = 1.0): RandomForest","description":"smile.regression.randomForest","location":"smile-kotlin/smile.regression/random-forest.html","searchKeys":["randomForest","fun randomForest(formula: Formula, data: DataFrame, ntrees: Int = 500, mtry: Int = 0, maxDepth: Int = 20, maxNodes: Int = 500, nodeSize: Int = 5, subsample: Double = 1.0): RandomForest","smile.regression.randomForest"]},{"name":"fun randomForest(formula: Formula, data: DataFrame, ntrees: Int = 500, mtry: Int = 0, splitRule: SplitRule = SplitRule.GINI, maxDepth: Int = 20, maxNodes: Int = 500, nodeSize: Int = 1, subsample: Double = 1.0, classWeight: IntArray? = null, seeds: LongStream? = null): RandomForest","description":"smile.classification.randomForest","location":"smile-kotlin/smile.classification/random-forest.html","searchKeys":["randomForest","fun randomForest(formula: Formula, data: DataFrame, ntrees: Int = 500, mtry: Int = 0, splitRule: SplitRule = SplitRule.GINI, maxDepth: Int = 20, maxNodes: Int = 500, nodeSize: Int = 1, subsample: Double = 1.0, classWeight: IntArray? = null, seeds: LongStream? = null): RandomForest","smile.classification.randomForest"]},{"name":"fun rbfnet(x: Array<DoubleArray>, y: DoubleArray, k: Int, normalized: Boolean = false): RBFNetwork<DoubleArray>","description":"smile.regression.rbfnet","location":"smile-kotlin/smile.regression/rbfnet.html","searchKeys":["rbfnet","fun rbfnet(x: Array<DoubleArray>, y: DoubleArray, k: Int, normalized: Boolean = false): RBFNetwork<DoubleArray>","smile.regression.rbfnet"]},{"name":"fun rbfnet(x: Array<DoubleArray>, y: IntArray, k: Int, normalized: Boolean = false): RBFNetwork<DoubleArray>","description":"smile.classification.rbfnet","location":"smile-kotlin/smile.classification/rbfnet.html","searchKeys":["rbfnet","fun rbfnet(x: Array<DoubleArray>, y: IntArray, k: Int, normalized: Boolean = false): RBFNetwork<DoubleArray>","smile.classification.rbfnet"]},{"name":"fun rda(x: Array<DoubleArray>, y: IntArray, alpha: Double, priori: DoubleArray? = null, tol: Double = 1.0E-4): RDA","description":"smile.classification.rda","location":"smile-kotlin/smile.classification/rda.html","searchKeys":["rda","fun rda(x: Array<DoubleArray>, y: IntArray, alpha: Double, priori: DoubleArray? = null, tol: Double = 1.0E-4): RDA","smile.classification.rda"]},{"name":"fun ridge(formula: Formula, data: DataFrame, lambda: Double): LinearModel","description":"smile.regression.ridge","location":"smile-kotlin/smile.regression/ridge.html","searchKeys":["ridge","fun ridge(formula: Formula, data: DataFrame, lambda: Double): LinearModel","smile.regression.ridge"]},{"name":"fun sammon(proximity: Array<DoubleArray>, k: Int, lambda: Double = 0.2, tol: Double = 1.0E-4, stepTol: Double = 0.001, maxIter: Int = 100): SammonMapping","description":"smile.manifold.sammon","location":"smile-kotlin/smile.manifold/sammon.html","searchKeys":["sammon","fun sammon(proximity: Array<DoubleArray>, k: Int, lambda: Double = 0.2, tol: Double = 1.0E-4, stepTol: Double = 0.001, maxIter: Int = 100): SammonMapping","smile.manifold.sammon"]},{"name":"fun sas(file: Path): DataFrame","description":"smile.read.sas","location":"smile-kotlin/smile/read/sas.html","searchKeys":["sas","fun sas(file: Path): DataFrame","smile.read.sas"]},{"name":"fun sas(file: String): DataFrame","description":"smile.read.sas","location":"smile-kotlin/smile/read/sas.html","searchKeys":["sas","fun sas(file: String): DataFrame","smile.read.sas"]},{"name":"fun sib(data: Array<SparseArray>, k: Int, maxIter: Int = 100, runs: Int = 8): SIB","description":"smile.clustering.sib","location":"smile-kotlin/smile.clustering/sib.html","searchKeys":["sib","fun sib(data: Array<SparseArray>, k: Int, maxIter: Int = 100, runs: Int = 8): SIB","smile.clustering.sib"]},{"name":"fun specc(W: Matrix, k: Int): SpectralClustering","description":"smile.clustering.specc","location":"smile-kotlin/smile.clustering/specc.html","searchKeys":["specc","fun specc(W: Matrix, k: Int): SpectralClustering","smile.clustering.specc"]},{"name":"fun specc(data: Array<DoubleArray>, k: Int, l: Int, sigma: Double): SpectralClustering","description":"smile.clustering.specc","location":"smile-kotlin/smile.clustering/specc.html","searchKeys":["specc","fun specc(data: Array<DoubleArray>, k: Int, l: Int, sigma: Double): SpectralClustering","smile.clustering.specc"]},{"name":"fun specc(data: Array<DoubleArray>, k: Int, sigma: Double): SpectralClustering","description":"smile.clustering.specc","location":"smile-kotlin/smile.clustering/specc.html","searchKeys":["specc","fun specc(data: Array<DoubleArray>, k: Int, sigma: Double): SpectralClustering","smile.clustering.specc"]},{"name":"fun tfidf(bag: DoubleArray, n: Int, df: IntArray): DoubleArray","description":"smile.nlp.tfidf","location":"smile-kotlin/smile.nlp/tfidf.html","searchKeys":["tfidf","fun tfidf(bag: DoubleArray, n: Int, df: IntArray): DoubleArray","smile.nlp.tfidf"]},{"name":"fun tfidf(corpus: List<DoubleArray>): List<DoubleArray>","description":"smile.nlp.tfidf","location":"smile-kotlin/smile.nlp/tfidf.html","searchKeys":["tfidf","fun tfidf(corpus: List<DoubleArray>): List<DoubleArray>","smile.nlp.tfidf"]},{"name":"fun tfidf(tf: Double, maxtf: Double, n: Int, df: Int): Double","description":"smile.nlp.tfidf","location":"smile-kotlin/smile.nlp/tfidf.html","searchKeys":["tfidf","fun tfidf(tf: Double, maxtf: Double, n: Int, df: Int): Double","smile.nlp.tfidf"]},{"name":"fun tsne(X: Array<DoubleArray>, d: Int = 2, perplexity: Double = 20.0, eta: Double = 200.0, iterations: Int = 1000): TSNE","description":"smile.manifold.tsne","location":"smile-kotlin/smile.manifold/tsne.html","searchKeys":["tsne","fun tsne(X: Array<DoubleArray>, d: Int = 2, perplexity: Double = 20.0, eta: Double = 200.0, iterations: Int = 1000): TSNE","smile.manifold.tsne"]},{"name":"fun umap(data: Array<DoubleArray>, k: Int = 15, d: Int = 2, epochs: Int = 0, learningRate: Double = 1.0, minDist: Double = 0.1, spread: Double = 1.0, negativeSamples: Int = 5, repulsionStrength: Double = 1.0, localConnectivity: Double = 1.0): Array<DoubleArray>","description":"smile.manifold.umap","location":"smile-kotlin/smile.manifold/umap.html","searchKeys":["umap","fun umap(data: Array<DoubleArray>, k: Int = 15, d: Int = 2, epochs: Int = 0, learningRate: Double = 1.0, minDist: Double = 0.1, spread: Double = 1.0, negativeSamples: Int = 5, repulsionStrength: Double = 1.0, localConnectivity: Double = 1.0): Array<DoubleArray>","smile.manifold.umap"]},{"name":"fun vectorize(terms: Array<String>, bag: Map<String, Int>): DoubleArray","description":"smile.nlp.vectorize","location":"smile-kotlin/smile.nlp/vectorize.html","searchKeys":["vectorize","fun vectorize(terms: Array<String>, bag: Map<String, Int>): DoubleArray","smile.nlp.vectorize"]},{"name":"fun vectorize(terms: List<String>, bag: Set<String>): IntArray","description":"smile.nlp.vectorize","location":"smile-kotlin/smile.nlp/vectorize.html","searchKeys":["vectorize","fun vectorize(terms: List<String>, bag: Set<String>): IntArray","smile.nlp.vectorize"]},{"name":"fun wavelet(filter: String): Wavelet","description":"smile.wavelet.wavelet","location":"smile-kotlin/smile.wavelet/wavelet.html","searchKeys":["wavelet","fun wavelet(filter: String): Wavelet","smile.wavelet.wavelet"]},{"name":"fun wsdenoise(t: DoubleArray, filter: String, soft: Boolean = false)","description":"smile.wavelet.wsdenoise","location":"smile-kotlin/smile.wavelet/wsdenoise.html","searchKeys":["wsdenoise","fun wsdenoise(t: DoubleArray, filter: String, soft: Boolean = false)","smile.wavelet.wsdenoise"]},{"name":"fun xmeans(data: Array<DoubleArray>, k: Int = 100): XMeans","description":"smile.clustering.xmeans","location":"smile-kotlin/smile.clustering/xmeans.html","searchKeys":["xmeans","fun xmeans(data: Array<DoubleArray>, k: Int = 100): XMeans","smile.clustering.xmeans"]},{"name":"object gpr","description":"smile.regression.gpr","location":"smile-kotlin/smile.regression/gpr/index.html","searchKeys":["gpr","object gpr","smile.regression.gpr"]},{"name":"object read","description":"smile.read","location":"smile-kotlin/smile/read/index.html","searchKeys":["read","object read","smile.read"]},{"name":"object write","description":"smile.write","location":"smile-kotlin/smile/write/index.html","searchKeys":["write","object write","smile.write"]}]
