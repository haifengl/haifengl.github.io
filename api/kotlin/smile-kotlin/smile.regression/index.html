<HTML>
<HEAD>
<meta charset="UTF-8">
<title>smile.regression - smile-kotlin</title>
<link rel="stylesheet" href="../../style.css">
</HEAD>
<BODY>
<a href="../index.html">smile-kotlin</a>&nbsp;/&nbsp;<a href="./index.html">smile.regression</a><br/>
<br/>
<h2>Package smile.regression</h2>
<p>Regression analysis.</p>
<p>Regression analysis includes any
techniques for modeling and analyzing several variables, when the focus
is on the relationship between a dependent variable and one or more
independent variables. Most commonly, regression analysis estimates the
conditional expectation of the dependent variable given the independent
variables. Therefore, the estimation target is a function of the independent
variables called the regression function. Regression analysis is widely
used for prediction and forecasting.</p>
  
<h3>Types</h3>
<table>
<tbody>
<tr>
<td>
<h4><a href="gpr/index.html">gpr</a></h4>
</td>
<td>
<p>Gaussian Process for Regression.</p>
<code><span class="keyword">object </span><span class="identifier">gpr</span></code></td>
</tr>
</tbody>
</table>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<h4><a href="cart.html">cart</a></h4>
</td>
<td>
<p>Regression tree. A classification/regression tree can be learned by
splitting the training set into subsets based on an attribute value
test. This process is repeated on each derived subset in a recursive
manner called recursive partitioning. The recursion is completed when
the subset at a node all has the same value of the target variable,
or when splitting no longer adds value to the predictions.</p>
<code><span class="keyword">fun </span><span class="identifier">cart</span><span class="symbol">(</span><span class="identifier" id="smile.regression$cart(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Int, kotlin.Int, kotlin.Int)/formula">formula</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/data/formula/Formula.html"><span class="identifier">Formula</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$cart(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Int, kotlin.Int, kotlin.Int)/data">data</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/data/DataFrame.html"><span class="identifier">DataFrame</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$cart(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Int, kotlin.Int, kotlin.Int)/maxDepth">maxDepth</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;20<span class="symbol">, </span><span class="identifier" id="smile.regression$cart(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Int, kotlin.Int, kotlin.Int)/maxNodes">maxNodes</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;0<span class="symbol">, </span><span class="identifier" id="smile.regression$cart(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Int, kotlin.Int, kotlin.Int)/nodeSize">nodeSize</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;5<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/regression/RegressionTree.html"><span class="identifier">RegressionTree</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="gbm.html">gbm</a></h4>
</td>
<td>
<p>Gradient boosted regression trees.</p>
<code><span class="keyword">fun </span><span class="identifier">gbm</span><span class="symbol">(</span><span class="identifier" id="smile.regression$gbm(smile.data.formula.Formula, smile.data.DataFrame, smile.base.cart.Loss, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double)/formula">formula</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/data/formula/Formula.html"><span class="identifier">Formula</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$gbm(smile.data.formula.Formula, smile.data.DataFrame, smile.base.cart.Loss, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/data/DataFrame.html"><span class="identifier">DataFrame</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$gbm(smile.data.formula.Formula, smile.data.DataFrame, smile.base.cart.Loss, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double)/loss">loss</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/base/cart/Loss.html"><span class="identifier">Loss</span></a>&nbsp;<span class="symbol">=</span>&nbsp;Loss.lad()<span class="symbol">, </span><span class="identifier" id="smile.regression$gbm(smile.data.formula.Formula, smile.data.DataFrame, smile.base.cart.Loss, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double)/ntrees">ntrees</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;500<span class="symbol">, </span><span class="identifier" id="smile.regression$gbm(smile.data.formula.Formula, smile.data.DataFrame, smile.base.cart.Loss, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double)/maxDepth">maxDepth</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;20<span class="symbol">, </span><span class="identifier" id="smile.regression$gbm(smile.data.formula.Formula, smile.data.DataFrame, smile.base.cart.Loss, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double)/maxNodes">maxNodes</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;6<span class="symbol">, </span><span class="identifier" id="smile.regression$gbm(smile.data.formula.Formula, smile.data.DataFrame, smile.base.cart.Loss, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double)/nodeSize">nodeSize</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;5<span class="symbol">, </span><span class="identifier" id="smile.regression$gbm(smile.data.formula.Formula, smile.data.DataFrame, smile.base.cart.Loss, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double)/shrinkage">shrinkage</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;0.05<span class="symbol">, </span><span class="identifier" id="smile.regression$gbm(smile.data.formula.Formula, smile.data.DataFrame, smile.base.cart.Loss, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double)/subsample">subsample</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;0.7<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/regression/GradientTreeBoost.html"><span class="identifier">GradientTreeBoost</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="gpr.html">gpr</a></h4>
</td>
<td>
<p>Gaussian Process for Regression. A Gaussian process is a stochastic process
whose realizations consist of random values associated with every point in
a range of times (or of space) such that each such random variable has
a normal distribution. Moreover, every finite collection of those random
variables has a multivariate normal distribution.</p>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <span class="identifier">gpr</span><span class="symbol">(</span><span class="identifier" id="smile.regression$gpr(kotlin.Array((smile.regression.gpr.T)), kotlin.DoubleArray, smile.math.kernel.MercerKernel((smile.regression.gpr.T)), kotlin.Double)/x">x</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.regression$gpr(kotlin.Array((smile.regression.gpr.T)), kotlin.DoubleArray, smile.math.kernel.MercerKernel((smile.regression.gpr.T)), kotlin.Double)/y">y</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$gpr(kotlin.Array((smile.regression.gpr.T)), kotlin.DoubleArray, smile.math.kernel.MercerKernel((smile.regression.gpr.T)), kotlin.Double)/kernel">kernel</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/math/kernel/MercerKernel.html"><span class="identifier">MercerKernel</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.regression$gpr(kotlin.Array((smile.regression.gpr.T)), kotlin.DoubleArray, smile.math.kernel.MercerKernel((smile.regression.gpr.T)), kotlin.Double)/lambda">lambda</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/regression/KernelMachine.html"><span class="identifier">KernelMachine</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<h4><a href="lasso.html">lasso</a></h4>
</td>
<td>
<p>Least absolute shrinkage and selection operator.
The Lasso is a shrinkage and selection method for linear regression.
It minimizes the usual sum of squared errors, with a bound on the sum
of the absolute values of the coefficients (i.e. L1-regularized).
It has connections to soft-thresholding of wavelet coefficients, forward
stage-wise regression, and boosting methods.</p>
<code><span class="keyword">fun </span><span class="identifier">lasso</span><span class="symbol">(</span><span class="identifier" id="smile.regression$lasso(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Double, kotlin.Double, kotlin.Int)/formula">formula</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/data/formula/Formula.html"><span class="identifier">Formula</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$lasso(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Double, kotlin.Double, kotlin.Int)/data">data</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/data/DataFrame.html"><span class="identifier">DataFrame</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$lasso(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Double, kotlin.Double, kotlin.Int)/lambda">lambda</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$lasso(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Double, kotlin.Double, kotlin.Int)/tol">tol</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;1E-3<span class="symbol">, </span><span class="identifier" id="smile.regression$lasso(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Double, kotlin.Double, kotlin.Int)/maxIter">maxIter</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;5000<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/regression/LinearModel.html"><span class="identifier">LinearModel</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="ols.html">ols</a></h4>
</td>
<td>
<p>Ordinary least squares. In linear regression,
the model specification is that the dependent variable is a linear
combination of the parameters (but need not be linear in the independent
variables). The residual is the difference between the value of the
dependent variable predicted by the model, and the true value of the
dependent variable. Ordinary least squares obtains parameter estimates
that minimize the sum of squared residuals, SSE (also denoted RSS).</p>
<code><span class="keyword">fun </span><span class="identifier">ols</span><span class="symbol">(</span><span class="identifier" id="smile.regression$ols(smile.data.formula.Formula, smile.data.DataFrame, kotlin.String, kotlin.Boolean, kotlin.Boolean)/formula">formula</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/data/formula/Formula.html"><span class="identifier">Formula</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$ols(smile.data.formula.Formula, smile.data.DataFrame, kotlin.String, kotlin.Boolean, kotlin.Boolean)/data">data</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/data/DataFrame.html"><span class="identifier">DataFrame</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$ols(smile.data.formula.Formula, smile.data.DataFrame, kotlin.String, kotlin.Boolean, kotlin.Boolean)/method">method</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a>&nbsp;<span class="symbol">=</span>&nbsp;"qr"<span class="symbol">, </span><span class="identifier" id="smile.regression$ols(smile.data.formula.Formula, smile.data.DataFrame, kotlin.String, kotlin.Boolean, kotlin.Boolean)/stderr">stderr</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a>&nbsp;<span class="symbol">=</span>&nbsp;true<span class="symbol">, </span><span class="identifier" id="smile.regression$ols(smile.data.formula.Formula, smile.data.DataFrame, kotlin.String, kotlin.Boolean, kotlin.Boolean)/recursive">recursive</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a>&nbsp;<span class="symbol">=</span>&nbsp;true<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/regression/LinearModel.html"><span class="identifier">LinearModel</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="random-forest.html">randomForest</a></h4>
</td>
<td>
<p>Random forest for regression. Random forest is an ensemble classifier
that consists of many decision trees and outputs the majority vote of
individual trees. The method combines bagging idea and the random
selection of features.</p>
<code><span class="keyword">fun </span><span class="identifier">randomForest</span><span class="symbol">(</span><span class="identifier" id="smile.regression$randomForest(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double)/formula">formula</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/data/formula/Formula.html"><span class="identifier">Formula</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$randomForest(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/data/DataFrame.html"><span class="identifier">DataFrame</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$randomForest(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double)/ntrees">ntrees</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;500<span class="symbol">, </span><span class="identifier" id="smile.regression$randomForest(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double)/mtry">mtry</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;0<span class="symbol">, </span><span class="identifier" id="smile.regression$randomForest(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double)/maxDepth">maxDepth</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;20<span class="symbol">, </span><span class="identifier" id="smile.regression$randomForest(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double)/maxNodes">maxNodes</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;500<span class="symbol">, </span><span class="identifier" id="smile.regression$randomForest(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double)/nodeSize">nodeSize</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;5<span class="symbol">, </span><span class="identifier" id="smile.regression$randomForest(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double)/subsample">subsample</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;1.0<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/regression/RandomForest.html"><span class="identifier">RandomForest</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="rbfnet.html">rbfnet</a></h4>
</td>
<td>
<p>Radial basis function networks. A radial basis function network is an
artificial neural network that uses radial basis functions as activation
functions. It is a linear combination of radial basis functions. They are
used in function approximation, time series prediction, and control.</p>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <span class="identifier">rbfnet</span><span class="symbol">(</span><span class="identifier" id="smile.regression$rbfnet(kotlin.Array((smile.regression.rbfnet.T)), kotlin.DoubleArray, kotlin.Array((smile.base.rbf.RBF((smile.regression.rbfnet.T)))), kotlin.Boolean)/x">x</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.regression$rbfnet(kotlin.Array((smile.regression.rbfnet.T)), kotlin.DoubleArray, kotlin.Array((smile.base.rbf.RBF((smile.regression.rbfnet.T)))), kotlin.Boolean)/y">y</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$rbfnet(kotlin.Array((smile.regression.rbfnet.T)), kotlin.DoubleArray, kotlin.Array((smile.base.rbf.RBF((smile.regression.rbfnet.T)))), kotlin.Boolean)/neurons">neurons</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="http://haifengl.github.io/api/java/smile/base/rbf/RBF.html"><span class="identifier">RBF</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.regression$rbfnet(kotlin.Array((smile.regression.rbfnet.T)), kotlin.DoubleArray, kotlin.Array((smile.base.rbf.RBF((smile.regression.rbfnet.T)))), kotlin.Boolean)/normalized">normalized</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a>&nbsp;<span class="symbol">=</span>&nbsp;false<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/regression/RBFNetwork.html"><span class="identifier">RBFNetwork</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Trains a Gaussian RBF network with k-means.</p>
<code><span class="keyword">fun </span><span class="identifier">rbfnet</span><span class="symbol">(</span><span class="identifier" id="smile.regression$rbfnet(kotlin.Array((kotlin.DoubleArray)), kotlin.DoubleArray, kotlin.Int, kotlin.Boolean)/x">x</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.regression$rbfnet(kotlin.Array((kotlin.DoubleArray)), kotlin.DoubleArray, kotlin.Int, kotlin.Boolean)/y">y</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$rbfnet(kotlin.Array((kotlin.DoubleArray)), kotlin.DoubleArray, kotlin.Int, kotlin.Boolean)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$rbfnet(kotlin.Array((kotlin.DoubleArray)), kotlin.DoubleArray, kotlin.Int, kotlin.Boolean)/normalized">normalized</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a>&nbsp;<span class="symbol">=</span>&nbsp;false<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/regression/RBFNetwork.html"><span class="identifier">RBFNetwork</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<h4><a href="ridge.html">ridge</a></h4>
</td>
<td>
<p>Ridge Regression. When the predictor variables are highly correlated amongst
themselves, the coefficients of the resulting least squares fit may be very
imprecise. By allowing a small amount of bias in the estimates, more
reasonable coefficients may often be obtained. Ridge regression is one
method to address these issues. Often, small amounts of bias lead to
dramatic reductions in the variance of the estimated model coefficients.
Ridge regression is such a technique which shrinks the regression
coefficients by imposing a penalty on their size. Ridge regression was
originally developed to overcome the singularity of the X'X matrix.
This matrix is perturbed so as to make its determinant appreciably
different from 0.</p>
<code><span class="keyword">fun </span><span class="identifier">ridge</span><span class="symbol">(</span><span class="identifier" id="smile.regression$ridge(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Double)/formula">formula</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/data/formula/Formula.html"><span class="identifier">Formula</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$ridge(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/data/DataFrame.html"><span class="identifier">DataFrame</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$ridge(smile.data.formula.Formula, smile.data.DataFrame, kotlin.Double)/lambda">lambda</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/regression/LinearModel.html"><span class="identifier">LinearModel</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="svr.html">svr</a></h4>
</td>
<td>
<p>Support vector regression. Like SVM for classification, the model produced
by SVR depends only on a subset of the training data, because the cost
function ignores any training data close to the model prediction (within
a threshold).</p>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <span class="identifier">svr</span><span class="symbol">(</span><span class="identifier" id="smile.regression$svr(kotlin.Array((smile.regression.svr.T)), kotlin.DoubleArray, smile.math.kernel.MercerKernel((smile.regression.svr.T)), kotlin.Double, kotlin.Double, kotlin.Double)/x">x</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.regression$svr(kotlin.Array((smile.regression.svr.T)), kotlin.DoubleArray, smile.math.kernel.MercerKernel((smile.regression.svr.T)), kotlin.Double, kotlin.Double, kotlin.Double)/y">y</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$svr(kotlin.Array((smile.regression.svr.T)), kotlin.DoubleArray, smile.math.kernel.MercerKernel((smile.regression.svr.T)), kotlin.Double, kotlin.Double, kotlin.Double)/kernel">kernel</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/math/kernel/MercerKernel.html"><span class="identifier">MercerKernel</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.regression$svr(kotlin.Array((smile.regression.svr.T)), kotlin.DoubleArray, smile.math.kernel.MercerKernel((smile.regression.svr.T)), kotlin.Double, kotlin.Double, kotlin.Double)/eps">eps</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$svr(kotlin.Array((smile.regression.svr.T)), kotlin.DoubleArray, smile.math.kernel.MercerKernel((smile.regression.svr.T)), kotlin.Double, kotlin.Double, kotlin.Double)/C">C</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">, </span><span class="identifier" id="smile.regression$svr(kotlin.Array((smile.regression.svr.T)), kotlin.DoubleArray, smile.math.kernel.MercerKernel((smile.regression.svr.T)), kotlin.Double, kotlin.Double, kotlin.Double)/tol">tol</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;1E-3<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/regression/KernelMachine.html"><span class="identifier">KernelMachine</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code></td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
