<HTML>
<HEAD>
<meta charset="UTF-8">
<title>hclust - smile-kotlin</title>
<link rel="stylesheet" href="../../style.css">
</HEAD>
<BODY>
<a href="../index.html">smile-kotlin</a>&nbsp;/&nbsp;<a href="index.html">smile.clustering</a>&nbsp;/&nbsp;<a href="./hclust.html">hclust</a><br/>
<br/>
<h1>hclust</h1>
<a name="smile.clustering$hclust(kotlin.Array((kotlin.DoubleArray)), kotlin.String)"></a>
<code><span class="keyword">fun </span><span class="identifier">hclust</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$hclust(kotlin.Array((kotlin.DoubleArray)), kotlin.String)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$hclust(kotlin.Array((kotlin.DoubleArray)), kotlin.String)/method">method</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/HierarchicalClustering.html"><span class="identifier">HierarchicalClustering</span></a></code>
<p>Agglomerative Hierarchical Clustering. This method
seeks to build a hierarchy of clusters in a bottom up approach: each
observation starts in its own cluster, and pairs of clusters are merged as
one moves up the hierarchy. The results of hierarchical clustering are
usually presented in a dendrogram.</p>
<p>In general, the merges are determined in a greedy manner. In order to decide
which clusters should be combined, a measure of dissimilarity between sets
of observations is required. In most methods of hierarchical clustering,
this is achieved by use of an appropriate metric, and a linkage criteria
which specifies the dissimilarity of sets as a function of the pairwise
distances of observations in the sets.</p>
<p>Hierarchical clustering has the distinct advantage that any valid measure
of distance can be used. In fact, the observations themselves are not
required: all that is used is a matrix of distances.</p>
<p>References</p>
<ul><li>David Eppstein. Fast hierarchical clustering and other applications of dynamic closest pairs. SODA 1998.</li>
</ul>
<h3>Parameters</h3>
<p><a name="data"></a>
<code>data</code> - The data set.</p>
<p><a name="method"></a>
<code>method</code> - the agglomeration method to merge clusters. This should be one of
    "single", "complete", "upgma", "upgmc", "wpgma", "wpgmc", and "ward".</p>
<a name="smile.clustering$hclust(kotlin.Array((smile.clustering.hclust.T)), smile.math.distance.Distance((smile.clustering.hclust.T)), kotlin.String)"></a>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <span class="identifier">hclust</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$hclust(kotlin.Array((smile.clustering.hclust.T)), smile.math.distance.Distance((smile.clustering.hclust.T)), kotlin.String)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$hclust(kotlin.Array((smile.clustering.hclust.T)), smile.math.distance.Distance((smile.clustering.hclust.T)), kotlin.String)/distance">distance</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/math/distance/Distance.html"><span class="identifier">Distance</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$hclust(kotlin.Array((smile.clustering.hclust.T)), smile.math.distance.Distance((smile.clustering.hclust.T)), kotlin.String)/method">method</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/HierarchicalClustering.html"><span class="identifier">HierarchicalClustering</span></a></code>
<p>Agglomerative Hierarchical Clustering. This method
seeks to build a hierarchy of clusters in a bottom up approach: each
observation starts in its own cluster, and pairs of clusters are merged as
one moves up the hierarchy. The results of hierarchical clustering are
usually presented in a dendrogram.</p>
<p>In general, the merges are determined in a greedy manner. In order to decide
which clusters should be combined, a measure of dissimilarity between sets
of observations is required. In most methods of hierarchical clustering,
this is achieved by use of an appropriate metric, and a linkage criteria
which specifies the dissimilarity of sets as a function of the pairwise
distances of observations in the sets.</p>
<p>Hierarchical clustering has the distinct advantage that any valid measure
of distance can be used. In fact, the observations themselves are not
required: all that is used is a matrix of distances.</p>
<p>References</p>
<ul><li>David Eppstein. Fast hierarchical clustering and other applications of dynamic closest pairs. SODA 1998.</li>
</ul>
<h3>Parameters</h3>
<p><a name="data"></a>
<code>data</code> - The data set.</p>
<p><a name="distance"></a>
<code>distance</code> - the distance/dissimilarity measure.</p>
<p><a name="method"></a>
<code>method</code> - the agglomeration method to merge clusters. This should be one of
    "single", "complete", "upgma", "upgmc", "wpgma", "wpgmc", and "ward".</p>
</BODY>
</HTML>
