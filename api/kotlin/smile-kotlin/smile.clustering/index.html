<HTML>
<HEAD>
<meta charset="UTF-8">
<title>smile.clustering - smile-kotlin</title>
<link rel="stylesheet" href="../../style.css">
</HEAD>
<BODY>
<a href="../index.html">smile-kotlin</a>&nbsp;/&nbsp;<a href="./index.html">smile.clustering</a><br/>
<br/>
<h2>Package smile.clustering</h2>
<p>Clustering analysis.</p>
 
<p>Clustering is the assignment of a set of observations
into subsets (called clusters) so that observations in the same cluster are
similar in some sense. Clustering is a method of unsupervised learning,
and a common technique for statistical data analysis used in many fields.</p>
<p>Hierarchical algorithms find successive clusters using previously
established clusters. These algorithms usually are either agglomerative
("bottom-up") or divisive ("top-down"). Agglomerative algorithms begin
with each element as a separate cluster and merge them into successively
larger clusters. Divisive algorithms begin with the whole set and proceed
to divide it into successively smaller clusters.</p>
<p>Partitional algorithms typically determine all clusters at once, but can
also be used as divisive algorithms in the hierarchical clustering.
Many partitional clustering algorithms require the specification of
the number of clusters to produce in the input data set, prior to
execution of the algorithm. Barring knowledge of the proper value
beforehand, the appropriate value must be determined, a problem on
its own for which a number of techniques have been developed.</p>
<p>Density-based clustering algorithms are devised to discover
arbitrary-shaped clusters. In this approach, a cluster is regarded as
a region in which the density of data objects exceeds a threshold.</p>
<p>Subspace clustering methods look for clusters that can only be seen in
a particular projection (subspace, manifold) of the data. These methods
thus can ignore irrelevant attributes. The general problem is also known
as Correlation clustering while the special case of axis-parallel subspaces
is also known as two-way clustering, co-clustering or biclustering in
bioinformatics: in these methods not only the objects are clustered but
also the features of the objects, i.e., if the data is represented in
a data matrix, the rows and columns are clustered simultaneously. They
usually do not however work with arbitrary feature combinations as in general
subspace methods.</p>
  
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<h4><a href="clarans.html">clarans</a></h4>
</td>
<td>
<p>Clustering Large Applications based upon RANdomized Search. CLARANS is an
efficient medoid-based clustering algorithm. The k-medoids algorithm is an
adaptation of the k-means algorithm. Rather than calculate the mean of the
items in each cluster, a representative item, or medoid, is chosen for each
cluster at each iteration. In CLARANS, the process of finding k medoids from
n objects is viewed abstractly as searching through a certain graph. In the
graph, a node is represented by a set of k objects as selected medoids. Two
nodes are neighbors if their sets differ by only one object. In each iteration,
CLARANS considers a set of randomly chosen neighbor nodes as candidate
of new medoids. We will move to the neighbor node if the neighbor
is a better choice for medoids. Otherwise, a local optima is discovered. The
entire process is repeated multiple time to find better.</p>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <span class="identifier">clarans</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$clarans(kotlin.Array((smile.clustering.clarans.T)), smile.math.distance.Distance((smile.clustering.clarans.T)), kotlin.Int, kotlin.Int, kotlin.Int)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$clarans(kotlin.Array((smile.clustering.clarans.T)), smile.math.distance.Distance((smile.clustering.clarans.T)), kotlin.Int, kotlin.Int, kotlin.Int)/distance">distance</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/math/distance/Distance.html"><span class="identifier">Distance</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$clarans(kotlin.Array((smile.clustering.clarans.T)), smile.math.distance.Distance((smile.clustering.clarans.T)), kotlin.Int, kotlin.Int, kotlin.Int)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$clarans(kotlin.Array((smile.clustering.clarans.T)), smile.math.distance.Distance((smile.clustering.clarans.T)), kotlin.Int, kotlin.Int, kotlin.Int)/maxNeighbor">maxNeighbor</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$clarans(kotlin.Array((smile.clustering.clarans.T)), smile.math.distance.Distance((smile.clustering.clarans.T)), kotlin.Int, kotlin.Int, kotlin.Int)/numLocal">numLocal</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;16<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/CLARANS.html"><span class="identifier">CLARANS</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<h4><a href="dac.html">dac</a></h4>
</td>
<td>
<p>Deterministic annealing clustering. Deterministic annealing extends
soft-clustering to an annealing process.
For each temperature value, the algorithm iterates between the calculation
of all posteriori probabilities and the update of the centroids vectors,
until convergence is reached. The annealing starts with a high temperature.
Here, all centroids vectors converge to the center of the pattern
distribution (independent of their initial positions). Below a critical
temperature the vectors start to split. Further decreasing the temperature
leads to more splittings until all centroids vectors are separate. The
annealing can therefore avoid (if it is sufficiently slow) the convergence
to local minima.</p>
<code><span class="keyword">fun </span><span class="identifier">dac</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$dac(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Int, kotlin.Double, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$dac(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Int, kotlin.Double, kotlin.Double)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$dac(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Int, kotlin.Double, kotlin.Double)/alpha">alpha</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;0.9<span class="symbol">, </span><span class="identifier" id="smile.clustering$dac(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Int, kotlin.Double, kotlin.Double)/maxIter">maxIter</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;100<span class="symbol">, </span><span class="identifier" id="smile.clustering$dac(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Int, kotlin.Double, kotlin.Double)/tol">tol</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;1E-4<span class="symbol">, </span><span class="identifier" id="smile.clustering$dac(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Int, kotlin.Double, kotlin.Double)/splitTol">splitTol</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;1E-2<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/DeterministicAnnealing.html"><span class="identifier">DeterministicAnnealing</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="dbscan.html">dbscan</a></h4>
</td>
<td>
<p>Density-Based Spatial Clustering of Applications with Noise.
DBSCAN finds a number of clusters starting from the estimated density
distribution of corresponding nodes.</p>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <span class="identifier">dbscan</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$dbscan(kotlin.Array((smile.clustering.dbscan.T)), smile.neighbor.RNNSearch((smile.clustering.dbscan.T, )), kotlin.Int, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$dbscan(kotlin.Array((smile.clustering.dbscan.T)), smile.neighbor.RNNSearch((smile.clustering.dbscan.T, )), kotlin.Int, kotlin.Double)/nns">nns</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/neighbor/RNNSearch.html"><span class="identifier">RNNSearch</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">,</span>&nbsp;<span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$dbscan(kotlin.Array((smile.clustering.dbscan.T)), smile.neighbor.RNNSearch((smile.clustering.dbscan.T, )), kotlin.Int, kotlin.Double)/minPts">minPts</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$dbscan(kotlin.Array((smile.clustering.dbscan.T)), smile.neighbor.RNNSearch((smile.clustering.dbscan.T, )), kotlin.Int, kotlin.Double)/radius">radius</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/DBSCAN.html"><span class="identifier">DBSCAN</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code><br/>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <span class="identifier">dbscan</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$dbscan(kotlin.Array((smile.clustering.dbscan.T)), smile.math.distance.Distance((smile.clustering.dbscan.T)), kotlin.Int, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$dbscan(kotlin.Array((smile.clustering.dbscan.T)), smile.math.distance.Distance((smile.clustering.dbscan.T)), kotlin.Int, kotlin.Double)/distance">distance</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/math/distance/Distance.html"><span class="identifier">Distance</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$dbscan(kotlin.Array((smile.clustering.dbscan.T)), smile.math.distance.Distance((smile.clustering.dbscan.T)), kotlin.Int, kotlin.Double)/minPts">minPts</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$dbscan(kotlin.Array((smile.clustering.dbscan.T)), smile.math.distance.Distance((smile.clustering.dbscan.T)), kotlin.Int, kotlin.Double)/radius">radius</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/DBSCAN.html"><span class="identifier">DBSCAN</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>DBSCAN with Euclidean distance.
DBSCAN finds a number of clusters starting from the estimated density
distribution of corresponding nodes.</p>
<code><span class="keyword">fun </span><span class="identifier">dbscan</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$dbscan(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$dbscan(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double)/minPts">minPts</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$dbscan(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double)/radius">radius</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/DBSCAN.html"><span class="identifier">DBSCAN</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<h4><a href="denclue.html">denclue</a></h4>
</td>
<td>
<p>DENsity CLUstering. The DENCLUE algorithm employs a cluster model based on
kernel density estimation. A cluster is defined by a local maximum of the
estimated density function. Data points going to the same local maximum
are put into the same cluster.</p>
<code><span class="keyword">fun </span><span class="identifier">denclue</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$denclue(kotlin.Array((kotlin.DoubleArray)), kotlin.Double, kotlin.Int)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$denclue(kotlin.Array((kotlin.DoubleArray)), kotlin.Double, kotlin.Int)/sigma">sigma</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$denclue(kotlin.Array((kotlin.DoubleArray)), kotlin.Double, kotlin.Int)/m">m</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/DENCLUE.html"><span class="identifier">DENCLUE</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="gmeans.html">gmeans</a></h4>
</td>
<td>
<p>G-Means clustering algorithm, an extended K-Means which tries to
automatically determine the number of clusters by normality test.
The G-means algorithm is based on a statistical test for the hypothesis
that a subset of data follows a Gaussian distribution. G-means runs
k-means with increasing k in a hierarchical fashion until the test accepts
the hypothesis that the data assigned to each k-means center are Gaussian.</p>
<code><span class="keyword">fun </span><span class="identifier">gmeans</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$gmeans(kotlin.Array((kotlin.DoubleArray)), kotlin.Int)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$gmeans(kotlin.Array((kotlin.DoubleArray)), kotlin.Int)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;100<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/GMeans.html"><span class="identifier">GMeans</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="hclust.html">hclust</a></h4>
</td>
<td>
<p>Agglomerative Hierarchical Clustering. This method
seeks to build a hierarchy of clusters in a bottom up approach: each
observation starts in its own cluster, and pairs of clusters are merged as
one moves up the hierarchy. The results of hierarchical clustering are
usually presented in a dendrogram.</p>
<code><span class="keyword">fun </span><span class="identifier">hclust</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$hclust(kotlin.Array((kotlin.DoubleArray)), kotlin.String)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$hclust(kotlin.Array((kotlin.DoubleArray)), kotlin.String)/method">method</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/HierarchicalClustering.html"><span class="identifier">HierarchicalClustering</span></a></code><br/>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <span class="identifier">hclust</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$hclust(kotlin.Array((smile.clustering.hclust.T)), smile.math.distance.Distance((smile.clustering.hclust.T)), kotlin.String)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$hclust(kotlin.Array((smile.clustering.hclust.T)), smile.math.distance.Distance((smile.clustering.hclust.T)), kotlin.String)/distance">distance</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/math/distance/Distance.html"><span class="identifier">Distance</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$hclust(kotlin.Array((smile.clustering.hclust.T)), smile.math.distance.Distance((smile.clustering.hclust.T)), kotlin.String)/method">method</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/HierarchicalClustering.html"><span class="identifier">HierarchicalClustering</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="kmeans.html">kmeans</a></h4>
</td>
<td>
<p>K-Means clustering. The algorithm partitions n observations into k clusters in which
each observation belongs to the cluster with the nearest mean.
Although finding an exact solution to the k-means problem for arbitrary
input is NP-hard, the standard approach to finding an approximate solution
(often called Lloyd's algorithm or the k-means algorithm) is used widely
and frequently finds reasonable solutions quickly.</p>
<code><span class="keyword">fun </span><span class="identifier">kmeans</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$kmeans(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Int)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$kmeans(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Int)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$kmeans(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Int)/maxIter">maxIter</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;100<span class="symbol">, </span><span class="identifier" id="smile.clustering$kmeans(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Int)/tol">tol</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;1E-4<span class="symbol">, </span><span class="identifier" id="smile.clustering$kmeans(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Int)/runs">runs</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;16<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/KMeans.html"><span class="identifier">KMeans</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="kmodes.html">kmodes</a></h4>
</td>
<td>
<p>K-Modes clustering. K-Modes is the binary equivalent for K-Means.
The mean update for centroids is replace by the mode one which is
a majority vote among element of each cluster.</p>
<code><span class="keyword">fun </span><span class="identifier">kmodes</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$kmodes(kotlin.Array((kotlin.IntArray)), kotlin.Int, kotlin.Int, kotlin.Int)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int-array/index.html"><span class="identifier">IntArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$kmodes(kotlin.Array((kotlin.IntArray)), kotlin.Int, kotlin.Int, kotlin.Int)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$kmodes(kotlin.Array((kotlin.IntArray)), kotlin.Int, kotlin.Int, kotlin.Int)/maxIter">maxIter</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;100<span class="symbol">, </span><span class="identifier" id="smile.clustering$kmodes(kotlin.Array((kotlin.IntArray)), kotlin.Int, kotlin.Int, kotlin.Int)/runs">runs</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;10<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/KModes.html"><span class="identifier">KModes</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="mec.html">mec</a></h4>
</td>
<td>
<p>Nonparametric Minimum Conditional Entropy Clustering. This method performs
very well especially when the exact number of clusters is unknown.
The method can also correctly reveal the structure of data and effectively
identify outliers simultaneously.</p>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <span class="identifier">mec</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.math.distance.Distance((smile.clustering.mec.T)), kotlin.Int, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.math.distance.Distance((smile.clustering.mec.T)), kotlin.Int, kotlin.Double)/distance">distance</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/math/distance/Distance.html"><span class="identifier">Distance</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.math.distance.Distance((smile.clustering.mec.T)), kotlin.Int, kotlin.Double)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.math.distance.Distance((smile.clustering.mec.T)), kotlin.Int, kotlin.Double)/radius">radius</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/MEC.html"><span class="identifier">MEC</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Nonparametric Minimum Conditional Entropy Clustering.</p>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <span class="identifier">mec</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.math.distance.Metric((smile.clustering.mec.T)), kotlin.Int, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.math.distance.Metric((smile.clustering.mec.T)), kotlin.Int, kotlin.Double)/distance">distance</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/math/distance/Metric.html"><span class="identifier">Metric</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.math.distance.Metric((smile.clustering.mec.T)), kotlin.Int, kotlin.Double)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.math.distance.Metric((smile.clustering.mec.T)), kotlin.Int, kotlin.Double)/radius">radius</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/MEC.html"><span class="identifier">MEC</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code><br/>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <span class="identifier">mec</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.neighbor.RNNSearch((smile.clustering.mec.T, )), kotlin.Int, kotlin.Double, kotlin.IntArray, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.neighbor.RNNSearch((smile.clustering.mec.T, )), kotlin.Int, kotlin.Double, kotlin.IntArray, kotlin.Double)/nns">nns</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/neighbor/RNNSearch.html"><span class="identifier">RNNSearch</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">,</span>&nbsp;<span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.neighbor.RNNSearch((smile.clustering.mec.T, )), kotlin.Int, kotlin.Double, kotlin.IntArray, kotlin.Double)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.neighbor.RNNSearch((smile.clustering.mec.T, )), kotlin.Int, kotlin.Double, kotlin.IntArray, kotlin.Double)/radius">radius</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.neighbor.RNNSearch((smile.clustering.mec.T, )), kotlin.Int, kotlin.Double, kotlin.IntArray, kotlin.Double)/y">y</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int-array/index.html"><span class="identifier">IntArray</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$mec(kotlin.Array((smile.clustering.mec.T)), smile.neighbor.RNNSearch((smile.clustering.mec.T, )), kotlin.Int, kotlin.Double, kotlin.IntArray, kotlin.Double)/tol">tol</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;1E-4<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/MEC.html"><span class="identifier">MEC</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Nonparametric Minimum Conditional Entropy Clustering. Assume Euclidean distance.</p>
<code><span class="keyword">fun </span><span class="identifier">mec</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$mec(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$mec(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$mec(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double)/radius">radius</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/MEC.html"><span class="identifier">MEC</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<h4><a href="sib.html">sib</a></h4>
</td>
<td>
<p>The Sequential Information Bottleneck algorithm. SIB clusters co-occurrence
data such as text documents vs words. SIB is guaranteed to converge to a local
maximum of the information. Moreover, the time and space complexity are
significantly improved in contrast to the agglomerative IB algorithm.</p>
<code><span class="keyword">fun </span><span class="identifier">sib</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$sib(kotlin.Array((smile.util.SparseArray)), kotlin.Int, kotlin.Int, kotlin.Int)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="http://haifengl.github.io/api/java/smile/util/SparseArray.html"><span class="identifier">SparseArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$sib(kotlin.Array((smile.util.SparseArray)), kotlin.Int, kotlin.Int, kotlin.Int)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$sib(kotlin.Array((smile.util.SparseArray)), kotlin.Int, kotlin.Int, kotlin.Int)/maxIter">maxIter</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;100<span class="symbol">, </span><span class="identifier" id="smile.clustering$sib(kotlin.Array((smile.util.SparseArray)), kotlin.Int, kotlin.Int, kotlin.Int)/runs">runs</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;8<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/SIB.html"><span class="identifier">SIB</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="specc.html">specc</a></h4>
</td>
<td>
<p>Spectral Clustering. Given a set of data points, the similarity matrix may
be defined as a matrix S where Sij represents a measure of the
similarity between points. Spectral clustering techniques make use of the
spectrum of the similarity matrix of the data to perform dimensionality
reduction for clustering in fewer dimensions. Then the clustering will
be performed in the dimension-reduce space, in which clusters of non-convex
shape may become tight. There are some intriguing similarities between
spectral clustering methods and kernel PCA, which has been empirically
observed to perform clustering.</p>
<code><span class="keyword">fun </span><span class="identifier">specc</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$specc(smile.math.matrix.Matrix, kotlin.Int)/W">W</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/math/matrix/Matrix.html"><span class="identifier">Matrix</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$specc(smile.math.matrix.Matrix, kotlin.Int)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/SpectralClustering.html"><span class="identifier">SpectralClustering</span></a></code>
<p>Spectral clustering.</p>
<code><span class="keyword">fun </span><span class="identifier">specc</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$specc(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$specc(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$specc(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double)/sigma">sigma</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/SpectralClustering.html"><span class="identifier">SpectralClustering</span></a></code>
<p>Spectral clustering with Nystrom approximation.</p>
<code><span class="keyword">fun </span><span class="identifier">specc</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$specc(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$specc(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Double)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$specc(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Double)/l">l</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.clustering$specc(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Double)/sigma">sigma</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/SpectralClustering.html"><span class="identifier">SpectralClustering</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="xmeans.html">xmeans</a></h4>
</td>
<td>
<p>X-Means clustering algorithm, an extended K-Means which tries to
automatically determine the number of clusters based on BIC scores.
Starting with only one cluster, the X-Means algorithm goes into action
after each run of K-Means, making local decisions about which subset of the
current centroids should split themselves in order to better fit the data.
The splitting decision is done by computing the Bayesian Information
Criterion (BIC).</p>
<code><span class="keyword">fun </span><span class="identifier">xmeans</span><span class="symbol">(</span><span class="identifier" id="smile.clustering$xmeans(kotlin.Array((kotlin.DoubleArray)), kotlin.Int)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.clustering$xmeans(kotlin.Array((kotlin.DoubleArray)), kotlin.Int)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;100<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/clustering/XMeans.html"><span class="identifier">XMeans</span></a></code></td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
