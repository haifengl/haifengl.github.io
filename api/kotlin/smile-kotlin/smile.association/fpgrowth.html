<html>
  <head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-57GD08QCML"></script>
<script type="text/javascript" src="/api/java/script-dir/gtag.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1" charset="UTF-8">
    <title>fpgrowth</title>
<link href="../../images/logo-icon.svg" rel="icon" type="image/svg"><script>var pathToRoot = "../../";</script><script type="text/javascript" src="../../scripts/sourceset_dependencies.js" async="async"></script><link href="../../styles/style.css" rel="Stylesheet"><link href="../../styles/logo-styles.css" rel="Stylesheet"><link href="../../styles/jetbrains-mono.css" rel="Stylesheet"><link href="../../styles/main.css" rel="Stylesheet"><script type="text/javascript" src="../../scripts/clipboard.js" async="async"></script><script type="text/javascript" src="../../scripts/navigation-loader.js" async="async"></script><script type="text/javascript" src="../../scripts/platform-content-handler.js" async="async"></script><script type="text/javascript" src="../../scripts/main.js" async="async"></script>  </head>
  <body>
    <div id="container">
      <div id="leftColumn"><a href="../../index.html">
          <div id="logo"></div>
        </a>
        <div id="paneSearch"></div>
        <div id="sideMenu"></div>
      </div>
      <div id="main">
        <div id="leftToggler"><span class="icon-toggler"></span></div>
<script type="text/javascript" src="../../scripts/main.js"></script>        <div class="main-content" id="content" pageIds="smile-kotlin::smile.association//fpgrowth/#kotlin.Int#kotlin.Array[kotlin.IntArray]/PointingToDeclaration//769193423">
          <div class="navigation-wrapper" id="navigation-wrapper">
            <div class="breadcrumbs"><a href="../../index.html">smile-kotlin</a>/<a href="index.html">smile.association</a>/<a href="fpgrowth.html">fpgrowth</a></div>
            <div class="pull-right d-flex">
              <div id="searchBar"></div>
            </div>
          </div>
          <div class="cover ">
            <h1 class="cover"><span><span>fpgrowth</span></span></h1>
          </div>
<div class="divergent-group" data-filterable-current=":dokkaHtml/main" data-filterable-set=":dokkaHtml/main"><div class="with-platform-tags"><span class="pull-right"></span></div>

  <div>
    <div class="platform-hinted " data-platform-hinted="data-platform-hinted"><div class="content sourceset-depenent-content" data-active="" data-togglable=":dokkaHtml/main"><div class="symbol monospace">fun <a href="fpgrowth.html">fpgrowth</a>(minSupport: <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html">Int</a>, itemsets: <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html">Array</a>&lt;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int-array/index.html">IntArray</a>&gt;): <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a>&lt;<span data-unresolved-link="smile.association/ItemSet///PointingToDeclaration/">ItemSet</span>&gt;<span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div></div></div>
  </div>
<p class="paragraph">Frequent item set mining based on the FP-growth (frequent pattern growth) algorithm, which employs an extended prefix-tree (FP-tree) structure to store the database in a compressed form. The FP-growth algorithm is currently one of the fastest approaches to discover frequent item sets. FP-growth adopts a divide-and-conquer approach to decompose both the mining tasks and the databases. It uses a pattern fragment growth method to avoid the costly process of candidate generation and testing used by Apriori.</p><p class="paragraph">The basic idea of the FP-growth algorithm can be described as a recursive elimination scheme: in a preprocessing step delete all items from the transactions that are not frequent individually, i.e., do not appear in a user-specified minimum number of transactions. Then select all transactions that contain the least frequent item (least frequent among those that are frequent) and delete this item from them. Recurse to process the obtained reduced (also known as projected) database, remembering that the item sets found in the recursion share the deleted item as a prefix. On return, remove the processed item from the database of all transactions and start over, i.e., process the second frequent item etc. In these processing steps the prefix tree, which is enhanced by links between the branches, is exploited to quickly find the transactions containing a given item and also to remove this item from the transactions after it has been processed.</p><h4 class="">Return</h4><p class="paragraph">the stream of frequent item sets.</p><h2 class="">Parameters</h2><div data-togglable="Parameters"><div class="platform-hinted WithExtraAttributes" data-platform-hinted="data-platform-hinted" data-togglable="Parameters"><div class="content sourceset-depenent-content" data-active="" data-togglable=":dokkaHtml/main"><div data-togglable="Parameters"><div class="table" data-togglable="Parameters"><div class="table-row" data-filterable-current=":dokkaHtml/main" data-filterable-set=":dokkaHtml/main"><div class="main-subrow keyValue WithExtraAttributes"><div class=""><span class="inline-flex"><span><span>itemsets</span></span></span></div><div><div class="title"><div data-togglable="Parameters"><p class="paragraph">the item set database. Each row is a item set, which     may have different length. The item identifiers have to be in [0, n),     where n is the number of items. Item set should NOT contain duplicated     items. Note that it is reordered after the call.</p></div></div></div></div></div><div class="table-row" data-filterable-current=":dokkaHtml/main" data-filterable-set=":dokkaHtml/main"><div class="main-subrow keyValue WithExtraAttributes"><div class=""><span class="inline-flex"><span>min</span><wbr></wbr><span><span>Support</span></span></span></div><div><div class="title"><div data-togglable="Parameters"><p class="paragraph">the required minimum support of item sets in terms     of frequency.</p></div></div></div></div></div></div></div></div></div></div></div>
<div class="divergent-group" data-filterable-current=":dokkaHtml/main" data-filterable-set=":dokkaHtml/main"><div class="with-platform-tags"><span class="pull-right"></span></div>

  <div>
    <div class="platform-hinted " data-platform-hinted="data-platform-hinted"><div class="content sourceset-depenent-content" data-active="" data-togglable=":dokkaHtml/main"><div class="symbol monospace">fun <a href="fpgrowth.html">fpgrowth</a>(tree: <span data-unresolved-link="smile.association/FPTree///PointingToDeclaration/">FPTree</span>): <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a>&lt;<span data-unresolved-link="smile.association/ItemSet///PointingToDeclaration/">ItemSet</span>&gt;<span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div></div></div>
  </div>
<p class="paragraph">Frequent item set mining based on the FP-growth (frequent pattern growth) algorithm, which employs an extended prefix-tree (FP-tree) structure to store the database in a compressed form. The FP-growth algorithm is currently one of the fastest approaches to discover frequent item sets. FP-growth adopts a divide-and-conquer approach to decompose both the mining tasks and the databases. It uses a pattern fragment growth method to avoid the costly process of candidate generation and testing used by Apriori.</p><p class="paragraph">The basic idea of the FP-growth algorithm can be described as a recursive elimination scheme: in a preprocessing step delete all items from the transactions that are not frequent individually, i.e., do not appear in a user-specified minimum number of transactions. Then select all transactions that contain the least frequent item (least frequent among those that are frequent) and delete this item from them. Recurse to process the obtained reduced (also known as projected) database, remembering that the item sets found in the recursion share the deleted item as a prefix. On return, remove the processed item from the database of all transactions and start over, i.e., process the second frequent item etc. In these processing steps the prefix tree, which is enhanced by links between the branches, is exploited to quickly find the transactions containing a given item and also to remove this item from the transactions after it has been processed.</p><h4 class="">Return</h4><p class="paragraph">the stream of frequent item sets.</p><h2 class="">Parameters</h2><div data-togglable="Parameters"><div class="platform-hinted WithExtraAttributes" data-platform-hinted="data-platform-hinted" data-togglable="Parameters"><div class="content sourceset-depenent-content" data-active="" data-togglable=":dokkaHtml/main"><div data-togglable="Parameters"><div class="table" data-togglable="Parameters"><div class="table-row" data-filterable-current=":dokkaHtml/main" data-filterable-set=":dokkaHtml/main"><div class="main-subrow keyValue WithExtraAttributes"><div class=""><span class="inline-flex"><span><span>tree</span></span></span></div><div><div class="title"><div data-togglable="Parameters"><p class="paragraph">the FP-tree of item set database.</p></div></div></div></div></div></div></div></div></div></div></div>
        </div>
        <div class="footer"><span class="go-to-top-icon"><a href="#content"></a></span><span>Â© 2024 Copyright</span><span class="pull-right"><span>Generated by </span><a href="https://github.com/Kotlin/dokka"><span>dokka</span><span class="padded-icon"></span></a></span></div>
      </div>
    </div>
  </body>
</html>

