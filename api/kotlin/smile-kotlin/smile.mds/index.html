<HTML>
<HEAD>
<meta charset="UTF-8">
<title>smile.mds - smile-kotlin</title>
<link rel="stylesheet" href="../../style.css">
</HEAD>
<BODY>
<a href="../index.html">smile-kotlin</a>&nbsp;/&nbsp;<a href="./index.html">smile.mds</a><br/>
<br/>
<h2>Package smile.mds</h2>
<p>Multidimensional scaling.</p>
 
<p>MDS is a set of related statistical techniques
often used in information visualization for exploring similarities or
dissimilarities in data. An MDS algorithm starts with a matrix of item-item
similarities, then assigns a location to each item in N-dimensional space.
For sufficiently small N, the resulting locations may be displayed in a
graph or 3D visualization.</p>
<p>The major types of MDS algorithms include:</p>
<ul><li><strong>Classical multidimensional scaling</strong> takes an input matrix giving
 dissimilarities between pairs of items and
outputs a coordinate matrix whose configuration minimizes a loss function
called strain.</li>

<li><strong>Metric multidimensional scaling</strong> is
a superset of classical MDS that generalizes the optimization procedure
to a variety of loss functions and input matrices of known distances with
weights and so on. A useful loss function in this context is called stress
which is often minimized using a procedure called stress majorization.</li>

<li><strong>Non-metric multidimensional scaling</strong> finds both a non-parametric
monotonic relationship between the dissimilarities in the item-item matrix
and the Euclidean distances between items, and the location of each item in
the low-dimensional space. The relationship is typically found using isotonic
regression.</li>

<li><strong>Generalized multidimensional scaling</strong> is
an extension of metric multidimensional scaling, in which the target
space is an arbitrary smooth non-Euclidean space. In case when the
dissimilarities are distances on a surface and the target space is another
surface, GMDS allows finding the minimum-distortion embedding of one surface
into another.</li>
</ul>
  
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<h4><a href="isomds.html">isomds</a></h4>
</td>
<td>
<p>Kruskal's nonmetric MDS. In non-metric MDS, only the rank order of entries
in the proximity matrix (not the actual dissimilarities) is assumed to
contain the significant information. Hence, the distances of the final
configuration should as far as possible be in the same rank order as the
original data. Note that a perfect ordinal re-scaling of the data into
distances is usually not possible. The relationship is typically found
using isotonic regression.</p>
<code><span class="keyword">fun </span><span class="identifier">isomds</span><span class="symbol">(</span><span class="identifier" id="smile.mds$isomds(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Int)/proximity">proximity</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.mds$isomds(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Int)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.mds$isomds(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Int)/tol">tol</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;0.0001<span class="symbol">, </span><span class="identifier" id="smile.mds$isomds(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Int)/maxIter">maxIter</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;200<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/mds/IsotonicMDS.html"><span class="identifier">IsotonicMDS</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="mds.html">mds</a></h4>
</td>
<td>
<p>Classical multidimensional scaling, also known as principal coordinates
analysis. Given a matrix of dissimilarities (e.g. pairwise distances), MDS
finds a set of points in low dimensional space that well-approximates the
dissimilarities in A. We are not restricted to using a Euclidean
distance metric. However, when Euclidean distances are used MDS is
equivalent to PCA.</p>
<code><span class="keyword">fun </span><span class="identifier">mds</span><span class="symbol">(</span><span class="identifier" id="smile.mds$mds(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Boolean)/proximity">proximity</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.mds$mds(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Boolean)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.mds$mds(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Boolean)/positive">positive</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a>&nbsp;<span class="symbol">=</span>&nbsp;false<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/mds/MDS.html"><span class="identifier">MDS</span></a></code></td>
</tr>
<tr>
<td>
<h4><a href="sammon.html">sammon</a></h4>
</td>
<td>
<p>The Sammon's mapping is an iterative technique for making interpoint
distances in the low-dimensional projection as close as possible to the
interpoint distances in the high-dimensional object. Two points close
together in the high-dimensional space should appear close together in the
projection, while two points far apart in the high dimensional space should
appear far apart in the projection. The Sammon's mapping is a special case of
metric least-square multidimensional scaling.</p>
<code><span class="keyword">fun </span><span class="identifier">sammon</span><span class="symbol">(</span><span class="identifier" id="smile.mds$sammon(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int)/proximity">proximity</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.mds$sammon(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="smile.mds$sammon(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int)/lambda">lambda</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;0.2<span class="symbol">, </span><span class="identifier" id="smile.mds$sammon(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int)/tol">tol</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;0.0001<span class="symbol">, </span><span class="identifier" id="smile.mds$sammon(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int)/stepTol">stepTol</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;0.001<span class="symbol">, </span><span class="identifier" id="smile.mds$sammon(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int)/maxIter">maxIter</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;100<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/mds/SammonMapping.html"><span class="identifier">SammonMapping</span></a></code></td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
