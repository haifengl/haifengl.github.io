<HTML>
<HEAD>
<meta charset="UTF-8">
<title>umap - smile-kotlin</title>
<link rel="stylesheet" href="../../style.css">
</HEAD>
<BODY>
<a href="../index.html">smile-kotlin</a>&nbsp;/&nbsp;<a href="index.html">smile.manifold</a>&nbsp;/&nbsp;<a href="./umap.html">umap</a><br/>
<br/>
<h1>umap</h1>
<a name="smile.manifold$umap(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)"></a>
<code><span class="keyword">fun </span><span class="identifier">umap</span><span class="symbol">(</span><span class="identifier" id="smile.manifold$umap(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html"><span class="identifier">DoubleArray</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;15<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/d">d</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;2<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/iterations">iterations</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;0<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/learningRate">learningRate</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;1.0<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/minDist">minDist</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;0.1<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/spread">spread</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;1.0<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/negativeSamples">negativeSamples</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;5<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((kotlin.DoubleArray)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/repulsionStrength">repulsionStrength</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;1.0<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/manifold/UMAP.html"><span class="identifier">UMAP</span></a></code>
<p>Uniform Manifold Approximation and Projection.</p>
<p>UMAP is a dimension reduction technique that can be used for visualization
similarly to t-SNE, but also for general non-linear dimension reduction.
The algorithm is founded on three assumptions about the data:</p>
<ul><li>The data is uniformly distributed on a Riemannian manifold;</li>
<li>The Riemannian metric is locally constant (or can be approximated as such);</li>
<li>The manifold is locally connected.</li>
</ul>
<p>From these assumptions it is possible to model the manifold with a fuzzy
topological structure. The embedding is found by searching for a low
dimensional projection of the data that has the closest possible equivalent
fuzzy topological structure.</p>
<h3>Parameters</h3>
<p><a name="data"></a>
<code>data</code> - the input data.</p>
<p><a name="k"></a>
<code>k</code> - k-nearest neighbors. Larger values result in more global views
    of the manifold, while smaller values result in more local data
    being preserved. Generally in the range 2 to 100.</p>
<p><a name="d"></a>
<code>d</code> - The target embedding dimensions. defaults to 2 to provide easy
    visualization, but can reasonably be set to any integer value
    in the range 2 to 100.</p>
<p><a name="iterations"></a>
<code>iterations</code> - The number of iterations to optimize the
    low-dimensional representation. Larger values result in more
    accurate embedding. Muse be at least 10. Choose wise value
    based on the size of the input data, e.g, 200 for large
    data (1000+ samples), 500 for small.</p>
<p><a name="learningRate"></a>
<code>learningRate</code> - The initial learning rate for the embedding optimization,
    default 1.</p>
<p><a name="minDist"></a>
<code>minDist</code> - The desired separation between close points in the embedding
    space. Smaller values will result in a more clustered/clumped
    embedding where nearby points on the manifold are drawn closer
    together, while larger values will result on a more even
    disperse of points. The value should be set no-greater than
    and relative to the spread value, which determines the scale
    at which embedded points will be spread out. default 0.1.</p>
<p><a name="spread"></a>
<code>spread</code> - The effective scale of embedded points. In combination with
    minDist, this determines how clustered/clumped the embedded
    points are. default 1.0.</p>
<p><a name="negativeSamples"></a>
<code>negativeSamples</code> - The number of negative samples to select per positive sample
    in the optimization process. Increasing this value will result
    in greater repulsive force being applied, greater optimization
    cost, but slightly more accuracy, default 5.</p>
<p><a name="repulsionStrength"></a>
<code>repulsionStrength</code> - Weighting applied to negative samples in low dimensional
    embedding optimization. Values higher than one will result in
    greater weight being given to negative samples, default 1.0.</p>
<a name="smile.manifold$umap(kotlin.Array((smile.manifold.umap.T)), smile.math.distance.Distance((smile.manifold.umap.T)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)"></a>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <span class="identifier">umap</span><span class="symbol">(</span><span class="identifier" id="smile.manifold$umap(kotlin.Array((smile.manifold.umap.T)), smile.math.distance.Distance((smile.manifold.umap.T)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/data">data</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/index.html"><span class="identifier">Array</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((smile.manifold.umap.T)), smile.math.distance.Distance((smile.manifold.umap.T)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/distance">distance</span><span class="symbol">:</span>&nbsp;<a href="http://haifengl.github.io/api/java/smile/math/distance/Distance.html"><span class="identifier">Distance</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((smile.manifold.umap.T)), smile.math.distance.Distance((smile.manifold.umap.T)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/k">k</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;15<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((smile.manifold.umap.T)), smile.math.distance.Distance((smile.manifold.umap.T)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/d">d</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;2<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((smile.manifold.umap.T)), smile.math.distance.Distance((smile.manifold.umap.T)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/iterations">iterations</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;0<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((smile.manifold.umap.T)), smile.math.distance.Distance((smile.manifold.umap.T)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/learningRate">learningRate</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;1.0<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((smile.manifold.umap.T)), smile.math.distance.Distance((smile.manifold.umap.T)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/minDist">minDist</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;0.1<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((smile.manifold.umap.T)), smile.math.distance.Distance((smile.manifold.umap.T)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/spread">spread</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;1.0<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((smile.manifold.umap.T)), smile.math.distance.Distance((smile.manifold.umap.T)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/negativeSamples">negativeSamples</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;5<span class="symbol">, </span><span class="identifier" id="smile.manifold$umap(kotlin.Array((smile.manifold.umap.T)), smile.math.distance.Distance((smile.manifold.umap.T)), kotlin.Int, kotlin.Int, kotlin.Int, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Int, kotlin.Double)/repulsionStrength">repulsionStrength</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html"><span class="identifier">Double</span></a>&nbsp;<span class="symbol">=</span>&nbsp;1.0<span class="symbol">)</span><span class="symbol">: </span><a href="http://haifengl.github.io/api/java/smile/manifold/UMAP.html"><span class="identifier">UMAP</span></a></code>
<p>Uniform Manifold Approximation and Projection.</p>
<p>UMAP is a dimension reduction technique that can be used for visualization
similarly to t-SNE, but also for general non-linear dimension reduction.
The algorithm is founded on three assumptions about the data:</p>
<ul><li>The data is uniformly distributed on a Riemannian manifold;</li>
<li>The Riemannian metric is locally constant (or can be approximated as such);</li>
<li>The manifold is locally connected.</li>
</ul>
<p>From these assumptions it is possible to model the manifold with a fuzzy
topological structure. The embedding is found by searching for a low
dimensional projection of the data that has the closest possible equivalent
fuzzy topological structure.</p>
<h3>Parameters</h3>
<p><a name="data"></a>
<code>data</code> - the input data.</p>
<p><a name="distance"></a>
<code>distance</code> - the distance measure.</p>
<p><a name="k"></a>
<code>k</code> - k-nearest neighbors. Larger values result in more global views
    of the manifold, while smaller values result in more local data
    being preserved. Generally in the range 2 to 100.</p>
<p><a name="d"></a>
<code>d</code> - The target embedding dimensions. defaults to 2 to provide easy
    visualization, but can reasonably be set to any integer value
    in the range 2 to 100.</p>
<p><a name="iterations"></a>
<code>iterations</code> - The number of iterations to optimize the
    low-dimensional representation. Larger values result in more
    accurate embedding. Muse be at least 10. Choose wise value
    based on the size of the input data, e.g, 200 for large
    data (1000+ samples), 500 for small.</p>
<p><a name="learningRate"></a>
<code>learningRate</code> - The initial learning rate for the embedding optimization,
    default 1.</p>
<p><a name="minDist"></a>
<code>minDist</code> - The desired separation between close points in the embedding
    space. Smaller values will result in a more clustered/clumped
    embedding where nearby points on the manifold are drawn closer
    together, while larger values will result on a more even
    disperse of points. The value should be set no-greater than
    and relative to the spread value, which determines the scale
    at which embedded points will be spread out. default 0.1.</p>
<p><a name="spread"></a>
<code>spread</code> - The effective scale of embedded points. In combination with
    minDist, this determines how clustered/clumped the embedded
    points are. default 1.0.</p>
<p><a name="negativeSamples"></a>
<code>negativeSamples</code> - The number of negative samples to select per positive sample
    in the optimization process. Increasing this value will result
    in greater repulsive force being applied, greater optimization
    cost, but slightly more accuracy, default 5.</p>
<p><a name="repulsionStrength"></a>
<code>repulsionStrength</code> - Weighting applied to negative samples in low dimensional
    embedding optimization. Values higher than one will result in
    greater weight being given to negative samples, default 1.0.</p>
</BODY>
</HTML>
